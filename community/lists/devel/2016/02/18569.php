<?
$subject_val = "Re: [OMPI devel] [OMPI commits] Git: open-mpi/ompi-release branch v2.x updated. v2.x-dev-1078-gefeac60";
include("../../include/msg-header.inc");
?>
<!-- received="Sun Feb  7 08:05:46 2016" -->
<!-- isoreceived="20160207130546" -->
<!-- sent="Sun, 7 Feb 2016 08:05:40 -0500" -->
<!-- isosent="20160207130540" -->
<!-- name="George Bosilca" -->
<!-- email="bosilca_at_[hidden]" -->
<!-- subject="Re: [OMPI devel] [OMPI commits] Git: open-mpi/ompi-release branch v2.x updated. v2.x-dev-1078-gefeac60" -->
<!-- id="CAMJJpkV0Q7piZxgxMP7QmBOuiaw=zX-yEYF4aLS4qUCocSpoFg_at_mail.gmail.com" -->
<!-- charset="UTF-8" -->
<!-- inreplyto="20160207130132.1D654260EDA_at_lion.crest.iu.edu" -->
<!-- expires="-1" -->
<div class="center">
<table border="2" width="100%" class="links">
<tr>
<th><a href="date.php">Date view</a></th>
<th><a href="index.php">Thread view</a></th>
<th><a href="subject.php">Subject view</a></th>
<th><a href="author.php">Author view</a></th>
</tr>
</table>
</div>
<p class="headers">
<strong>Subject:</strong> Re: [OMPI devel] [OMPI commits] Git: open-mpi/ompi-release branch v2.x updated. v2.x-dev-1078-gefeac60<br>
<strong>From:</strong> George Bosilca (<em>bosilca_at_[hidden]</em>)<br>
<strong>Date:</strong> 2016-02-07 08:05:40
</p>
<ul class="links">
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="18570.php">Jeff Squyres (jsquyres): "Re: [OMPI devel] orted hangs on SLES12 when running 80 ranks per node"</a>
<li><strong>Previous message:</strong> <a href="18568.php">Justin Cinkelj: "Re: [OMPI devel] mpirun --launch-proxy options"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
</ul>
<hr>
<!-- body="start" -->
<p>
There was a typo in this patch. I saw it in the trunk but I missed the
<br>
pending PR. Please move 7c574a35309 as well
<br>
<p>&nbsp;&nbsp;George.
<br>
<p><p>On Sun, Feb 7, 2016 at 8:01 AM, &lt;gitdub_at_[hidden]&gt; wrote:
<br>
<p><span class="quotelev1">&gt; This is an automated email from the git hooks/post-receive script. It was
</span><br>
<span class="quotelev1">&gt; generated because a ref change was pushed to the repository containing
</span><br>
<span class="quotelev1">&gt; the project &quot;open-mpi/ompi-release&quot;.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; The branch, v2.x has been updated
</span><br>
<span class="quotelev1">&gt;        via  efeac60a18a06d4224394dbce41c4486b28ca194 (commit)
</span><br>
<span class="quotelev1">&gt;        via  0e8f2675bf13dd6aa34cbf4492f92a5cddcaaf6f (commit)
</span><br>
<span class="quotelev1">&gt;        via  245147390edeb9cd9fab1d08610f83841588989b (commit)
</span><br>
<span class="quotelev1">&gt;        via  98532dda3d642f845498a40e7e1c660f13ab67aa (commit)
</span><br>
<span class="quotelev1">&gt;        via  b1cb049a9d9a486c6e08bd2966b0033e30df7055 (commit)
</span><br>
<span class="quotelev1">&gt;       from  1280d534de59030c4311fb55df455d0739362e9f (commit)
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; Those revisions listed above that are new to this repository have
</span><br>
<span class="quotelev1">&gt; not appeared on any other notification email; so we list those
</span><br>
<span class="quotelev1">&gt; revisions in full, below.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; - Log -----------------------------------------------------------------
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; <a href="https://github.com/open-mpi/ompi-release/commit/efeac60a18a06d4224394dbce41c4486b28ca194">https://github.com/open-mpi/ompi-release/commit/efeac60a18a06d4224394dbce41c4486b28ca194</a>
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; commit efeac60a18a06d4224394dbce41c4486b28ca194
</span><br>
<span class="quotelev1">&gt; Merge: 1280d53 0e8f267
</span><br>
<span class="quotelev1">&gt; Author: Jeff Squyres &lt;jsquyres_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt; Date:   Sun Feb 7 08:01:26 2016 -0500
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Merge pull request #947 from hjelmn/v2.x_osc_pt2pt_fixes
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     v2.x osc/pt2pt fixes
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; <a href="https://github.com/open-mpi/ompi-release/commit/0e8f2675bf13dd6aa34cbf4492f92a5cddcaaf6f">https://github.com/open-mpi/ompi-release/commit/0e8f2675bf13dd6aa34cbf4492f92a5cddcaaf6f</a>
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; commit 0e8f2675bf13dd6aa34cbf4492f92a5cddcaaf6f
</span><br>
<span class="quotelev1">&gt; Author: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt; Date:   Thu Feb 4 16:59:39 2016 -0700
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     osc/pt2pt: bug fixes
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     This commit fixes several bugs identified by @ggouaillardet and MTT:
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      - Fix SEGV in long send completion caused by missing update to the
</span><br>
<span class="quotelev1">&gt;        request callback data.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      - Add an MPI_Barrier to the fence short-cut. This fixes potential
</span><br>
<span class="quotelev1">&gt;        semantic issues where messages may be received before fence is
</span><br>
<span class="quotelev1">&gt;        reached.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      - Ensure fragments are flushed when using request-based RMA. This
</span><br>
<span class="quotelev1">&gt;        allows MPI_Test/MPI_Wait/etc to work as expected.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      - Restore the tag space back to 16-bits. It was intended that the
</span><br>
<span class="quotelev1">&gt;        space be expanded to 32-bits but the required change to the
</span><br>
<span class="quotelev1">&gt;        fragment headers was not committed. The tag space may be expanded
</span><br>
<span class="quotelev1">&gt;        in a later commit.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Signed-off-by: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     (cherry picked from commit
</span><br>
<span class="quotelev1">&gt; open-mpi/ompi_at_5b9c82a9648b06364b695e199711e1c26a3afeeb)
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Signed-off-by: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; index 409011d..68ca022 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; @@ -631,8 +631,8 @@ static inline void osc_pt2pt_add_pending
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_pending_t *pending)
</span><br>
<span class="quotelev1">&gt;                              opal_list_append
</span><br>
<span class="quotelev1">&gt; (&amp;mca_osc_pt2pt_component.pending_operations, &amp;pending-&gt;super));
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -#define OSC_PT2PT_FRAG_TAG   0x80000
</span><br>
<span class="quotelev1">&gt; -#define OSC_PT2PT_FRAG_MASK  0x7ffff
</span><br>
<span class="quotelev1">&gt; +#define OSC_PT2PT_FRAG_TAG   0x10000
</span><br>
<span class="quotelev1">&gt; +#define OSC_PT2PT_FRAG_MASK  0x0ffff
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  /**
</span><br>
<span class="quotelev1">&gt;   * get_tag:
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; index 58d6b40..0b3c2e0 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; @@ -147,6 +147,7 @@ int ompi_osc_pt2pt_fence(int assert, ompi_win_t *win)
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* short-circuit the noprecede case */
</span><br>
<span class="quotelev1">&gt;      if (0 != (assert &amp; MPI_MODE_NOPRECEDE)) {
</span><br>
<span class="quotelev1">&gt; +        module-&gt;comm-&gt;c_coll.coll_barrier (module-&gt;comm,
</span><br>
<span class="quotelev1">&gt; module-&gt;comm-&gt;c_coll.coll_barrier);
</span><br>
<span class="quotelev1">&gt;          OPAL_OUTPUT_VERBOSE((50, ompi_osc_base_framework.framework_output,
</span><br>
<span class="quotelev1">&gt;                               &quot;osc pt2pt: fence end (short circuit)&quot;));
</span><br>
<span class="quotelev1">&gt;          return ret;
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; index a1dcfd7..1205767 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; @@ -58,6 +58,9 @@ static int ompi_osc_pt2pt_req_comm_complete
</span><br>
<span class="quotelev1">&gt; (ompi_request_t *request)
</span><br>
<span class="quotelev1">&gt;                           &quot;ompi_osc_pt2pt_req_comm_complete called tag =
</span><br>
<span class="quotelev1">&gt; %d&quot;,
</span><br>
<span class="quotelev1">&gt;                           request-&gt;req_status.MPI_TAG));
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +    /* update the cbdata for ompi_osc_pt2pt_comm_complete */
</span><br>
<span class="quotelev1">&gt; +    request-&gt;req_complete_cb_data = pt2pt_request-&gt;module;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;      if (0 == OPAL_THREAD_ADD32(&amp;pt2pt_request-&gt;outstanding_requests, -1))
</span><br>
<span class="quotelev1">&gt; {
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_request_complete (pt2pt_request,
</span><br>
<span class="quotelev1">&gt; request-&gt;req_status.MPI_ERROR);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt; @@ -218,8 +221,8 @@ static inline int ompi_osc_pt2pt_gacc_self
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_sync_t *pt2pt_sync, c
</span><br>
<span class="quotelev1">&gt;          ((unsigned long) target_disp * module-&gt;disp_unit);
</span><br>
<span class="quotelev1">&gt;      int ret;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    /* if we are in active target mode wait until all post messages
</span><br>
<span class="quotelev1">&gt; arrive */
</span><br>
<span class="quotelev1">&gt; -    ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt; +    OPAL_OUTPUT_VERBOSE((MCA_BASE_VERBOSE_TRACE,
</span><br>
<span class="quotelev1">&gt; ompi_osc_base_framework.framework_output, &quot;ompi_osc_pt2pt_gacc_self:
</span><br>
<span class="quotelev1">&gt; starting local &quot;
</span><br>
<span class="quotelev1">&gt; +                         &quot;get accumulate&quot;));
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_accumulate_lock (module);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -250,6 +253,9 @@ static inline int ompi_osc_pt2pt_gacc_self
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_sync_t *pt2pt_sync, c
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_accumulate_unlock (module);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +    OPAL_OUTPUT_VERBOSE((MCA_BASE_VERBOSE_TRACE,
</span><br>
<span class="quotelev1">&gt; ompi_osc_base_framework.framework_output, &quot;ompi_osc_pt2pt_gacc_self: local
</span><br>
<span class="quotelev1">&gt; get &quot;
</span><br>
<span class="quotelev1">&gt; +                         &quot;accumulate complete&quot;));
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;      if (request) {
</span><br>
<span class="quotelev1">&gt;          /* NTH: is it ok to use an ompi error code here? */
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_request_complete (request, ret);
</span><br>
<span class="quotelev1">&gt; @@ -310,14 +316,14 @@ static inline int ompi_osc_pt2pt_put_w_req (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin_
</span><br>
<span class="quotelev1">&gt;      payload_len = origin_dt-&gt;super.size * origin_count;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + ddt_len +
</span><br>
<span class="quotelev1">&gt; payload_len;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false, true);
</span><br>
<span class="quotelev1">&gt;      if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, true, false);
</span><br>
<span class="quotelev1">&gt;          if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;              /* allocate space for the header plus space to store ddt_len
</span><br>
<span class="quotelev1">&gt; */
</span><br>
<span class="quotelev1">&gt;              frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + 8;
</span><br>
<span class="quotelev1">&gt; -            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true, false);
</span><br>
<span class="quotelev1">&gt;              if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;                  return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt; @@ -469,14 +475,14 @@ ompi_osc_pt2pt_accumulate_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_count,
</span><br>
<span class="quotelev1">&gt;      payload_len = origin_dt-&gt;super.size * origin_count;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(*header) + ddt_len + payload_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false, true);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(*header) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, true, !request);
</span><br>
<span class="quotelev1">&gt;          if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;              /* allocate space for the header plus space to store ddt_len
</span><br>
<span class="quotelev1">&gt; */
</span><br>
<span class="quotelev1">&gt;              frag_len = sizeof(*header) + 8;
</span><br>
<span class="quotelev1">&gt; -            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true, !request);
</span><br>
<span class="quotelev1">&gt;              if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;                  return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt; @@ -488,7 +494,7 @@ ompi_osc_pt2pt_accumulate_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_count,
</span><br>
<span class="quotelev1">&gt;          tag = get_rtag (module);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    if (is_long_msg || is_long_datatype) {
</span><br>
<span class="quotelev1">&gt; +    if (is_long_msg) {
</span><br>
<span class="quotelev1">&gt;          /* wait for synchronization before posting a long message */
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt; @@ -631,7 +637,7 @@ int ompi_osc_pt2pt_compare_and_swap (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, const void *compar
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(ompi_osc_pt2pt_header_cswap_t) + ddt_len +
</span><br>
<span class="quotelev1">&gt; payload_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false, false);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt; @@ -663,9 +669,7 @@ int ompi_osc_pt2pt_compare_and_swap (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, const void *compar
</span><br>
<span class="quotelev1">&gt;          return ret;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return ret;
</span><br>
<span class="quotelev1">&gt; +    return ompi_osc_pt2pt_frag_finish (module, frag);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -779,11 +783,11 @@ static inline int ompi_osc_pt2pt_rget_internal (void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_co
</span><br>
<span class="quotelev1">&gt;      ddt_len = ompi_datatype_pack_description_length(target_dt);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(ompi_osc_pt2pt_header_get_t) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false, release_req);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          /* allocate space for the header plus space to store ddt_len */
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + 8;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false, release_req);
</span><br>
<span class="quotelev1">&gt;          if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;              return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt; @@ -961,6 +965,11 @@ int ompi_osc_pt2pt_rget_accumulate_internal (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin
</span><br>
<span class="quotelev1">&gt;          return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +    if (!release_req) {
</span><br>
<span class="quotelev1">&gt; +        /* wait for epoch to begin before starting operation */
</span><br>
<span class="quotelev1">&gt; +        ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt; +    }
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;      /* optimize the self case. TODO: optimize the local case */
</span><br>
<span class="quotelev1">&gt;      if (ompi_comm_rank (module-&gt;comm) == target_rank) {
</span><br>
<span class="quotelev1">&gt;          *request = &amp;pt2pt_request-&gt;super;
</span><br>
<span class="quotelev1">&gt; @@ -987,14 +996,14 @@ int ompi_osc_pt2pt_rget_accumulate_internal (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(*header) + ddt_len + payload_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false, release_req);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(*header) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true, release_req);
</span><br>
<span class="quotelev1">&gt;          if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;              /* allocate space for the header plus space to store ddt_len
</span><br>
<span class="quotelev1">&gt; */
</span><br>
<span class="quotelev1">&gt;              frag_len = sizeof(*header) + 8;
</span><br>
<span class="quotelev1">&gt; -            ret = ompi_osc_pt2pt_frag_alloc(module, target_rank,
</span><br>
<span class="quotelev1">&gt; frag_len, &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_frag_alloc(module, target_rank,
</span><br>
<span class="quotelev1">&gt; frag_len, &amp;frag, &amp;ptr, true, release_req);
</span><br>
<span class="quotelev1">&gt;              if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;                  return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt; @@ -1014,11 +1023,6 @@ int ompi_osc_pt2pt_rget_accumulate_internal (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin
</span><br>
<span class="quotelev1">&gt;      /* increment the number of outgoing fragments */
</span><br>
<span class="quotelev1">&gt;      ompi_osc_signal_outgoing (module, target_rank,
</span><br>
<span class="quotelev1">&gt; pt2pt_request-&gt;outstanding_requests);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    if (!release_req) {
</span><br>
<span class="quotelev1">&gt; -        /* wait for epoch to begin before starting operation */
</span><br>
<span class="quotelev1">&gt; -        ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt; -    }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt;      header = (ompi_osc_pt2pt_header_acc_t *) ptr;
</span><br>
<span class="quotelev1">&gt;      header-&gt;base.flags = 0;
</span><br>
<span class="quotelev1">&gt;      header-&gt;len = frag_len;
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; index 09bd285..681e73a 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; @@ -213,7 +213,7 @@ int ompi_osc_pt2pt_control_send
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, int target,
</span><br>
<span class="quotelev1">&gt;      char *ptr;
</span><br>
<span class="quotelev1">&gt;      int ret;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, len, &amp;frag, &amp;ptr,
</span><br>
<span class="quotelev1">&gt; false);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, len, &amp;frag, &amp;ptr,
</span><br>
<span class="quotelev1">&gt; false, true);
</span><br>
<span class="quotelev1">&gt;      if (OPAL_LIKELY(OMPI_SUCCESS == ret)) {
</span><br>
<span class="quotelev1">&gt;          memcpy (ptr, data, len);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; index f55e6cb..da51b7d 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; @@ -57,16 +57,62 @@ static inline int ompi_osc_pt2pt_frag_finish
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module,
</span><br>
<span class="quotelev1">&gt;      return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +static inline ompi_osc_pt2pt_frag_t
</span><br>
<span class="quotelev1">&gt; *ompi_osc_pt2pt_frag_alloc_non_buffered (ompi_osc_pt2pt_module_t *module,
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;    ompi_osc_pt2pt_peer_t *peer,
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;    size_t request_len)
</span><br>
<span class="quotelev1">&gt; +{
</span><br>
<span class="quotelev1">&gt; +    ompi_osc_pt2pt_frag_t *curr;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    /* to ensure ordering flush the buffer on the peer */
</span><br>
<span class="quotelev1">&gt; +    curr = peer-&gt;active_frag;
</span><br>
<span class="quotelev1">&gt; +    if (NULL != curr &amp;&amp; opal_atomic_cmpset (&amp;peer-&gt;active_frag, curr,
</span><br>
<span class="quotelev1">&gt; NULL)) {
</span><br>
<span class="quotelev1">&gt; +        /* If there's something pending, the pending finish will
</span><br>
<span class="quotelev1">&gt; +           start the buffer.  Otherwise, we need to start it now. */
</span><br>
<span class="quotelev1">&gt; +        int ret = ompi_osc_pt2pt_frag_finish (module, curr);
</span><br>
<span class="quotelev1">&gt; +        if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt; +            return NULL;
</span><br>
<span class="quotelev1">&gt; +        }
</span><br>
<span class="quotelev1">&gt; +    }
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    curr = (ompi_osc_pt2pt_frag_t *) opal_free_list_get
</span><br>
<span class="quotelev1">&gt; (&amp;mca_osc_pt2pt_component.frags);
</span><br>
<span class="quotelev1">&gt; +    if (OPAL_UNLIKELY(NULL == curr)) {
</span><br>
<span class="quotelev1">&gt; +        return NULL;
</span><br>
<span class="quotelev1">&gt; +    }
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;target = peer-&gt;rank;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;header = (ompi_osc_pt2pt_frag_header_t*) curr-&gt;buffer;
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;top = (char*) (curr-&gt;header + 1);
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;remain_len = mca_osc_pt2pt_component.buffer_size;
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;module = module;
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;pending = 1;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;header-&gt;base.type = OMPI_OSC_PT2PT_HDR_TYPE_FRAG;
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;header-&gt;base.flags = OMPI_OSC_PT2PT_HDR_FLAG_VALID;
</span><br>
<span class="quotelev1">&gt; +    if (module-&gt;passive_target_access_epoch) {
</span><br>
<span class="quotelev1">&gt; +        curr-&gt;header-&gt;base.flags |=
</span><br>
<span class="quotelev1">&gt; OMPI_OSC_PT2PT_HDR_FLAG_PASSIVE_TARGET;
</span><br>
<span class="quotelev1">&gt; +    }
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;header-&gt;source = ompi_comm_rank(module-&gt;comm);
</span><br>
<span class="quotelev1">&gt; +    curr-&gt;header-&gt;num_ops = 1;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    return curr;
</span><br>
<span class="quotelev1">&gt; +}
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;  /*
</span><br>
<span class="quotelev1">&gt; - * Note: module lock must be held during this operation
</span><br>
<span class="quotelev1">&gt; + * Note: this function takes the module lock
</span><br>
<span class="quotelev1">&gt; + *
</span><br>
<span class="quotelev1">&gt; + * buffered sends will cache the fragment on the peer object associated
</span><br>
<span class="quotelev1">&gt; with the
</span><br>
<span class="quotelev1">&gt; + * target. unbuffered-sends will cause the target fragment to be flushed
</span><br>
<span class="quotelev1">&gt; and
</span><br>
<span class="quotelev1">&gt; + * will not be cached on the peer. this causes the fragment to be flushed
</span><br>
<span class="quotelev1">&gt; as
</span><br>
<span class="quotelev1">&gt; + * soon as it is sent. this allows request-based rma fragments to be
</span><br>
<span class="quotelev1">&gt; completed
</span><br>
<span class="quotelev1">&gt; + * so MPI_Test/MPI_Wait/etc will work as expected.
</span><br>
<span class="quotelev1">&gt;   */
</span><br>
<span class="quotelev1">&gt;  static inline int ompi_osc_pt2pt_frag_alloc (ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module, int target,
</span><br>
<span class="quotelev1">&gt;                                               size_t request_len,
</span><br>
<span class="quotelev1">&gt; ompi_osc_pt2pt_frag_t **buffer,
</span><br>
<span class="quotelev1">&gt; -                                             char **ptr, bool long_send)
</span><br>
<span class="quotelev1">&gt; +                                             char **ptr, bool long_send,
</span><br>
<span class="quotelev1">&gt; bool buffered)
</span><br>
<span class="quotelev1">&gt;  {
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_peer_t *peer = ompi_osc_pt2pt_peer_lookup (module,
</span><br>
<span class="quotelev1">&gt; target);
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_frag_t *curr;
</span><br>
<span class="quotelev1">&gt; -    int ret;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* osc pt2pt headers can have 64-bit values. these will need to be
</span><br>
<span class="quotelev1">&gt; aligned
</span><br>
<span class="quotelev1">&gt;       * on an 8-byte boundary on some architectures so we up align the
</span><br>
<span class="quotelev1">&gt; allocation
</span><br>
<span class="quotelev1">&gt; @@ -77,51 +123,34 @@ static inline int ompi_osc_pt2pt_frag_alloc
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, in
</span><br>
<span class="quotelev1">&gt;          return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +    OPAL_OUTPUT_VERBOSE((MCA_BASE_VERBOSE_TRACE,
</span><br>
<span class="quotelev1">&gt; ompi_osc_base_framework.framework_output,
</span><br>
<span class="quotelev1">&gt; +                         &quot;attempting to allocate buffer for %lu bytes to
</span><br>
<span class="quotelev1">&gt; target %d. long send: %d, &quot;
</span><br>
<span class="quotelev1">&gt; +                         &quot;buffered: %d&quot;, (unsigned long) request_len,
</span><br>
<span class="quotelev1">&gt; target, long_send, buffered));
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;      OPAL_THREAD_LOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt; -    curr = peer-&gt;active_frag;
</span><br>
<span class="quotelev1">&gt; -    if (NULL == curr || curr-&gt;remain_len &lt; request_len || (long_send &amp;&amp;
</span><br>
<span class="quotelev1">&gt; curr-&gt;pending_long_sends == 32)) {
</span><br>
<span class="quotelev1">&gt; -        if (NULL != curr &amp;&amp; opal_atomic_cmpset (&amp;peer-&gt;active_frag, curr,
</span><br>
<span class="quotelev1">&gt; NULL)) {
</span><br>
<span class="quotelev1">&gt; -            /* If there's something pending, the pending finish will
</span><br>
<span class="quotelev1">&gt; -               start the buffer.  Otherwise, we need to start it now. */
</span><br>
<span class="quotelev1">&gt; -            ret = ompi_osc_pt2pt_frag_finish (module, curr);
</span><br>
<span class="quotelev1">&gt; -            if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt; +    if (buffered) {
</span><br>
<span class="quotelev1">&gt; +        curr = peer-&gt;active_frag;
</span><br>
<span class="quotelev1">&gt; +        if (NULL == curr || curr-&gt;remain_len &lt; request_len || (long_send
</span><br>
<span class="quotelev1">&gt; &amp;&amp; curr-&gt;pending_long_sends == 32)) {
</span><br>
<span class="quotelev1">&gt; +            curr = ompi_osc_pt2pt_frag_alloc_non_buffered (module, peer,
</span><br>
<span class="quotelev1">&gt; request_len);
</span><br>
<span class="quotelev1">&gt; +            if (OPAL_UNLIKELY(NULL == curr)) {
</span><br>
<span class="quotelev1">&gt;                  OPAL_THREAD_UNLOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt; -                return ret;
</span><br>
<span class="quotelev1">&gt; +                return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt; -        }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -        curr = (ompi_osc_pt2pt_frag_t *) opal_free_list_get
</span><br>
<span class="quotelev1">&gt; (&amp;mca_osc_pt2pt_component.frags);
</span><br>
<span class="quotelev1">&gt; -        if (OPAL_UNLIKELY(NULL == curr)) {
</span><br>
<span class="quotelev1">&gt; -            return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt; -        }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;target = target;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;header = (ompi_osc_pt2pt_frag_header_t*) curr-&gt;buffer;
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;top = (char*) (curr-&gt;header + 1);
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;remain_len = mca_osc_pt2pt_component.buffer_size;
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;module = module;
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;pending = 2;
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;pending_long_sends = long_send;
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;header-&gt;base.type = OMPI_OSC_PT2PT_HDR_TYPE_FRAG;
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;header-&gt;base.flags = OMPI_OSC_PT2PT_HDR_FLAG_VALID;
</span><br>
<span class="quotelev1">&gt; -        if (module-&gt;passive_target_access_epoch) {
</span><br>
<span class="quotelev1">&gt; -            curr-&gt;header-&gt;base.flags |=
</span><br>
<span class="quotelev1">&gt; OMPI_OSC_PT2PT_HDR_FLAG_PASSIVE_TARGET;
</span><br>
<span class="quotelev1">&gt; +            curr-&gt;pending_long_sends = long_send;
</span><br>
<span class="quotelev1">&gt; +            peer-&gt;active_frag = curr;
</span><br>
<span class="quotelev1">&gt; +        } else {
</span><br>
<span class="quotelev1">&gt; +            OPAL_THREAD_ADD32(&amp;curr-&gt;header-&gt;num_ops, 1);
</span><br>
<span class="quotelev1">&gt; +            curr-&gt;pending_long_sends += long_send;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;header-&gt;source = ompi_comm_rank(module-&gt;comm);
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;header-&gt;num_ops = 1;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -        if (curr-&gt;remain_len &lt; request_len) {
</span><br>
<span class="quotelev1">&gt; +        OPAL_THREAD_ADD32(&amp;curr-&gt;pending, 1);
</span><br>
<span class="quotelev1">&gt; +    } else {
</span><br>
<span class="quotelev1">&gt; +        curr = ompi_osc_pt2pt_frag_alloc_non_buffered (module, peer,
</span><br>
<span class="quotelev1">&gt; request_len);
</span><br>
<span class="quotelev1">&gt; +        if (OPAL_UNLIKELY(NULL == curr)) {
</span><br>
<span class="quotelev1">&gt;              OPAL_THREAD_UNLOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt; -            return OMPI_ERR_TEMP_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt; +            return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -        peer-&gt;active_frag = curr;
</span><br>
<span class="quotelev1">&gt; -    } else {
</span><br>
<span class="quotelev1">&gt; -        OPAL_THREAD_ADD32(&amp;curr-&gt;pending, 1);
</span><br>
<span class="quotelev1">&gt; -        OPAL_THREAD_ADD32(&amp;curr-&gt;header-&gt;num_ops, 1);
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;pending_long_sends += long_send;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      *ptr = curr-&gt;top;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; <a href="https://github.com/open-mpi/ompi-release/commit/245147390edeb9cd9fab1d08610f83841588989b">https://github.com/open-mpi/ompi-release/commit/245147390edeb9cd9fab1d08610f83841588989b</a>
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; commit 245147390edeb9cd9fab1d08610f83841588989b
</span><br>
<span class="quotelev1">&gt; Author: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt; Date:   Tue Feb 2 12:44:17 2016 -0700
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     osc/pt2pt: eager sends are always active if MPI_MODE_NOCHECK is used
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     This commit fixes open-mpi/ompi#1299.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Signed-off-by: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     (cherry picked from
</span><br>
<span class="quotelev1">&gt; open-mpi/ompi_at_519fffb65e7a9502b0e5edeb72b1ad2d802daed4)
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Signed-off-by: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_passive_target.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_passive_target.c
</span><br>
<span class="quotelev1">&gt; index 0ddc4cf..099aa56 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_passive_target.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_passive_target.c
</span><br>
<span class="quotelev1">&gt; @@ -8,7 +8,7 @@
</span><br>
<span class="quotelev1">&gt;   *                         University of Stuttgart.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2004-2005 The Regents of the University of California.
</span><br>
<span class="quotelev1">&gt;   *                         All rights reserved.
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2007-2015 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2007-2016 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2010      IBM Corporation.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2012-2013 Sandia National Laboratories.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt; @@ -244,6 +244,8 @@ static int ompi_osc_pt2pt_lock_internal_execute
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt; +    } else {
</span><br>
<span class="quotelev1">&gt; +        lock-&gt;eager_send_active = true;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; <a href="https://github.com/open-mpi/ompi-release/commit/98532dda3d642f845498a40e7e1c660f13ab67aa">https://github.com/open-mpi/ompi-release/commit/98532dda3d642f845498a40e7e1c660f13ab67aa</a>
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; commit 98532dda3d642f845498a40e7e1c660f13ab67aa
</span><br>
<span class="quotelev1">&gt; Author: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt; Date:   Tue Feb 2 12:22:21 2016 -0700
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     osc/pt2pt: various threading fixes
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     This commit fixes several bugs identified by a new multi-threaded RMA
</span><br>
<span class="quotelev1">&gt;     benchmarking suite. The following bugs have been identified and fixed:
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      - The code that signaled the actual start of an access epoch changed
</span><br>
<span class="quotelev1">&gt;        the eager_send_active flag on a synchronization object without
</span><br>
<span class="quotelev1">&gt;        holding the object's lock. This could cause another thread waiting
</span><br>
<span class="quotelev1">&gt;        on eager sends to block indefinitely because the entirety of
</span><br>
<span class="quotelev1">&gt;        ompi_osc_pt2pt_sync_expected could exectute between the check of
</span><br>
<span class="quotelev1">&gt;        eager_send_active and the conditon wait of
</span><br>
<span class="quotelev1">&gt;        ompi_osc_pt2pt_sync_wait.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      - The bookkeeping of fragments could get screwed up when performing
</span><br>
<span class="quotelev1">&gt;        long put/accumulate operations from different threads. This was
</span><br>
<span class="quotelev1">&gt;        caused by the fragment flush code at the end of both put and
</span><br>
<span class="quotelev1">&gt;        accumulate. This code was put in place to avoid sending a large
</span><br>
<span class="quotelev1">&gt;        number of unexpected messages to a peer. To fix the bookkeeping
</span><br>
<span class="quotelev1">&gt;        issue we now 1) wait for eager sends to be active before stating
</span><br>
<span class="quotelev1">&gt;        any large isend's, and 2) keep track of the number of large isends
</span><br>
<span class="quotelev1">&gt;        associated with a fragment. If the number of large isends reaches
</span><br>
<span class="quotelev1">&gt;        32 the active fragment is flushed.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      - Use atomics to update the large receive/send tag counters. This
</span><br>
<span class="quotelev1">&gt;        prevents duplicate tags from being used. The tag space has also
</span><br>
<span class="quotelev1">&gt;        been updated to use the entire 16-bits of the tag space.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     These changes should also fix open-mpi/ompi#1299.
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Signed-off-by: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     (cherry picked from
</span><br>
<span class="quotelev1">&gt; open-mpi/ompi_at_d7264aa61394ffa278cc9ea08bc7b4704fb680e1)
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Signed-off-by: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; index 1f3c204..409011d 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; @@ -8,7 +8,7 @@
</span><br>
<span class="quotelev1">&gt;   *                         University of Stuttgart.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2004-2005 The Regents of the University of California.
</span><br>
<span class="quotelev1">&gt;   *                         All rights reserved.
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2007-2015 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2007-2016 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2010      Cisco Systems, Inc.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2012-2013 Sandia National Laboratories.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt; @@ -149,20 +149,20 @@ struct ompi_osc_pt2pt_module_t {
</span><br>
<span class="quotelev1">&gt;      uint32_t *epoch_outgoing_frag_count;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /** cyclic counter for a unique tage for long messages. */
</span><br>
<span class="quotelev1">&gt; -    unsigned int tag_counter;
</span><br>
<span class="quotelev1">&gt; -    unsigned int rtag_counter;
</span><br>
<span class="quotelev1">&gt; +    uint32_t tag_counter;
</span><br>
<span class="quotelev1">&gt; +    uint32_t rtag_counter;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* Number of outgoing fragments that have completed since the
</span><br>
<span class="quotelev1">&gt;         begining of time */
</span><br>
<span class="quotelev1">&gt; -    uint32_t outgoing_frag_count;
</span><br>
<span class="quotelev1">&gt; +    volatile uint32_t outgoing_frag_count;
</span><br>
<span class="quotelev1">&gt;      /* Next outgoing fragment count at which we want a signal on cond */
</span><br>
<span class="quotelev1">&gt; -    uint32_t outgoing_frag_signal_count;
</span><br>
<span class="quotelev1">&gt; +    volatile uint32_t outgoing_frag_signal_count;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* Number of incoming fragments that have completed since the
</span><br>
<span class="quotelev1">&gt;         begining of time */
</span><br>
<span class="quotelev1">&gt; -    uint32_t active_incoming_frag_count;
</span><br>
<span class="quotelev1">&gt; +    volatile uint32_t active_incoming_frag_count;
</span><br>
<span class="quotelev1">&gt;      /* Next incoming buffer count at which we want a signal on cond */
</span><br>
<span class="quotelev1">&gt; -    uint32_t active_incoming_frag_signal_count;
</span><br>
<span class="quotelev1">&gt; +    volatile uint32_t active_incoming_frag_signal_count;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /** Number of targets locked/being locked */
</span><br>
<span class="quotelev1">&gt;      unsigned int passive_target_access_epoch;
</span><br>
<span class="quotelev1">&gt; @@ -409,14 +409,6 @@ int
</span><br>
<span class="quotelev1">&gt; ompi_osc_pt2pt_component_irecv(ompi_osc_pt2pt_module_t *module,
</span><br>
<span class="quotelev1">&gt;                                    int tag,
</span><br>
<span class="quotelev1">&gt;                                    struct ompi_communicator_t *comm);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -int ompi_osc_pt2pt_component_isend(ompi_osc_pt2pt_module_t *module,
</span><br>
<span class="quotelev1">&gt; -                                  const void *buf,
</span><br>
<span class="quotelev1">&gt; -                                  size_t count,
</span><br>
<span class="quotelev1">&gt; -                                  struct ompi_datatype_t *datatype,
</span><br>
<span class="quotelev1">&gt; -                                  int dest,
</span><br>
<span class="quotelev1">&gt; -                                  int tag,
</span><br>
<span class="quotelev1">&gt; -                                  struct ompi_communicator_t *comm);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt;  /**
</span><br>
<span class="quotelev1">&gt;   * ompi_osc_pt2pt_progress_pending_acc:
</span><br>
<span class="quotelev1">&gt;   *
</span><br>
<span class="quotelev1">&gt; @@ -639,8 +631,8 @@ static inline void osc_pt2pt_add_pending
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_pending_t *pending)
</span><br>
<span class="quotelev1">&gt;                              opal_list_append
</span><br>
<span class="quotelev1">&gt; (&amp;mca_osc_pt2pt_component.pending_operations, &amp;pending-&gt;super));
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -#define OSC_PT2PT_FRAG_TAG   0x10000
</span><br>
<span class="quotelev1">&gt; -#define OSC_PT2PT_FRAG_MASK  0x0ffff
</span><br>
<span class="quotelev1">&gt; +#define OSC_PT2PT_FRAG_TAG   0x80000
</span><br>
<span class="quotelev1">&gt; +#define OSC_PT2PT_FRAG_MASK  0x7ffff
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  /**
</span><br>
<span class="quotelev1">&gt;   * get_tag:
</span><br>
<span class="quotelev1">&gt; @@ -658,11 +650,8 @@ static inline int get_tag(ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module)
</span><br>
<span class="quotelev1">&gt;      /* the LSB of the tag is used be the receiver to determine if the
</span><br>
<span class="quotelev1">&gt;         message is a passive or active target (ie, where to mark
</span><br>
<span class="quotelev1">&gt;         completion). */
</span><br>
<span class="quotelev1">&gt; -    int tmp = module-&gt;tag_counter +
</span><br>
<span class="quotelev1">&gt; !!(module-&gt;passive_target_access_epoch);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    module-&gt;tag_counter = (module-&gt;tag_counter + 4) &amp; OSC_PT2PT_FRAG_MASK;
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return tmp;
</span><br>
<span class="quotelev1">&gt; +    int32_t tmp = OPAL_THREAD_ADD32((volatile int32_t *)
</span><br>
<span class="quotelev1">&gt; &amp;module-&gt;tag_counter, 4);
</span><br>
<span class="quotelev1">&gt; +    return (tmp &amp; OSC_PT2PT_FRAG_MASK) |
</span><br>
<span class="quotelev1">&gt; !!(module-&gt;passive_target_access_epoch);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  static inline int get_rtag(ompi_osc_pt2pt_module_t *module)
</span><br>
<span class="quotelev1">&gt; @@ -670,11 +659,8 @@ static inline int get_rtag(ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module)
</span><br>
<span class="quotelev1">&gt;      /* the LSB of the tag is used be the receiver to determine if the
</span><br>
<span class="quotelev1">&gt;         message is a passive or active target (ie, where to mark
</span><br>
<span class="quotelev1">&gt;         completion). */
</span><br>
<span class="quotelev1">&gt; -    int tmp = module-&gt;rtag_counter +
</span><br>
<span class="quotelev1">&gt; !!(module-&gt;passive_target_access_epoch);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    module-&gt;rtag_counter = (module-&gt;rtag_counter + 4) &amp;
</span><br>
<span class="quotelev1">&gt; OSC_PT2PT_FRAG_MASK;
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return tmp;
</span><br>
<span class="quotelev1">&gt; +    int32_t tmp = OPAL_THREAD_ADD32((volatile int32_t *)
</span><br>
<span class="quotelev1">&gt; &amp;module-&gt;rtag_counter, 4);
</span><br>
<span class="quotelev1">&gt; +    return (tmp &amp; OSC_PT2PT_FRAG_MASK) |
</span><br>
<span class="quotelev1">&gt; !!(module-&gt;passive_target_access_epoch);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;  /**
</span><br>
<span class="quotelev1">&gt;   * ompi_osc_pt2pt_accumulate_lock:
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; index e169add..58d6b40 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c
</span><br>
<span class="quotelev1">&gt; @@ -8,7 +8,7 @@
</span><br>
<span class="quotelev1">&gt;   *                         University of Stuttgart.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2004-2005 The Regents of the University of California.
</span><br>
<span class="quotelev1">&gt;   *                         All rights reserved.
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2007-2015 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2007-2016 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2010      IBM Corporation.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2012-2013 Sandia National Laboratories.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt; @@ -211,7 +211,7 @@ int ompi_osc_pt2pt_start (ompi_group_t *group, int
</span><br>
<span class="quotelev1">&gt; assert, ompi_win_t *win)
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_module_t *module = GET_MODULE(win);
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_sync_t *sync = &amp;module-&gt;all_sync;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    OPAL_THREAD_LOCK(&amp;sync-&gt;lock);
</span><br>
<span class="quotelev1">&gt; +    OPAL_THREAD_LOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* check if we are already in an access epoch */
</span><br>
<span class="quotelev1">&gt;      if (ompi_osc_pt2pt_access_epoch_active (module)) {
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; index b22f783..a1dcfd7 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; @@ -8,7 +8,7 @@
</span><br>
<span class="quotelev1">&gt;   *                         University of Stuttgart.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2004-2005 The Regents of the University of California.
</span><br>
<span class="quotelev1">&gt;   *                         All rights reserved.
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2007-2015 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2007-2016 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2010      Cisco Systems, Inc.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2012-2013 Sandia National Laboratories.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt; @@ -34,27 +34,55 @@
</span><br>
<span class="quotelev1">&gt;  #include &lt;stdio.h&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  /* progress an OSC request */
</span><br>
<span class="quotelev1">&gt; +static int ompi_osc_pt2pt_comm_complete (ompi_request_t *request)
</span><br>
<span class="quotelev1">&gt; +{
</span><br>
<span class="quotelev1">&gt; +    ompi_osc_pt2pt_module_t *module =
</span><br>
<span class="quotelev1">&gt; +        (ompi_osc_pt2pt_module_t*) request-&gt;req_complete_cb_data;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    OPAL_OUTPUT_VERBOSE((10, ompi_osc_base_framework.framework_output,
</span><br>
<span class="quotelev1">&gt; +                         &quot;isend_completion_cb called&quot;));
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    mark_outgoing_completion(module);
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    /* put this request on the garbage colletion list */
</span><br>
<span class="quotelev1">&gt; +    osc_pt2pt_gc_add_request (module, request);
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt; +}
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;  static int ompi_osc_pt2pt_req_comm_complete (ompi_request_t *request)
</span><br>
<span class="quotelev1">&gt;  {
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_request_t *pt2pt_request = (ompi_osc_pt2pt_request_t
</span><br>
<span class="quotelev1">&gt; *) request-&gt;req_complete_cb_data;
</span><br>
<span class="quotelev1">&gt; -    ompi_osc_pt2pt_module_t *module = pt2pt_request-&gt;module;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      OPAL_OUTPUT_VERBOSE((10, ompi_osc_base_framework.framework_output,
</span><br>
<span class="quotelev1">&gt;                           &quot;ompi_osc_pt2pt_req_comm_complete called tag =
</span><br>
<span class="quotelev1">&gt; %d&quot;,
</span><br>
<span class="quotelev1">&gt;                           request-&gt;req_status.MPI_TAG));
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    mark_outgoing_completion (module);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt;      if (0 == OPAL_THREAD_ADD32(&amp;pt2pt_request-&gt;outstanding_requests, -1))
</span><br>
<span class="quotelev1">&gt; {
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_request_complete (pt2pt_request,
</span><br>
<span class="quotelev1">&gt; request-&gt;req_status.MPI_ERROR);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    /* put this request on the garbage colletion list */
</span><br>
<span class="quotelev1">&gt; -    osc_pt2pt_gc_add_request (module, request);
</span><br>
<span class="quotelev1">&gt; +    return ompi_osc_pt2pt_comm_complete (request);
</span><br>
<span class="quotelev1">&gt; +}
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt; +static inline int ompi_osc_pt2pt_data_isend (ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module, const void *buf,
</span><br>
<span class="quotelev1">&gt; +                                             size_t count,
</span><br>
<span class="quotelev1">&gt; ompi_datatype_t *datatype, int dest,
</span><br>
<span class="quotelev1">&gt; +                                             int tag,
</span><br>
<span class="quotelev1">&gt; ompi_osc_pt2pt_request_t *request)
</span><br>
<span class="quotelev1">&gt; +{
</span><br>
<span class="quotelev1">&gt; +    /* increment the outgoing send count */
</span><br>
<span class="quotelev1">&gt; +    ompi_osc_signal_outgoing (module, dest, 1);
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    if (NULL != request) {
</span><br>
<span class="quotelev1">&gt; +        ++request-&gt;outstanding_requests;
</span><br>
<span class="quotelev1">&gt; +        return ompi_osc_pt2pt_isend_w_cb (buf, count, datatype, dest,
</span><br>
<span class="quotelev1">&gt; tag, module-&gt;comm,
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; ompi_osc_pt2pt_req_comm_complete, request);
</span><br>
<span class="quotelev1">&gt; +    }
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    return ompi_osc_pt2pt_isend_w_cb (buf, count, datatype, dest, tag,
</span><br>
<span class="quotelev1">&gt; module-&gt;comm,
</span><br>
<span class="quotelev1">&gt; +                                      ompi_osc_pt2pt_comm_complete,
</span><br>
<span class="quotelev1">&gt; module);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;  static int ompi_osc_pt2pt_dt_send_complete (ompi_request_t *request)
</span><br>
<span class="quotelev1">&gt;  {
</span><br>
<span class="quotelev1">&gt;      ompi_datatype_t *datatype = (ompi_datatype_t *)
</span><br>
<span class="quotelev1">&gt; request-&gt;req_complete_cb_data;
</span><br>
<span class="quotelev1">&gt; @@ -282,14 +310,14 @@ static inline int ompi_osc_pt2pt_put_w_req (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin_
</span><br>
<span class="quotelev1">&gt;      payload_len = origin_dt-&gt;super.size * origin_count;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + ddt_len +
</span><br>
<span class="quotelev1">&gt; payload_len;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt;      if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt;          if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;              /* allocate space for the header plus space to store ddt_len
</span><br>
<span class="quotelev1">&gt; */
</span><br>
<span class="quotelev1">&gt;              frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + 8;
</span><br>
<span class="quotelev1">&gt; -            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt;              if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;                  return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt; @@ -301,9 +329,8 @@ static inline int ompi_osc_pt2pt_put_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_
</span><br>
<span class="quotelev1">&gt;          tag = get_tag(module);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    /* flush will be called at the end of this function. make sure all
</span><br>
<span class="quotelev1">&gt; post messages have
</span><br>
<span class="quotelev1">&gt; -     * arrived. */
</span><br>
<span class="quotelev1">&gt; -    if ((is_long_msg || request) &amp;&amp; OMPI_OSC_PT2PT_SYNC_TYPE_PSCW ==
</span><br>
<span class="quotelev1">&gt; pt2pt_sync-&gt;type) {
</span><br>
<span class="quotelev1">&gt; +    if (is_long_msg) {
</span><br>
<span class="quotelev1">&gt; +        /* wait for eager sends to be active before starting a long put */
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -361,18 +388,8 @@ static inline int ompi_osc_pt2pt_put_w_req (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin_
</span><br>
<span class="quotelev1">&gt;              header-&gt;tag = tag;
</span><br>
<span class="quotelev1">&gt;              osc_pt2pt_hton(header, proc);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -            /* increase the outgoing signal count */
</span><br>
<span class="quotelev1">&gt; -            ompi_osc_signal_outgoing (module, target, 1);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -            if (request) {
</span><br>
<span class="quotelev1">&gt; -                request-&gt;outstanding_requests = 1;
</span><br>
<span class="quotelev1">&gt; -                ret = ompi_osc_pt2pt_isend_w_cb (origin_addr,
</span><br>
<span class="quotelev1">&gt; origin_count, origin_dt,
</span><br>
<span class="quotelev1">&gt; -                                                target, tag,
</span><br>
<span class="quotelev1">&gt; module-&gt;comm, ompi_osc_pt2pt_req_comm_complete,
</span><br>
<span class="quotelev1">&gt; -                                                request);
</span><br>
<span class="quotelev1">&gt; -            } else {
</span><br>
<span class="quotelev1">&gt; -                ret = ompi_osc_pt2pt_component_isend (module,origin_addr,
</span><br>
<span class="quotelev1">&gt; origin_count, origin_dt, target, tag,
</span><br>
<span class="quotelev1">&gt; -                                                     module-&gt;comm);
</span><br>
<span class="quotelev1">&gt; -            }
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_data_isend (module,origin_addr,
</span><br>
<span class="quotelev1">&gt; origin_count, origin_dt, target, tag,
</span><br>
<span class="quotelev1">&gt; +                                             request);
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt;      } while (0);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -380,14 +397,7 @@ static inline int ompi_osc_pt2pt_put_w_req (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin_
</span><br>
<span class="quotelev1">&gt;          header-&gt;base.flags |= OMPI_OSC_PT2PT_HDR_FLAG_VALID;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    if (request || is_long_msg) {
</span><br>
<span class="quotelev1">&gt; -        /* need to flush now in case the caller decides to wait on the
</span><br>
<span class="quotelev1">&gt; request */
</span><br>
<span class="quotelev1">&gt; -        ompi_osc_pt2pt_frag_flush_target (module, target);
</span><br>
<span class="quotelev1">&gt; -    }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return ret;
</span><br>
<span class="quotelev1">&gt; +    return ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  int
</span><br>
<span class="quotelev1">&gt; @@ -459,14 +469,14 @@ ompi_osc_pt2pt_accumulate_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_count,
</span><br>
<span class="quotelev1">&gt;      payload_len = origin_dt-&gt;super.size * origin_count;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(*header) + ddt_len + payload_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(*header) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt;          if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;              /* allocate space for the header plus space to store ddt_len
</span><br>
<span class="quotelev1">&gt; */
</span><br>
<span class="quotelev1">&gt;              frag_len = sizeof(*header) + 8;
</span><br>
<span class="quotelev1">&gt; -            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt;              if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;                  return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt; @@ -478,9 +488,8 @@ ompi_osc_pt2pt_accumulate_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_count,
</span><br>
<span class="quotelev1">&gt;          tag = get_rtag (module);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    /* flush will be called at the end of this function. make sure all
</span><br>
<span class="quotelev1">&gt; post messages have
</span><br>
<span class="quotelev1">&gt; -     * arrived. */
</span><br>
<span class="quotelev1">&gt; -    if ((is_long_msg || request) &amp;&amp; OMPI_OSC_PT2PT_SYNC_TYPE_PSCW ==
</span><br>
<span class="quotelev1">&gt; pt2pt_sync-&gt;type) {
</span><br>
<span class="quotelev1">&gt; +    if (is_long_msg || is_long_datatype) {
</span><br>
<span class="quotelev1">&gt; +        /* wait for synchronization before posting a long message */
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -538,18 +547,8 @@ ompi_osc_pt2pt_accumulate_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_count,
</span><br>
<span class="quotelev1">&gt;              OPAL_OUTPUT_VERBOSE((25,
</span><br>
<span class="quotelev1">&gt; ompi_osc_base_framework.framework_output,
</span><br>
<span class="quotelev1">&gt;                                   &quot;acc: starting long accumulate with tag
</span><br>
<span class="quotelev1">&gt; %d&quot;, tag));
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -            /* increment the outgoing send count */
</span><br>
<span class="quotelev1">&gt; -            ompi_osc_signal_outgoing (module, target, 1);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -            if (request) {
</span><br>
<span class="quotelev1">&gt; -                request-&gt;outstanding_requests = 1;
</span><br>
<span class="quotelev1">&gt; -                ret = ompi_osc_pt2pt_isend_w_cb (origin_addr,
</span><br>
<span class="quotelev1">&gt; origin_count, origin_dt,
</span><br>
<span class="quotelev1">&gt; -                                                target, tag,
</span><br>
<span class="quotelev1">&gt; module-&gt;comm, ompi_osc_pt2pt_req_comm_complete,
</span><br>
<span class="quotelev1">&gt; -                                                request);
</span><br>
<span class="quotelev1">&gt; -            } else {
</span><br>
<span class="quotelev1">&gt; -                ret = ompi_osc_pt2pt_component_isend (module,
</span><br>
<span class="quotelev1">&gt; origin_addr, origin_count, origin_dt, target, tag,
</span><br>
<span class="quotelev1">&gt; -                                                     module-&gt;comm);
</span><br>
<span class="quotelev1">&gt; -            }
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_data_isend (module, origin_addr,
</span><br>
<span class="quotelev1">&gt; origin_count, origin_dt, target, tag,
</span><br>
<span class="quotelev1">&gt; +                                             request);
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt;      } while (0);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -561,14 +560,7 @@ ompi_osc_pt2pt_accumulate_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_count,
</span><br>
<span class="quotelev1">&gt;          header-&gt;base.flags |= OMPI_OSC_PT2PT_HDR_FLAG_VALID;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    if (is_long_msg || request) {
</span><br>
<span class="quotelev1">&gt; -        /* need to flush now in case the caller decides to wait on the
</span><br>
<span class="quotelev1">&gt; request */
</span><br>
<span class="quotelev1">&gt; -        ompi_osc_pt2pt_frag_flush_target (module, target);
</span><br>
<span class="quotelev1">&gt; -    }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return ret;
</span><br>
<span class="quotelev1">&gt; +    return ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  int
</span><br>
<span class="quotelev1">&gt; @@ -639,7 +631,7 @@ int ompi_osc_pt2pt_compare_and_swap (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, const void *compar
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(ompi_osc_pt2pt_header_cswap_t) + ddt_len +
</span><br>
<span class="quotelev1">&gt; payload_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt; @@ -787,11 +779,11 @@ static inline int ompi_osc_pt2pt_rget_internal (void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_co
</span><br>
<span class="quotelev1">&gt;      ddt_len = ompi_datatype_pack_description_length(target_dt);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(ompi_osc_pt2pt_header_get_t) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          /* allocate space for the header plus space to store ddt_len */
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(ompi_osc_pt2pt_header_put_t) + 8;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt;          if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;              return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt; @@ -804,9 +796,8 @@ static inline int ompi_osc_pt2pt_rget_internal (void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_co
</span><br>
<span class="quotelev1">&gt;      /* for bookkeeping the get is &quot;outgoing&quot; */
</span><br>
<span class="quotelev1">&gt;      ompi_osc_signal_outgoing (module, target, 1);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    /* flush will be called at the end of this function. make sure all
</span><br>
<span class="quotelev1">&gt; post messages have
</span><br>
<span class="quotelev1">&gt; -     * arrived. */
</span><br>
<span class="quotelev1">&gt; -    if (!release_req &amp;&amp; OMPI_OSC_PT2PT_SYNC_TYPE_PSCW ==
</span><br>
<span class="quotelev1">&gt; pt2pt_sync-&gt;type) {
</span><br>
<span class="quotelev1">&gt; +    if (!release_req) {
</span><br>
<span class="quotelev1">&gt; +        /* wait for epoch to begin before starting rget operation */
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -857,14 +848,7 @@ static inline int ompi_osc_pt2pt_rget_internal (void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_co
</span><br>
<span class="quotelev1">&gt;          *request = &amp;pt2pt_request-&gt;super;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    if (!release_req) {
</span><br>
<span class="quotelev1">&gt; -        /* need to flush now in case the caller decides to wait on the
</span><br>
<span class="quotelev1">&gt; request */
</span><br>
<span class="quotelev1">&gt; -        ompi_osc_pt2pt_frag_flush_target (module, target);
</span><br>
<span class="quotelev1">&gt; -    }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return ret;
</span><br>
<span class="quotelev1">&gt; +    return ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  int ompi_osc_pt2pt_rget (void *origin_addr, int origin_count, struct
</span><br>
<span class="quotelev1">&gt; ompi_datatype_t *origin_dt,
</span><br>
<span class="quotelev1">&gt; @@ -1003,14 +987,14 @@ int ompi_osc_pt2pt_rget_accumulate_internal (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      frag_len = sizeof(*header) + ddt_len + payload_len;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len, &amp;frag,
</span><br>
<span class="quotelev1">&gt; &amp;ptr, false);
</span><br>
<span class="quotelev1">&gt;      if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;          frag_len = sizeof(*header) + ddt_len;
</span><br>
<span class="quotelev1">&gt; -        ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +        ret = ompi_osc_pt2pt_frag_alloc(module, target_rank, frag_len,
</span><br>
<span class="quotelev1">&gt; &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt;          if (OMPI_SUCCESS != ret) {
</span><br>
<span class="quotelev1">&gt;              /* allocate space for the header plus space to store ddt_len
</span><br>
<span class="quotelev1">&gt; */
</span><br>
<span class="quotelev1">&gt;              frag_len = sizeof(*header) + 8;
</span><br>
<span class="quotelev1">&gt; -            ret = ompi_osc_pt2pt_frag_alloc(module, target_rank,
</span><br>
<span class="quotelev1">&gt; frag_len, &amp;frag, &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_frag_alloc(module, target_rank,
</span><br>
<span class="quotelev1">&gt; frag_len, &amp;frag, &amp;ptr, true);
</span><br>
<span class="quotelev1">&gt;              if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt;                  return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt; @@ -1030,9 +1014,8 @@ int ompi_osc_pt2pt_rget_accumulate_internal (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin
</span><br>
<span class="quotelev1">&gt;      /* increment the number of outgoing fragments */
</span><br>
<span class="quotelev1">&gt;      ompi_osc_signal_outgoing (module, target_rank,
</span><br>
<span class="quotelev1">&gt; pt2pt_request-&gt;outstanding_requests);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    /* flush will be called at the end of this function. make sure all
</span><br>
<span class="quotelev1">&gt; post messages have
</span><br>
<span class="quotelev1">&gt; -     * arrived. */
</span><br>
<span class="quotelev1">&gt; -    if (!release_req &amp;&amp; OMPI_OSC_PT2PT_SYNC_TYPE_PSCW ==
</span><br>
<span class="quotelev1">&gt; pt2pt_sync-&gt;type) {
</span><br>
<span class="quotelev1">&gt; +    if (!release_req) {
</span><br>
<span class="quotelev1">&gt; +        /* wait for epoch to begin before starting operation */
</span><br>
<span class="quotelev1">&gt;          ompi_osc_pt2pt_sync_wait (pt2pt_sync);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -1100,14 +1083,7 @@ int ompi_osc_pt2pt_rget_accumulate_internal (const
</span><br>
<span class="quotelev1">&gt; void *origin_addr, int origin
</span><br>
<span class="quotelev1">&gt;          *request = (ompi_request_t *) pt2pt_request;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    if (!release_req) {
</span><br>
<span class="quotelev1">&gt; -        /* need to flush now in case the caller decides to wait on the
</span><br>
<span class="quotelev1">&gt; request */
</span><br>
<span class="quotelev1">&gt; -        ompi_osc_pt2pt_frag_flush_target (module, target_rank);
</span><br>
<span class="quotelev1">&gt; -    }
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return ret;
</span><br>
<span class="quotelev1">&gt; +    return ompi_osc_pt2pt_frag_finish(module, frag);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  int ompi_osc_pt2pt_get_accumulate(const void *origin_addr, int
</span><br>
<span class="quotelev1">&gt; origin_count,
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; index 6883d79..09bd285 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c
</span><br>
<span class="quotelev1">&gt; @@ -8,7 +8,7 @@
</span><br>
<span class="quotelev1">&gt;   *                         University of Stuttgart.  All rights reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2004-2005 The Regents of the University of California.
</span><br>
<span class="quotelev1">&gt;   *                         All rights reserved.
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2007-2015 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2007-2016 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2009-2011 Oracle and/or its affiliates.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2012-2013 Sandia National Laboratories.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt; @@ -213,7 +213,7 @@ int ompi_osc_pt2pt_control_send
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, int target,
</span><br>
<span class="quotelev1">&gt;      char *ptr;
</span><br>
<span class="quotelev1">&gt;      int ret;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    ret = ompi_osc_pt2pt_frag_alloc(module, target, len, &amp;frag, &amp;ptr);
</span><br>
<span class="quotelev1">&gt; +    ret = ompi_osc_pt2pt_frag_alloc(module, target, len, &amp;frag, &amp;ptr,
</span><br>
<span class="quotelev1">&gt; false);
</span><br>
<span class="quotelev1">&gt;      if (OPAL_LIKELY(OMPI_SUCCESS == ret)) {
</span><br>
<span class="quotelev1">&gt;          memcpy (ptr, data, len);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -1682,33 +1682,6 @@ int ompi_osc_pt2pt_component_irecv
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, void *buf,
</span><br>
<span class="quotelev1">&gt;                                       osc_pt2pt_incoming_req_complete,
</span><br>
<span class="quotelev1">&gt; module);
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -static int
</span><br>
<span class="quotelev1">&gt; -isend_completion_cb(ompi_request_t *request)
</span><br>
<span class="quotelev1">&gt; -{
</span><br>
<span class="quotelev1">&gt; -    ompi_osc_pt2pt_module_t *module =
</span><br>
<span class="quotelev1">&gt; -        (ompi_osc_pt2pt_module_t*) request-&gt;req_complete_cb_data;
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    OPAL_OUTPUT_VERBOSE((10, ompi_osc_base_framework.framework_output,
</span><br>
<span class="quotelev1">&gt; -                         &quot;isend_completion_cb called&quot;));
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    mark_outgoing_completion(module);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    /* put this request on the garbage colletion list */
</span><br>
<span class="quotelev1">&gt; -    osc_pt2pt_gc_add_request (module, request);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt; -}
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -int ompi_osc_pt2pt_component_isend (ompi_osc_pt2pt_module_t *module,
</span><br>
<span class="quotelev1">&gt; const void *buf,
</span><br>
<span class="quotelev1">&gt; -                                    size_t count, struct ompi_datatype_t
</span><br>
<span class="quotelev1">&gt; *datatype,
</span><br>
<span class="quotelev1">&gt; -                                    int dest, int tag, struct
</span><br>
<span class="quotelev1">&gt; ompi_communicator_t *comm)
</span><br>
<span class="quotelev1">&gt; -{
</span><br>
<span class="quotelev1">&gt; -    return ompi_osc_pt2pt_isend_w_cb (buf, count, datatype, dest, tag,
</span><br>
<span class="quotelev1">&gt; comm,
</span><br>
<span class="quotelev1">&gt; -                                     isend_completion_cb, module);
</span><br>
<span class="quotelev1">&gt; -}
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt;  int ompi_osc_pt2pt_isend_w_cb (const void *ptr, int count,
</span><br>
<span class="quotelev1">&gt; ompi_datatype_t *datatype, int target, int tag,
</span><br>
<span class="quotelev1">&gt;                                ompi_communicator_t *comm,
</span><br>
<span class="quotelev1">&gt; ompi_request_complete_fn_t cb, void *ctx)
</span><br>
<span class="quotelev1">&gt;  {
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; index 515ce82..f55e6cb 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_frag.h
</span><br>
<span class="quotelev1">&gt; @@ -1,7 +1,7 @@
</span><br>
<span class="quotelev1">&gt;  /* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */
</span><br>
<span class="quotelev1">&gt;  /*
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2012      Sandia National Laboratories.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2014-2015 Los Alamos National Security, LLC. All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2014-2016 Los Alamos National Security, LLC. All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * $COPYRIGHT$
</span><br>
<span class="quotelev1">&gt;   *
</span><br>
<span class="quotelev1">&gt; @@ -33,7 +33,8 @@ struct ompi_osc_pt2pt_frag_t {
</span><br>
<span class="quotelev1">&gt;      char *top;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* Number of operations which have started writing into the frag, but
</span><br>
<span class="quotelev1">&gt; not yet completed doing so */
</span><br>
<span class="quotelev1">&gt; -    int32_t pending;
</span><br>
<span class="quotelev1">&gt; +    volatile int32_t pending;
</span><br>
<span class="quotelev1">&gt; +    int32_t pending_long_sends;
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_frag_header_t *header;
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_module_t *module;
</span><br>
<span class="quotelev1">&gt;  };
</span><br>
<span class="quotelev1">&gt; @@ -44,12 +45,24 @@ extern int
</span><br>
<span class="quotelev1">&gt; ompi_osc_pt2pt_frag_start(ompi_osc_pt2pt_module_t *module, ompi_osc_p
</span><br>
<span class="quotelev1">&gt;  extern int ompi_osc_pt2pt_frag_flush_target(ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module, int target);
</span><br>
<span class="quotelev1">&gt;  extern int ompi_osc_pt2pt_frag_flush_all(ompi_osc_pt2pt_module_t *module);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +static inline int ompi_osc_pt2pt_frag_finish (ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module,
</span><br>
<span class="quotelev1">&gt; +                                              ompi_osc_pt2pt_frag_t*
</span><br>
<span class="quotelev1">&gt; buffer)
</span><br>
<span class="quotelev1">&gt; +{
</span><br>
<span class="quotelev1">&gt; +    opal_atomic_wmb ();
</span><br>
<span class="quotelev1">&gt; +    if (0 == OPAL_THREAD_ADD32(&amp;buffer-&gt;pending, -1)) {
</span><br>
<span class="quotelev1">&gt; +        opal_atomic_mb ();
</span><br>
<span class="quotelev1">&gt; +        return ompi_osc_pt2pt_frag_start(module, buffer);
</span><br>
<span class="quotelev1">&gt; +    }
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt; +}
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt;  /*
</span><br>
<span class="quotelev1">&gt;   * Note: module lock must be held during this operation
</span><br>
<span class="quotelev1">&gt;   */
</span><br>
<span class="quotelev1">&gt;  static inline int ompi_osc_pt2pt_frag_alloc (ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module, int target,
</span><br>
<span class="quotelev1">&gt;                                               size_t request_len,
</span><br>
<span class="quotelev1">&gt; ompi_osc_pt2pt_frag_t **buffer,
</span><br>
<span class="quotelev1">&gt; -                                             char **ptr)
</span><br>
<span class="quotelev1">&gt; +                                             char **ptr, bool long_send)
</span><br>
<span class="quotelev1">&gt;  {
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_peer_t *peer = ompi_osc_pt2pt_peer_lookup (module,
</span><br>
<span class="quotelev1">&gt; target);
</span><br>
<span class="quotelev1">&gt;      ompi_osc_pt2pt_frag_t *curr;
</span><br>
<span class="quotelev1">&gt; @@ -66,29 +79,21 @@ static inline int ompi_osc_pt2pt_frag_alloc
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, in
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      OPAL_THREAD_LOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt;      curr = peer-&gt;active_frag;
</span><br>
<span class="quotelev1">&gt; -    if (NULL == curr || curr-&gt;remain_len &lt; request_len) {
</span><br>
<span class="quotelev1">&gt; -        opal_free_list_item_t *item = NULL;
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -        if (NULL != curr) {
</span><br>
<span class="quotelev1">&gt; -            curr-&gt;remain_len = 0;
</span><br>
<span class="quotelev1">&gt; -            peer-&gt;active_frag = NULL;
</span><br>
<span class="quotelev1">&gt; -            opal_atomic_mb ();
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; +    if (NULL == curr || curr-&gt;remain_len &lt; request_len || (long_send &amp;&amp;
</span><br>
<span class="quotelev1">&gt; curr-&gt;pending_long_sends == 32)) {
</span><br>
<span class="quotelev1">&gt; +        if (NULL != curr &amp;&amp; opal_atomic_cmpset (&amp;peer-&gt;active_frag, curr,
</span><br>
<span class="quotelev1">&gt; NULL)) {
</span><br>
<span class="quotelev1">&gt;              /* If there's something pending, the pending finish will
</span><br>
<span class="quotelev1">&gt;                 start the buffer.  Otherwise, we need to start it now. */
</span><br>
<span class="quotelev1">&gt; -            if (0 == OPAL_THREAD_ADD32(&amp;curr-&gt;pending, -1)) {
</span><br>
<span class="quotelev1">&gt; -                ret = ompi_osc_pt2pt_frag_start(module, curr);
</span><br>
<span class="quotelev1">&gt; -                if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt; -                    return ret;
</span><br>
<span class="quotelev1">&gt; -                }
</span><br>
<span class="quotelev1">&gt; +            ret = ompi_osc_pt2pt_frag_finish (module, curr);
</span><br>
<span class="quotelev1">&gt; +            if (OPAL_UNLIKELY(OMPI_SUCCESS != ret)) {
</span><br>
<span class="quotelev1">&gt; +                OPAL_THREAD_UNLOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt; +                return ret;
</span><br>
<span class="quotelev1">&gt;              }
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -        item = opal_free_list_get (&amp;mca_osc_pt2pt_component.frags);
</span><br>
<span class="quotelev1">&gt; -        if (OPAL_UNLIKELY(NULL == item)) {
</span><br>
<span class="quotelev1">&gt; +        curr = (ompi_osc_pt2pt_frag_t *) opal_free_list_get
</span><br>
<span class="quotelev1">&gt; (&amp;mca_osc_pt2pt_component.frags);
</span><br>
<span class="quotelev1">&gt; +        if (OPAL_UNLIKELY(NULL == curr)) {
</span><br>
<span class="quotelev1">&gt;              return OMPI_ERR_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt; -        curr = peer-&gt;active_frag = (ompi_osc_pt2pt_frag_t*) item;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;          curr-&gt;target = target;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; @@ -96,7 +101,8 @@ static inline int ompi_osc_pt2pt_frag_alloc
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, in
</span><br>
<span class="quotelev1">&gt;          curr-&gt;top = (char*) (curr-&gt;header + 1);
</span><br>
<span class="quotelev1">&gt;          curr-&gt;remain_len = mca_osc_pt2pt_component.buffer_size;
</span><br>
<span class="quotelev1">&gt;          curr-&gt;module = module;
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;pending = 1;
</span><br>
<span class="quotelev1">&gt; +        curr-&gt;pending = 2;
</span><br>
<span class="quotelev1">&gt; +        curr-&gt;pending_long_sends = long_send;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;          curr-&gt;header-&gt;base.type = OMPI_OSC_PT2PT_HDR_TYPE_FRAG;
</span><br>
<span class="quotelev1">&gt;          curr-&gt;header-&gt;base.flags = OMPI_OSC_PT2PT_HDR_FLAG_VALID;
</span><br>
<span class="quotelev1">&gt; @@ -104,12 +110,18 @@ static inline int ompi_osc_pt2pt_frag_alloc
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, in
</span><br>
<span class="quotelev1">&gt;              curr-&gt;header-&gt;base.flags |=
</span><br>
<span class="quotelev1">&gt; OMPI_OSC_PT2PT_HDR_FLAG_PASSIVE_TARGET;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt;          curr-&gt;header-&gt;source = ompi_comm_rank(module-&gt;comm);
</span><br>
<span class="quotelev1">&gt; -        curr-&gt;header-&gt;num_ops = 0;
</span><br>
<span class="quotelev1">&gt; +        curr-&gt;header-&gt;num_ops = 1;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;          if (curr-&gt;remain_len &lt; request_len) {
</span><br>
<span class="quotelev1">&gt;              OPAL_THREAD_UNLOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt;              return OMPI_ERR_TEMP_OUT_OF_RESOURCE;
</span><br>
<span class="quotelev1">&gt;          }
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +        peer-&gt;active_frag = curr;
</span><br>
<span class="quotelev1">&gt; +    } else {
</span><br>
<span class="quotelev1">&gt; +        OPAL_THREAD_ADD32(&amp;curr-&gt;pending, 1);
</span><br>
<span class="quotelev1">&gt; +        OPAL_THREAD_ADD32(&amp;curr-&gt;header-&gt;num_ops, 1);
</span><br>
<span class="quotelev1">&gt; +        curr-&gt;pending_long_sends += long_send;
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      *ptr = curr-&gt;top;
</span><br>
<span class="quotelev1">&gt; @@ -117,24 +129,8 @@ static inline int ompi_osc_pt2pt_frag_alloc
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_module_t *module, in
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      curr-&gt;top += request_len;
</span><br>
<span class="quotelev1">&gt;      curr-&gt;remain_len -= request_len;
</span><br>
<span class="quotelev1">&gt; -    OPAL_THREAD_UNLOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    OPAL_THREAD_ADD32(&amp;curr-&gt;pending, 1);
</span><br>
<span class="quotelev1">&gt; -    OPAL_THREAD_ADD32(&amp;curr-&gt;header-&gt;num_ops, 1);
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -    return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt; -}
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -
</span><br>
<span class="quotelev1">&gt; -/*
</span><br>
<span class="quotelev1">&gt; - * Note: module lock must be held for this operation
</span><br>
<span class="quotelev1">&gt; - */
</span><br>
<span class="quotelev1">&gt; -static inline int ompi_osc_pt2pt_frag_finish(ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module,
</span><br>
<span class="quotelev1">&gt; -                                            ompi_osc_pt2pt_frag_t* buffer)
</span><br>
<span class="quotelev1">&gt; -{
</span><br>
<span class="quotelev1">&gt; -    if (0 == OPAL_THREAD_ADD32(&amp;buffer-&gt;pending, -1)) {
</span><br>
<span class="quotelev1">&gt; -        return ompi_osc_pt2pt_frag_start(module, buffer);
</span><br>
<span class="quotelev1">&gt; -    }
</span><br>
<span class="quotelev1">&gt; +    OPAL_THREAD_UNLOCK(&amp;module-&gt;lock);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      return OMPI_SUCCESS;
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_request.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_request.c
</span><br>
<span class="quotelev1">&gt; index eddccf5..6741036 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_request.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_request.c
</span><br>
<span class="quotelev1">&gt; @@ -51,6 +51,7 @@ request_construct(ompi_osc_pt2pt_request_t *request)
</span><br>
<span class="quotelev1">&gt;      request-&gt;super.req_status._cancelled = 0;
</span><br>
<span class="quotelev1">&gt;      request-&gt;super.req_free = request_free;
</span><br>
<span class="quotelev1">&gt;      request-&gt;super.req_cancel = request_cancel;
</span><br>
<span class="quotelev1">&gt; +    request-&gt;outstanding_requests = 0;
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;  OBJ_CLASS_INSTANCE(ompi_osc_pt2pt_request_t,
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_request.h
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_request.h
</span><br>
<span class="quotelev1">&gt; index 07b9d53..dee5c86 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_request.h
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_request.h
</span><br>
<span class="quotelev1">&gt; @@ -1,7 +1,7 @@
</span><br>
<span class="quotelev1">&gt;  /* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */
</span><br>
<span class="quotelev1">&gt;  /*
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2012      Sandia National Laboratories.  All rights
</span><br>
<span class="quotelev1">&gt; reserved.
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2014-2015 Los Alamos National Security, LLC. All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2014-2016 Los Alamos National Security, LLC. All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * Copyright (c) 2015      Research Organization for Information Science
</span><br>
<span class="quotelev1">&gt;   *                         and Technology (RIST). All rights reserved.
</span><br>
<span class="quotelev1">&gt; @@ -57,6 +57,7 @@ OBJ_CLASS_DECLARATION(ompi_osc_pt2pt_request_t);
</span><br>
<span class="quotelev1">&gt;  #define OMPI_OSC_PT2PT_REQUEST_RETURN(req)                              \
</span><br>
<span class="quotelev1">&gt;      do {                                                                \
</span><br>
<span class="quotelev1">&gt;          OMPI_REQUEST_FINI(&amp;(req)-&gt;super);                               \
</span><br>
<span class="quotelev1">&gt; +        (req)-&gt;outstanding_requests = 0;                                \
</span><br>
<span class="quotelev1">&gt;          opal_free_list_return (&amp;mca_osc_pt2pt_component.requests,       \
</span><br>
<span class="quotelev1">&gt;                                   (opal_free_list_item_t *) (req));      \
</span><br>
<span class="quotelev1">&gt;      } while (0)
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_sync.h
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_sync.h
</span><br>
<span class="quotelev1">&gt; index eee2964..f4e4adc 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_sync.h
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_sync.h
</span><br>
<span class="quotelev1">&gt; @@ -1,6 +1,6 @@
</span><br>
<span class="quotelev1">&gt;  /* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */
</span><br>
<span class="quotelev1">&gt;  /*
</span><br>
<span class="quotelev1">&gt; - * Copyright (c) 2015      Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt; + * Copyright (c) 2015-2016 Los Alamos National Security, LLC.  All rights
</span><br>
<span class="quotelev1">&gt;   *                         reserved.
</span><br>
<span class="quotelev1">&gt;   * $COPYRIGHT$
</span><br>
<span class="quotelev1">&gt;   *
</span><br>
<span class="quotelev1">&gt; @@ -163,8 +163,10 @@ static inline void ompi_osc_pt2pt_sync_expected
</span><br>
<span class="quotelev1">&gt; (ompi_osc_pt2pt_sync_t *sync)
</span><br>
<span class="quotelev1">&gt;  {
</span><br>
<span class="quotelev1">&gt;      int32_t new_value = OPAL_THREAD_ADD32 (&amp;sync-&gt;sync_expected, -1);
</span><br>
<span class="quotelev1">&gt;      if (0 == new_value) {
</span><br>
<span class="quotelev1">&gt; +        OPAL_THREAD_LOCK(&amp;sync-&gt;lock);
</span><br>
<span class="quotelev1">&gt;          sync-&gt;eager_send_active = true;
</span><br>
<span class="quotelev1">&gt;          opal_condition_broadcast (&amp;sync-&gt;cond);
</span><br>
<span class="quotelev1">&gt; +        OPAL_THREAD_UNLOCK(&amp;sync-&gt;lock);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; <a href="https://github.com/open-mpi/ompi-release/commit/b1cb049a9d9a486c6e08bd2966b0033e30df7055">https://github.com/open-mpi/ompi-release/commit/b1cb049a9d9a486c6e08bd2966b0033e30df7055</a>
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; commit b1cb049a9d9a486c6e08bd2966b0033e30df7055
</span><br>
<span class="quotelev1">&gt; Author: Gilles Gouaillardet &lt;gilles_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt; Date:   Tue Jan 5 16:57:37 2016 +0900
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     osc/pt2pt: use two distinct &quot;namespaces&quot; for tags
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     (cherry picked from
</span><br>
<span class="quotelev1">&gt; open-mpi/ompi_at_06ecdb6aa7ee688f51de2b3ca05e9f0605a90099)
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;     Signed-off-by: Nathan Hjelm &lt;hjelmn_at_[hidden]&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; index 51b14b7..1f3c204 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt.h
</span><br>
<span class="quotelev1">&gt; @@ -150,6 +150,7 @@ struct ompi_osc_pt2pt_module_t {
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /** cyclic counter for a unique tage for long messages. */
</span><br>
<span class="quotelev1">&gt;      unsigned int tag_counter;
</span><br>
<span class="quotelev1">&gt; +    unsigned int rtag_counter;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* Number of outgoing fragments that have completed since the
</span><br>
<span class="quotelev1">&gt;         begining of time */
</span><br>
<span class="quotelev1">&gt; @@ -659,11 +660,22 @@ static inline int get_tag(ompi_osc_pt2pt_module_t
</span><br>
<span class="quotelev1">&gt; *module)
</span><br>
<span class="quotelev1">&gt;         completion). */
</span><br>
<span class="quotelev1">&gt;      int tmp = module-&gt;tag_counter +
</span><br>
<span class="quotelev1">&gt; !!(module-&gt;passive_target_access_epoch);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -    module-&gt;tag_counter = (module-&gt;tag_counter + 2) &amp; OSC_PT2PT_FRAG_MASK;
</span><br>
<span class="quotelev1">&gt; +    module-&gt;tag_counter = (module-&gt;tag_counter + 4) &amp; OSC_PT2PT_FRAG_MASK;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      return tmp;
</span><br>
<span class="quotelev1">&gt;  }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; +static inline int get_rtag(ompi_osc_pt2pt_module_t *module)
</span><br>
<span class="quotelev1">&gt; +{
</span><br>
<span class="quotelev1">&gt; +    /* the LSB of the tag is used be the receiver to determine if the
</span><br>
<span class="quotelev1">&gt; +       message is a passive or active target (ie, where to mark
</span><br>
<span class="quotelev1">&gt; +       completion). */
</span><br>
<span class="quotelev1">&gt; +    int tmp = module-&gt;rtag_counter +
</span><br>
<span class="quotelev1">&gt; !!(module-&gt;passive_target_access_epoch);
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    module-&gt;rtag_counter = (module-&gt;rtag_counter + 4) &amp;
</span><br>
<span class="quotelev1">&gt; OSC_PT2PT_FRAG_MASK;
</span><br>
<span class="quotelev1">&gt; +
</span><br>
<span class="quotelev1">&gt; +    return tmp;
</span><br>
<span class="quotelev1">&gt; +}
</span><br>
<span class="quotelev1">&gt;  /**
</span><br>
<span class="quotelev1">&gt;   * ompi_osc_pt2pt_accumulate_lock:
</span><br>
<span class="quotelev1">&gt;   *
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; index 5bb3a07..b22f783 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_comm.c
</span><br>
<span class="quotelev1">&gt; @@ -475,7 +475,7 @@ ompi_osc_pt2pt_accumulate_w_req (const void
</span><br>
<span class="quotelev1">&gt; *origin_addr, int origin_count,
</span><br>
<span class="quotelev1">&gt;           }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;          is_long_msg = true;
</span><br>
<span class="quotelev1">&gt; -        tag = get_tag (module);
</span><br>
<span class="quotelev1">&gt; +        tag = get_rtag (module);
</span><br>
<span class="quotelev1">&gt;      }
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* flush will be called at the end of this function. make sure all
</span><br>
<span class="quotelev1">&gt; post messages have
</span><br>
<span class="quotelev1">&gt; diff --git a/ompi/mca/osc/pt2pt/osc_pt2pt_component.c
</span><br>
<span class="quotelev1">&gt; b/ompi/mca/osc/pt2pt/osc_pt2pt_component.c
</span><br>
<span class="quotelev1">&gt; index 6a8f53e..41bbe18 100644
</span><br>
<span class="quotelev1">&gt; --- a/ompi/mca/osc/pt2pt/osc_pt2pt_component.c
</span><br>
<span class="quotelev1">&gt; +++ b/ompi/mca/osc/pt2pt/osc_pt2pt_component.c
</span><br>
<span class="quotelev1">&gt; @@ -290,6 +290,7 @@ component_select(struct ompi_win_t *win, void **base,
</span><br>
<span class="quotelev1">&gt; size_t size, int disp_unit
</span><br>
<span class="quotelev1">&gt;      /* fill in the function pointer part */
</span><br>
<span class="quotelev1">&gt;      memcpy(module, &amp;ompi_osc_pt2pt_module_template,
</span><br>
<span class="quotelev1">&gt;             sizeof(ompi_osc_base_module_t));
</span><br>
<span class="quotelev1">&gt; +    module-&gt;rtag_counter = 2;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;      /* initialize the objects, so that always free in cleanup */
</span><br>
<span class="quotelev1">&gt;      OBJ_CONSTRUCT(&amp;module-&gt;lock, opal_mutex_t);
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; -----------------------------------------------------------------------
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; Summary of changes:
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt.h                |  36 +++---
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_active_target.c  |   5 +-
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_comm.c           | 170
</span><br>
<span class="quotelev1">&gt; ++++++++++++--------------
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_component.c      |   1 +
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_data_move.c      |  31 +----
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_frag.h           | 147 +++++++++++++---------
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_passive_target.c |   4 +-
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_request.c        |   1 +
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_request.h        |   3 +-
</span><br>
<span class="quotelev1">&gt;  ompi/mca/osc/pt2pt/osc_pt2pt_sync.h           |   4 +-
</span><br>
<span class="quotelev1">&gt;  10 files changed, 193 insertions(+), 209 deletions(-)
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt;
</span><br>
<span class="quotelev1">&gt; hooks/post-receive
</span><br>
<span class="quotelev1">&gt; --
</span><br>
<span class="quotelev1">&gt; open-mpi/ompi-release
</span><br>
<span class="quotelev1">&gt; _______________________________________________
</span><br>
<span class="quotelev1">&gt; ompi-commits mailing list
</span><br>
<span class="quotelev1">&gt; ompi-commits_at_[hidden]
</span><br>
<span class="quotelev1">&gt; <a href="http://www.open-mpi.org/mailman/listinfo.cgi/ompi-commits">http://www.open-mpi.org/mailman/listinfo.cgi/ompi-commits</a>
</span><br>
<span class="quotelev1">&gt;
</span><br>
<p><hr>
<ul>
<li>text/html attachment: <a href="http://www.open-mpi.org/community/lists/devel/att-18569/attachment">attachment</a>
</ul>
<!-- attachment="attachment" -->
<!-- body="end" -->
<hr>
<ul class="links">
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="18570.php">Jeff Squyres (jsquyres): "Re: [OMPI devel] orted hangs on SLES12 when running 80 ranks per node"</a>
<li><strong>Previous message:</strong> <a href="18568.php">Justin Cinkelj: "Re: [OMPI devel] mpirun --launch-proxy options"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
</ul>
<div class="center">
<table border="2" width="100%" class="links">
<tr>
<th><a href="date.php">Date view</a></th>
<th><a href="index.php">Thread view</a></th>
<th><a href="subject.php">Subject view</a></th>
<th><a href="author.php">Author view</a></th>
</tr>
</table>
</div>
<!-- trailer="footer" -->
<? include("../../include/msg-footer.inc") ?>
