Index: test/class/ompi_pointer_array.c
===================================================================
--- test/class/ompi_pointer_array.c	(revision 16968)
+++ test/class/ompi_pointer_array.c	(working copy)
@@ -1,158 +0,0 @@
-/*
- * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
- *                         University Research and Technology
- *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
- *                         of Tennessee Research Foundation.  All rights
- *                         reserved.
- * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
- *                         University of Stuttgart.  All rights reserved.
- * Copyright (c) 2004-2005 The Regents of the University of California.
- *                         All rights reserved.
- * $COPYRIGHT$
- * 
- * Additional copyrights may follow
- * 
- * $HEADER$
- */
-
-/*
- * This test is intended to test the ompi_pointer_array
- *   class
- */
-
-#include "ompi_config.h"
-#include <stdlib.h>
-#include <stdio.h>
-#include <assert.h>
-#include <string.h>
-
-#include "support.h"
-#include "ompi/class/ompi_pointer_array.h"
-
-typedef union {
-    int ivalue;
-    char *cvalue;
-} value_t;
-
-static void test(bool thread_usage){
-
-    /* local variables */
-    ompi_pointer_array_t *array;
-    value_t *test_data;
-    int len_test_data,i,test_len_in_array,error_cnt;
-    int ele_index;
-    int use_threads,error_code;
-    value_t value;
-
-    /* initialize thread levels */
-    use_threads=(int)opal_set_using_threads(thread_usage);
-    
-    array=OBJ_NEW(ompi_pointer_array_t);
-    assert(array);
-
-    len_test_data=5;
-    test_data=malloc(sizeof(value_t)*len_test_data);
-    assert(test_data);
-
-    for(i=0 ; i < len_test_data ; i++ ) {
-        test_data[i].ivalue = (i+1);
-    }
-
-    /* add data to table */
-    test_len_in_array=3;
-    assert(len_test_data>=test_len_in_array);
-    for(i=0 ; i < test_len_in_array ; i++ ) {
-        ompi_pointer_array_add(array,test_data[i].cvalue);
-    }
-    /* check to see that test_len_in_array are in array */
-    if( (array->size - array->number_free) == test_len_in_array) {
-        test_success();
-    } else {
-        test_failure("check on number of elments in array");
-    }
-
-    /* check order of data */
-    error_cnt=0;
-    for(i=0 ; i < test_len_in_array ; i++ ) {
-        value.cvalue = array->addr[i];
-        if( (i+1) != value.ivalue ) {
-            error_cnt++;
-        }
-    }
-    if( 0 == error_cnt ) {
-        test_success();
-    } else {
-        test_failure(" data check ");
-    }
-
-    /* free 2nd element and make sure that value is reset correctly,
-     *   and that the lowest_index is also reset correctly */
-    ele_index=1;
-    error_code=ompi_pointer_array_set_item(array,ele_index,NULL);
-    if( 0 == error_code ) {
-        test_success();
-    } else {
-        test_failure(" ompi_pointer_array_set_item ");
-    }
-    if( NULL == array->addr[ele_index]){
-        test_success();
-    } else {
-        test_failure(" set pointer value");
-    }
-    if( ele_index == array->lowest_free ) {
-        test_success();
-    } else {
-        test_failure(" lowest free ");
-    }
-
-    /* test ompi_pointer_array_get_item */
-    array->number_free=array->size;
-    array->lowest_free=0;
-    for(i=0 ; i < array->size ; i++ ) {
-        array->addr[i] = NULL;
-    }
-    error_cnt=0;
-    for(i=0 ; i < array->size ; i++ ) {
-        value.ivalue = i + 2;
-        ele_index=ompi_pointer_array_add(array, value.cvalue);
-        if( i != ele_index ) {
-            error_cnt++;
-        }
-    }
-    if( 0 == error_cnt ) {
-        test_success();
-    } else {
-        test_failure(" ompi_pointer_array_add 2nd ");
-    }
-
-    error_cnt=0;
-    for(i=0 ; i < array->size ; i++ ) {
-        value.cvalue = ompi_pointer_array_get_item(array,i);
-        if( (i+2) != value.ivalue ) {
-            error_cnt++;
-        }
-    }
-    if( 0 == error_cnt ) {
-        test_success();
-    } else {
-        test_failure(" data check - 2nd ");
-    }
-
-    free (array);
-    free(test_data);
-}
-
-
-int main(int argc, char **argv)
-{
-    test_init("ompi_pointer_array");
-
-    /* run through tests with thread usage set to false */
-    test(false);
-
-    /* run through tests with thread usage set to true */
-    test(true);
-
-    return test_finalize();
-}
Index: test/class/Makefile.am
===================================================================
--- test/class/Makefile.am	(revision 16968)
+++ test/class/Makefile.am	(working copy)
@@ -3,7 +3,7 @@
 # Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
 #                         University Research and Technology
 #                         Corporation.  All rights reserved.
-# Copyright (c) 2004-2005 The University of Tennessee and The University
+# Copyright (c) 2004-2007 The University of Tennessee and The University
 #                         of Tennessee Research Foundation.  All rights
 #                         reserved.
 # Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -24,7 +24,7 @@
 	opal_hash_table \
 	opal_list \
 	opal_value_array \
-	ompi_pointer_array \
+	opal_pointer_array \
 	ompi_rb_tree
 
 TESTS = \
@@ -66,13 +66,13 @@
         $(top_builddir)/test/support/libsupport.a
 opal_hash_table_DEPENDENCIES = $(opal_hash_table_LDADD)
 
-ompi_pointer_array_SOURCES = ompi_pointer_array.c
-ompi_pointer_array_LDADD = \
+opal_pointer_array_SOURCES = opal_pointer_array.c
+opal_pointer_array_LDADD = \
         $(top_builddir)/ompi/libmpi.la \
         $(top_builddir)/orte/libopen-rte.la \
         $(top_builddir)/opal/libopen-pal.la \
         $(top_builddir)/test/support/libsupport.a
-ompi_pointer_array_DEPENDENCIES = $(ompi_pointer_array_LDADD)
+opal_pointer_array_DEPENDENCIES = $(opal_pointer_array_LDADD)
 
 opal_value_array_SOURCES = opal_value_array.c
 opal_value_array_LDADD = \
Index: opal/include/opal/sys/ia32/atomic.h
===================================================================
--- opal/include/opal/sys/ia32/atomic.h	(revision 16968)
+++ opal/include/opal/sys/ia32/atomic.h	(working copy)
@@ -46,7 +46,7 @@
 #define OPAL_HAVE_ATOMIC_ADD_32 1
 #define OPAL_HAVE_ATOMIC_SUB_32 1
 
-#define OPAL_HAVE_ATOMIC_CMPSET_64 1
+#define OPAL_HAVE_ATOMIC_CMPSET_64 0
 
 #undef OPAL_HAVE_INLINE_ATOMIC_CMPSET_64
 #define OPAL_HAVE_INLINE_ATOMIC_CMPSET_64 0
Index: opal/class/opal_pointer_array.h
===================================================================
--- opal/class/opal_pointer_array.h	(revision 0)
+++ opal/class/opal_pointer_array.h	(revision 0)
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */
+/** @file
+ *
+ * See opal_bitmap.h for an explanation of why there is a split
+ * between OPAL and ORTE for this generic class.
+ *
+ * Utility functions to manage fortran <-> c opaque object
+ * translation.  Note that since MPI defines fortran handles as
+ * [signed] int's, we use int everywhere in here where you would
+ * normally expect size_t.  There's some code that makes sure indices
+ * don't go above FORTRAN_HANDLE_MAX (which is min(INT_MAX, fortran
+ * INTEGER max)), just to be sure.
+ */
+
+#ifndef OPAL_POINTER_ARRAY_H
+#define OPAL_POINTER_ARRAY_H
+
+#include "opal_config.h"
+
+#include "opal/threads/mutex.h"
+#include "opal/class/opal_object.h"
+
+BEGIN_C_DECLS
+
+/**
+ * dynamic pointer array
+ */
+struct opal_pointer_array_t {
+    /** base class */
+    opal_object_t super;
+    /** synchronization object */
+    opal_mutex_t lock;
+    /** Index of lowest free element.  NOTE: This is only an
+        optimization to know where to search for the first free slot.
+        It does \em not necessarily imply indices all above this index
+        are not taken! */
+    int lowest_free;
+    /** number of free elements in the list */
+    int number_free;
+    /** size of list, i.e. number of elements in addr */
+    int size;
+    /** maximum size of the array */
+    int max_size;
+    /** block size for each allocation */
+    int block_size;
+    /** pointer to array of pointers */
+    void **addr;
+};
+/**
+ * Convenience typedef
+ */
+typedef struct opal_pointer_array_t opal_pointer_array_t;
+/**
+ * Class declaration
+ */
+OPAL_DECLSPEC OBJ_CLASS_DECLARATION(opal_pointer_array_t);
+
+/**
+ * Initialize the pointer array with an initial size of initial_allocation.
+ * Set the maximum size of the array, as well as the size of the allocation
+ * block for all subsequent growing operations. Remarque: The pointer array
+ * has to be created bfore calling this function.
+ *
+ * @param array Pointer to pointer of an array (IN/OUT)
+ * @param initial_allocation The number of elements in the initial array (IN)
+ * @param max_size The maximum size of the array (IN)
+ * @param block_size The size for all subsequent grows of the array (IN).
+ *
+ * @return OPAL_SUCCESS if all initializations were succesfull. Otherwise,
+ *  the error indicate what went wrong in the function.
+ */
+OPAL_DECLSPEC int opal_pointer_array_init( opal_pointer_array_t* array,
+                                           int initial_allocation,
+                                           int max_size, int block_size );
+
+/**
+ * Add a pointer to the array (Grow the array, if need be)
+ *
+ * @param array Pointer to array (IN)
+ * @param ptr Pointer value (IN)
+ *
+ * @return Index of inserted array element.  Return value of
+ *  (-1) indicates an error.
+ */
+OPAL_DECLSPEC int opal_pointer_array_add(opal_pointer_array_t *array, void *ptr);
+
+/**
+ * Set the value of an element in array
+ *
+ * @param array Pointer to array (IN)
+ * @param index Index of element to be reset (IN)
+ * @param value New value to be set at element index (IN)
+ *
+ * @return Error code.  (-1) indicates an error.
+ */
+OPAL_DECLSPEC int opal_pointer_array_set_item(opal_pointer_array_t *array, 
+                                int index, void *value);
+
+/**
+ * Get the value of an element in array
+ *
+ * @param array          Pointer to array (IN)
+ * @param element_index  Index of element to be returned (IN)
+ *
+ * @return Error code.  NULL indicates an error.
+ */
+
+static inline void *opal_pointer_array_get_item(opal_pointer_array_t *table, 
+                                                int element_index)
+{
+    void *p;
+
+	if( table->size <= element_index ) {
+		return NULL;
+	}
+    OPAL_THREAD_LOCK(&(table->lock));
+    p = table->addr[element_index];
+    OPAL_THREAD_UNLOCK(&(table->lock));
+    return p;
+}
+
+
+/**
+ * Get the size of the pointer array
+ *
+ * @param array Pointer to array (IN)
+ *
+ * @returns size Size of the array
+ *
+ * Simple inline function to return the size of the array in order to
+ * hide the member field from external users.
+ */
+static inline int opal_pointer_array_get_size(opal_pointer_array_t *array)
+{
+  return array->size;
+}
+
+/**
+ * Set the size of the pointer array
+ *
+ * @param array Pointer to array (IN)
+ *
+ * @param size Desired size of the array
+ *
+ * Simple function to set the size of the array in order to
+ * hide the member field from external users.
+ */
+OPAL_DECLSPEC int opal_pointer_array_set_size(opal_pointer_array_t *array, int size);
+
+/**
+ * Test whether a certain element is already in use. If not yet
+ * in use, reserve it.
+ *
+ * @param array Pointer to array (IN)
+ * @param index Index of element to be tested (IN)
+ * @param value New value to be set at element index (IN)
+ *
+ * @return true/false True if element could be reserved
+ *                    False if element could not be reserved (e.g., in use).
+ *
+ * In contrary to array_set, this function does not allow to overwrite 
+ * a value, unless the previous value is NULL ( equiv. to free ).
+ */
+OPAL_DECLSPEC bool opal_pointer_array_test_and_set_item (opal_pointer_array_t *table, 
+                                          int index,
+                                          void *value);
+
+/**
+ * Empty the array.
+ *
+ * @param array Pointer to array (IN)
+ *
+ */
+static inline void opal_pointer_array_remove_all(opal_pointer_array_t *array)
+{
+    int i;
+    if( array->number_free == array->size )
+        return;  /* nothing to do here this time (the array is already empty) */
+ 
+    OPAL_THREAD_LOCK(&array->lock);
+    array->lowest_free = 0;
+    array->number_free = array->size;
+    for(i=0; i<array->size; i++) {
+        array->addr[i] = NULL;
+    }
+    OPAL_THREAD_UNLOCK(&array->lock);
+}
+
+END_C_DECLS
+
+#endif /* OPAL_POINTER_ARRAY_H */
Index: opal/class/Makefile.am
===================================================================
--- opal/class/Makefile.am	(revision 16968)
+++ opal/class/Makefile.am	(working copy)
@@ -3,7 +3,7 @@
 # Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
 #                         University Research and Technology
 #                         Corporation.  All rights reserved.
-# Copyright (c) 2004-2005 The University of Tennessee and The University
+# Copyright (c) 2004-2007 The University of Tennessee and The University
 #                         of Tennessee Research Foundation.  All rights
 #                         reserved.
 # Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -26,6 +26,7 @@
         class/opal_list.h \
         class/opal_object.h \
         class/opal_atomic_lifo.h \
+        class/opal_pointer_array.h \
         class/opal_value_array.h
 
 libopen_pal_la_SOURCES += \
@@ -34,4 +35,5 @@
         class/opal_list.c \
         class/opal_object.c \
         class/opal_atomic_lifo.c \
+        class/opal_pointer_array.c \
         class/opal_value_array.c
Index: opal/class/opal_pointer_array.c
===================================================================
--- opal/class/opal_pointer_array.c	(revision 0)
+++ opal/class/opal_pointer_array.c	(revision 0)
@@ -0,0 +1,336 @@
+/*
+ * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */
+
+#include "opal_config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+
+#include "opal/constants.h"
+#include "opal/class/opal_pointer_array.h"
+#include "opal/util/output.h"
+
+enum { TABLE_INIT = 1, TABLE_GROW = 2 };
+
+static void opal_pointer_array_construct(opal_pointer_array_t *);
+static void opal_pointer_array_destruct(opal_pointer_array_t *);
+static bool grow_table(opal_pointer_array_t *table, int soft, int hard);
+
+OBJ_CLASS_INSTANCE(opal_pointer_array_t, opal_object_t,
+                   opal_pointer_array_construct,
+                   opal_pointer_array_destruct);
+
+/*
+ * opal_pointer_array constructor
+ */
+static void opal_pointer_array_construct(opal_pointer_array_t *array)
+{
+    OBJ_CONSTRUCT(&array->lock, opal_mutex_t);
+    array->lowest_free = 0;
+    array->number_free = 0;
+    array->size = 0;
+    array->max_size = INT_MAX;
+    array->block_size = 0;
+    array->addr = 0;
+}
+
+/*
+ * opal_pointer_array destructor
+ */
+static void opal_pointer_array_destruct(opal_pointer_array_t *array)
+{
+    /* free table */
+    if( NULL != array->addr) {
+        free(array->addr);
+    }
+
+    OBJ_DESTRUCT(&array->lock);
+}
+
+/**
+ * initialize an array object
+ */
+int opal_pointer_array_init(opal_pointer_array_t* array,
+                            int initial_allocation,
+                            int max_size, int block_size)
+{
+    size_t num_bytes;
+    
+    /* check for errors */
+    if (NULL == array || max_size < block_size) {
+        return OPAL_ERR_BAD_PARAM;
+    }
+    
+    array->max_size = max_size;
+    array->block_size = block_size;
+   
+    num_bytes = (0 < initial_allocation ? initial_allocation : block_size);
+    array->number_free = num_bytes;
+    array->size = num_bytes;
+    num_bytes *= sizeof(void*);
+
+    /* Allocate and set the array to NULL */   
+    array->addr = (void **)calloc(num_bytes, 1);
+    if (NULL == array->addr) { /* out of memory */
+        return OPAL_ERR_OUT_OF_RESOURCE;
+    }
+
+    return OPAL_SUCCESS;
+}
+
+/**
+ * add a pointer to dynamic pointer table
+ *
+ * @param table Pointer to opal_pointer_array_t object (IN)
+ * @param ptr Pointer to be added to table    (IN)
+ *
+ * @return Array index where ptr is inserted or OPAL_ERROR if it fails
+ */
+int opal_pointer_array_add(opal_pointer_array_t *table, void *ptr)
+{
+    int i, index;
+
+    OPAL_THREAD_LOCK(&(table->lock));
+
+    if (table->number_free == 0) {
+        /* need to grow table */
+        if (!grow_table(table, 
+                        (NULL == table->addr ? TABLE_INIT : table->size * TABLE_GROW), 
+                        OMPI_FORTRAN_HANDLE_MAX)) {
+            OPAL_THREAD_UNLOCK(&(table->lock));
+            return OPAL_ERR_OUT_OF_RESOURCE;
+        }
+    }
+
+    assert( (table->addr != NULL) && (table->size > 0) );
+    assert( (table->lowest_free >= 0) && (table->lowest_free < table->size) );
+    assert( (table->number_free > 0) && (table->number_free <= table->size) );
+
+    /*
+     * add pointer to table, and return the index
+     */
+
+    index = table->lowest_free;
+    assert(table->addr[index] == NULL);
+    table->addr[index] = ptr;
+    table->number_free--;
+    if (table->number_free > 0) {
+        for (i = table->lowest_free + 1; i < table->size; i++) {
+            if (table->addr[i] == NULL) {
+                table->lowest_free = i;
+                break;
+            }
+        }
+    }
+    else {
+        table->lowest_free = table->size;
+    }
+
+    OPAL_THREAD_UNLOCK(&(table->lock));
+    return index;
+}
+
+/**
+ * Set the value of the dynamic array at a specified location.
+ *
+ *
+ * @param table Pointer to opal_pointer_array_t object (IN)
+ * @param ptr Pointer to be added to table    (IN)
+ *
+ * @return Error code
+ *
+ * Assumption: NULL element is free element.
+ */
+int opal_pointer_array_set_item(opal_pointer_array_t *table, int index,
+                                void * value)
+{
+    assert(table != NULL);
+
+    /* expand table if required to set a specific index */
+
+    OPAL_THREAD_LOCK(&(table->lock));
+    if (table->size <= index) {
+        if (!grow_table(table, ((index / TABLE_GROW) + 1) * TABLE_GROW,
+                        index)) {
+            OPAL_THREAD_UNLOCK(&(table->lock));
+            return OPAL_ERROR;
+        }
+    }
+
+    /* mark element as free, if NULL element */
+    if( NULL == value ) {
+        if (index < table->lowest_free) {
+            table->lowest_free = index;
+        }
+        if( NULL != table->addr[index] ) {
+            table->number_free++;
+        }
+    } else {
+        /* Reset lowest_free if required */
+        if ( index == table->lowest_free ) {
+            int i;
+            
+            table->lowest_free = table->size;
+            for ( i=index; i<table->size; i++) {
+                if ( NULL == table->addr[i] ){
+                    table->lowest_free = i;
+                    break;
+                }                    
+            }
+        }
+    }
+    table->addr[index] = value;	
+
+#if 0
+    opal_output(0,"opal_pointer_array_set_item: OUT: "
+                " table %p (size %ld, lowest free %ld, number free %ld)"
+                " addr[%d] = %p\n",
+                table, table->size, table->lowest_free, table->number_free,
+                index, table->addr[index]);
+#endif
+
+    OPAL_THREAD_UNLOCK(&(table->lock));
+    return OPAL_SUCCESS;
+}
+
+/**
+ * Test whether a certain element is already in use. If not yet
+ * in use, reserve it.
+ *
+ * @param array Pointer to array (IN)
+ * @param index Index of element to be tested (IN)
+ * @param value New value to be set at element index (IN)
+ *
+ * @return true/false True if element could be reserved
+ *                    False if element could not be reserved (e.g.in use).
+ *
+ * In contrary to array_set, this function does not allow to overwrite 
+ * a value, unless the previous value is NULL ( equiv. to free ).
+ */
+bool opal_pointer_array_test_and_set_item (opal_pointer_array_t *table, 
+                                           int index, void *value)
+{
+    assert(table != NULL);
+    assert(index >= 0);
+
+#if 0
+    opal_output(0,"opal_pointer_array_test_and_set_item: IN:  "
+               " table %p (size %ld, lowest free %ld, number free %ld)"
+               " addr[%d] = %p\n",
+               table, table->size, table->lowest_free, table->number_free,
+               index, table->addr[index]);
+#endif
+
+    /* expand table if required to set a specific index */
+    OPAL_THREAD_LOCK(&(table->lock));
+    if ( index < table->size && table->addr[index] != NULL ) {
+        /* This element is already in use */
+        OPAL_THREAD_UNLOCK(&(table->lock));
+        return false;
+    }
+
+    /* Do we need to grow the table? */
+
+    if (table->size <= index) {
+        if (!grow_table(table, (((index / TABLE_GROW) + 1) * TABLE_GROW),
+                        index)) {
+            OPAL_THREAD_UNLOCK(&(table->lock));
+            return false;
+        }
+    }
+
+    /* 
+     * allow a specific index to be changed.
+     */
+    table->addr[index] = value;
+    table->number_free--;
+    /* Reset lowest_free if required */
+    if ( index == table->lowest_free ) {
+        int i;
+
+	table->lowest_free = table->size;
+        for ( i=index; i<table->size; i++) {
+            if ( NULL == table->addr[i] ){
+                table->lowest_free = i;
+                break;
+            }                    
+        }
+    }
+
+#if 0
+    opal_output(0,"opal_pointer_array_test_and_set_item: OUT: "
+               " table %p (size %ld, lowest free %ld, number free %ld)"
+               " addr[%d] = %p\n",
+               table, table->size, table->lowest_free, table->number_free,
+               index, table->addr[index]);
+#endif
+
+    OPAL_THREAD_UNLOCK(&(table->lock));
+    return true;
+}
+
+int opal_pointer_array_set_size(opal_pointer_array_t *array, int new_size)
+{
+    OPAL_THREAD_LOCK(&(array->lock));
+    if(new_size > array->size) {
+        if (!grow_table(array, new_size, new_size)) {
+            OPAL_THREAD_UNLOCK(&(array->lock));
+            return OPAL_ERROR;
+        }
+    }
+    OPAL_THREAD_UNLOCK(&(array->lock));
+    return OPAL_SUCCESS;
+}
+
+static bool grow_table(opal_pointer_array_t *table, int soft, int hard)
+{
+    int new_size, i, new_size_int;
+    void *p;
+
+    /* new_size = ((table->size + num_needed + table->block_size - 1) /
+       table->block_size) * table->block_size; */
+    new_size = soft;
+    if( soft > table->max_size ) {
+        if( hard > table->max_size ) {
+            return false;
+        }
+        new_size = hard;
+    }
+    if( new_size >= table->max_size ) {
+        return false;
+    }
+
+    p = (void **) realloc(table->addr, new_size * sizeof(void *));
+    if (p == NULL) {
+        return false;
+    }
+    
+    /* We've already established (above) that the arithmetic
+       below will be less than OMPI_FORTRAN_HANDLE_MAX */
+    
+    new_size_int = (int) new_size;
+    table->number_free += new_size_int - table->size;
+    table->addr = (void**)p;
+    for (i = table->size; i < new_size_int; ++i) {
+        table->addr[i] = NULL;
+    }
+    table->size = new_size_int;
+
+    return true;
+}
Index: ompi/file/file.c
===================================================================
--- ompi/file/file.c	(revision 16968)
+++ ompi/file/file.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -28,7 +28,7 @@
 /*
  * Table for Fortran <-> C file handle conversion
  */
-ompi_pointer_array_t ompi_file_f_to_c_table; 
+opal_pointer_array_t ompi_file_f_to_c_table; 
 
 /*
  * MPI_FILE_NULL
@@ -59,7 +59,11 @@
 {
     /* Setup file array */
 
-    OBJ_CONSTRUCT(&ompi_file_f_to_c_table, ompi_pointer_array_t); 
+    OBJ_CONSTRUCT(&ompi_file_f_to_c_table, opal_pointer_array_t); 
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_file_f_to_c_table, 0,
+                                                OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
 
     /* Setup MPI_FILE_NULL.  Note that it will have the default error
        handler of MPI_ERRORS_RETURN, per MPI-2:9.7 (p265).  */
@@ -68,7 +72,7 @@
     ompi_mpi_file_null.f_comm = &ompi_mpi_comm_null;
     OBJ_RETAIN(ompi_mpi_file_null.f_comm);
     ompi_mpi_file_null.f_f_to_c_index = 0;
-    ompi_pointer_array_set_item(&ompi_file_f_to_c_table, 0,
+    opal_pointer_array_set_item(&ompi_file_f_to_c_table, 0,
                                 &ompi_mpi_file_null);
 
     /* All done */
@@ -159,14 +163,14 @@
      to call OBJ_RELEASE on it. */
 
     OBJ_DESTRUCT(&ompi_mpi_file_null);
-    ompi_pointer_array_set_item(&ompi_file_f_to_c_table, 0, NULL);
+    opal_pointer_array_set_item(&ompi_file_f_to_c_table, 0, NULL);
 
     /* Iterate through all the file handles and destroy them.  Note
        that this also takes care of destroying MPI_FILE_NULL. */
 
-    max = ompi_pointer_array_get_size(&ompi_file_f_to_c_table);
+    max = opal_pointer_array_get_size(&ompi_file_f_to_c_table);
     for (num_unnamed = i = 0; i < max; ++i) {
-        file = (ompi_file_t *)ompi_pointer_array_get_item(&ompi_file_f_to_c_table, i);
+        file = (ompi_file_t *)opal_pointer_array_get_item(&ompi_file_f_to_c_table, i);
         
         /* If the file was closed but still exists because the user
            told us to never free handles, then do an OBJ_RELEASE it
@@ -176,7 +180,7 @@
         if (NULL != file && ompi_debug_no_free_handles && 
             0 == (file->f_flags & OMPI_FILE_ISCLOSED)) {
             OBJ_RELEASE(file);
-            file = (ompi_file_t *)ompi_pointer_array_get_item(&ompi_file_f_to_c_table, i);
+            file = (ompi_file_t *)opal_pointer_array_get_item(&ompi_file_f_to_c_table, i);
         } 
         
         if (NULL != file) {
@@ -223,7 +227,7 @@
 
     /* Initialize the fortran <--> C translation index */
 
-    file->f_f_to_c_index = ompi_pointer_array_add(&ompi_file_f_to_c_table, 
+    file->f_f_to_c_index = opal_pointer_array_add(&ompi_file_f_to_c_table, 
                                                   file);
 
     /* Initialize the error handler.  Per MPI-2:9.7 (p265), the
@@ -313,9 +317,9 @@
     /* Reset the f_to_c table entry */
 
     if (MPI_UNDEFINED != file->f_f_to_c_index &&
-        NULL != ompi_pointer_array_get_item(&ompi_file_f_to_c_table,
+        NULL != opal_pointer_array_get_item(&ompi_file_f_to_c_table,
                                             file->f_f_to_c_index)) {
-        ompi_pointer_array_set_item(&ompi_file_f_to_c_table,
+        opal_pointer_array_set_item(&ompi_file_f_to_c_table,
                                     file->f_f_to_c_index, NULL);
     }
 }
Index: ompi/file/file.h
===================================================================
--- ompi/file/file.h	(revision 16968)
+++ ompi/file/file.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -31,9 +31,7 @@
 #define OMPI_FILE_ISCLOSED     0x00000001
 #define OMPI_FILE_HIDDEN       0x00000002
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
 /**
  * Back-end structure for MPI_File
@@ -107,83 +105,79 @@
 /**
  * Fortran to C conversion table
  */
-extern ompi_pointer_array_t ompi_file_f_to_c_table;
+extern opal_pointer_array_t ompi_file_f_to_c_table;
 
+/**
+ * Initialize MPI_File handling.
+ *
+ * @retval OMPI_SUCCESS Always.
+ *
+ * Invoked during ompi_mpi_init().
+ */
+int ompi_file_init(void);
 
-
-    /**
-     * Initialize MPI_File handling.
-     *
-     * @retval OMPI_SUCCESS Always.
-     *
-     * Invoked during ompi_mpi_init().
-     */
-    int ompi_file_init(void);
-
-    /**
-     * Back-end to MPI_FILE_OPEN: create a file handle, select an io
-     * component to use, and have that componet open the file.
-     *
-     * @param comm Communicator
-     * @param filename String filename
-     * @param amode Mode flags
-     * @param info Info
-     * @param fh Output file handle
-     *
-     * @retval OMPI_SUCCESS Upon success
-     * @retval OMPI_ERR* Upon error
-     *
-     * Create a file handle and select an io module to be paired with
-     * it.  There is a corresponding ompi_file_close() function; it
-     * mainly calls OBJ_RELEASE() but also does some other error
-     * handling as well.
-     */
-    int ompi_file_open(struct ompi_communicator_t *comm, char *filename, 
-                       int amode, struct ompi_info_t *info, 
-                       ompi_file_t **fh);
+/**
+ * Back-end to MPI_FILE_OPEN: create a file handle, select an io
+ * component to use, and have that componet open the file.
+ *
+ * @param comm Communicator
+ * @param filename String filename
+ * @param amode Mode flags
+ * @param info Info
+ * @param fh Output file handle
+ *
+ * @retval OMPI_SUCCESS Upon success
+ * @retval OMPI_ERR* Upon error
+ *
+ * Create a file handle and select an io module to be paired with
+ * it.  There is a corresponding ompi_file_close() function; it
+ * mainly calls OBJ_RELEASE() but also does some other error
+ * handling as well.
+ */
+int ompi_file_open(struct ompi_communicator_t *comm, char *filename, 
+                   int amode, struct ompi_info_t *info, 
+                   ompi_file_t **fh);
     
-    /** 
-     * Atomicly set a name on a file handle.
-     *
-     * @param file MPI_File handle to set the name on
-     * @param name NULL-terminated string to use
-     *
-     * @returns OMPI_SUCCESS Always.
-     *
-     * At most (MPI_MAX_OBJECT_NAME-1) characters will be copied over to
-     * the file name's name.  This function is performed atomically -- a
-     * lock is used to ensure that there are not multiple writers to the
-     * name to ensure that we don't end up with an erroneous name (e.g.,
-     * a name without a \0 at the end).  After invoking this function,
-     * ompi_file_is_name_set() will return true.
-     */
-    int ompi_file_set_name(ompi_file_t *file, char *name);
+/** 
+ * Atomicly set a name on a file handle.
+ *
+ * @param file MPI_File handle to set the name on
+ * @param name NULL-terminated string to use
+ *
+ * @returns OMPI_SUCCESS Always.
+ *
+ * At most (MPI_MAX_OBJECT_NAME-1) characters will be copied over to
+ * the file name's name.  This function is performed atomically -- a
+ * lock is used to ensure that there are not multiple writers to the
+ * name to ensure that we don't end up with an erroneous name (e.g.,
+ * a name without a \0 at the end).  After invoking this function,
+ * ompi_file_is_name_set() will return true.
+ */
+int ompi_file_set_name(ompi_file_t *file, char *name);
 
-    /**
-     * Back-end to MPI_FILE_CLOSE: destroy an ompi_file_t handle and
-     * close the file.
-     *
-     * @param file Pointer to ompi_file_t
-     *
-     * @returns OMPI_SUCCESS Always.
-     *
-     * This is the preferred mechanism for freeing an ompi_file_t.
-     * Although the main action that it performs is OBJ_RELEASE(), it
-     * also does some additional handling for error checking, etc.
-     */
-    int ompi_file_close(ompi_file_t **file);
+/**
+ * Back-end to MPI_FILE_CLOSE: destroy an ompi_file_t handle and
+ * close the file.
+ *
+ * @param file Pointer to ompi_file_t
+ *
+ * @returns OMPI_SUCCESS Always.
+ *
+ * This is the preferred mechanism for freeing an ompi_file_t.
+ * Although the main action that it performs is OBJ_RELEASE(), it
+ * also does some additional handling for error checking, etc.
+ */
+int ompi_file_close(ompi_file_t **file);
 
-    /**
-     * Tear down MPI_File handling.
-     *
-     * @retval OMPI_SUCCESS Always.
-     *
-     * Invoked during ompi_mpi_finalize().
-     */
-    int ompi_file_finalize(void);
+/**
+ * Tear down MPI_File handling.
+ *
+ * @retval OMPI_SUCCESS Always.
+ *
+ * Invoked during ompi_mpi_finalize().
+ */
+int ompi_file_finalize(void);
     
-
-
 /**
  * Check to see if an MPI_File handle is valid.
  *
@@ -202,7 +196,6 @@
             0 != (file->f_flags & OMPI_FILE_ISCLOSED));
 }
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
+END_C_DECLS
+
 #endif /* OMPI_FILE_H */
Index: ompi/runtime/ompi_cr.c
===================================================================
--- ompi/runtime/ompi_cr.c	(revision 16968)
+++ ompi/runtime/ompi_cr.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -108,10 +108,10 @@
 
     memset(&modules, 0, sizeof(mca_coll_base_module_1_1_0_t*) * NUM_COLLECTIVES);
 
-    max = ompi_pointer_array_get_size(&ompi_mpi_communicators);
+    max = opal_pointer_array_get_size(&ompi_mpi_communicators);
     for (i = 0 ; i < max ; ++i) {
         ompi_communicator_t *comm =
-            (ompi_communicator_t *)ompi_pointer_array_get_item(&ompi_mpi_communicators, i);
+            (ompi_communicator_t *)opal_pointer_array_get_item(&ompi_mpi_communicators, i);
         if (NULL == comm) continue;
 
         SIGNAL(comm, modules, highest_module, msg, ret, allgather); 
Index: ompi/mpi/c/group_f2c.c
===================================================================
--- ompi/mpi/c/group_f2c.c	(revision 16968)
+++ ompi/mpi/c/group_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -50,9 +50,9 @@
 
     if (group_index < 0 ||
         group_index >=
-        ompi_pointer_array_get_size(ompi_group_f_to_c_table)) {
+        opal_pointer_array_get_size(&ompi_group_f_to_c_table)) {
         return NULL;
     }
 
-    return (MPI_Group)ompi_pointer_array_get_item(ompi_group_f_to_c_table, group_index);
+    return (MPI_Group)opal_pointer_array_get_item(&ompi_group_f_to_c_table, group_index);
 }
Index: ompi/mpi/c/win_f2c.c
===================================================================
--- ompi/mpi/c/win_f2c.c	(revision 16968)
+++ ompi/mpi/c/win_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -48,9 +48,9 @@
        return an invalid C handle. */
 
     if ( 0 > o_index ||
-         o_index >= ompi_pointer_array_get_size(&ompi_mpi_windows)) {
+         o_index >= opal_pointer_array_get_size(&ompi_mpi_windows)) {
         return NULL;
     }
         
-    return (MPI_Win)ompi_pointer_array_get_item(&ompi_mpi_windows, o_index);
+    return (MPI_Win)opal_pointer_array_get_item(&ompi_mpi_windows, o_index);
 }
Index: ompi/mpi/c/type_f2c.c
===================================================================
--- ompi/mpi/c/type_f2c.c	(revision 16968)
+++ ompi/mpi/c/type_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -49,10 +49,10 @@
     
     if (datatype_index < 0 || 
         datatype_index >= 
-        ompi_pointer_array_get_size(ompi_datatype_f_to_c_table)) {
+        opal_pointer_array_get_size(&ompi_datatype_f_to_c_table)) {
         return NULL;
     }
 
-    return (MPI_Datatype)ompi_pointer_array_get_item(ompi_datatype_f_to_c_table, datatype_index);
+    return (MPI_Datatype)opal_pointer_array_get_item(&ompi_datatype_f_to_c_table, datatype_index);
 }
 
Index: ompi/mpi/c/comm_f2c.c
===================================================================
--- ompi/mpi/c/comm_f2c.c	(revision 16968)
+++ ompi/mpi/c/comm_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -48,9 +48,9 @@
        return an invalid C handle. */
 
     if ( 0 > o_index ||
-         o_index >= ompi_pointer_array_get_size(&ompi_mpi_communicators)) {
+         o_index >= opal_pointer_array_get_size(&ompi_mpi_communicators)) {
         return NULL;
     }
         
-    return (MPI_Comm)ompi_pointer_array_get_item(&ompi_mpi_communicators, o_index);
+    return (MPI_Comm)opal_pointer_array_get_item(&ompi_mpi_communicators, o_index);
 }
Index: ompi/mpi/c/errhandler_f2c.c
===================================================================
--- ompi/mpi/c/errhandler_f2c.c	(revision 16968)
+++ ompi/mpi/c/errhandler_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -51,10 +51,10 @@
 
     if (eh_index < 0 || 
         eh_index >= 
-        ompi_pointer_array_get_size(ompi_errhandler_f_to_c_table)) {
+        opal_pointer_array_get_size(&ompi_errhandler_f_to_c_table)) {
         return NULL;
     }
 
-    return (MPI_Errhandler)ompi_pointer_array_get_item(ompi_errhandler_f_to_c_table,
+    return (MPI_Errhandler)opal_pointer_array_get_item(&ompi_errhandler_f_to_c_table,
                                                        eh_index);
 }
Index: ompi/mpi/c/file_f2c.c
===================================================================
--- ompi/mpi/c/file_f2c.c	(revision 16968)
+++ ompi/mpi/c/file_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -50,9 +50,9 @@
 
     if (file_index < 0 ||
         file_index >= 
-        ompi_pointer_array_get_size(&ompi_file_f_to_c_table)) {
+        opal_pointer_array_get_size(&ompi_file_f_to_c_table)) {
         return NULL;
     }
 
-    return (MPI_File)ompi_pointer_array_get_item(&ompi_file_f_to_c_table, file_index);
+    return (MPI_File)opal_pointer_array_get_item(&ompi_file_f_to_c_table, file_index);
 }
Index: ompi/mpi/c/request_c2f.c
===================================================================
--- ompi/mpi/c/request_c2f.c	(revision 16968)
+++ ompi/mpi/c/request_c2f.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -61,7 +61,7 @@
 
     if (MPI_UNDEFINED == request->req_f_to_c_index) {
         request->req_f_to_c_index = 
-            ompi_pointer_array_add(&ompi_request_f_to_c_table, request);
+            opal_pointer_array_add(&ompi_request_f_to_c_table, request);
     }
 
     return OMPI_INT_2_FINT(request->req_f_to_c_index) ;
Index: ompi/mpi/c/op_f2c.c
===================================================================
--- ompi/mpi/c/op_f2c.c	(revision 16968)
+++ ompi/mpi/c/op_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -51,9 +51,9 @@
     
     if (op_index < 0 || 
         op_index >= 
-        ompi_pointer_array_get_size(ompi_op_f_to_c_table)) {
+        opal_pointer_array_get_size(ompi_op_f_to_c_table)) {
         return NULL;
     }
 
-    return (MPI_Op)ompi_pointer_array_get_item(ompi_op_f_to_c_table, op_index);
+    return (MPI_Op)opal_pointer_array_get_item(ompi_op_f_to_c_table, op_index);
 }
Index: ompi/mpi/c/info_f2c.c
===================================================================
--- ompi/mpi/c/info_f2c.c	(revision 16968)
+++ ompi/mpi/c/info_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -58,9 +58,9 @@
     
     if (info_index < 0 || 
         info_index >= 
-        ompi_pointer_array_get_size(&ompi_info_f_to_c_table)) {
+        opal_pointer_array_get_size(&ompi_info_f_to_c_table)) {
         return NULL;
     }
 
-    return (MPI_Info)ompi_pointer_array_get_item(&ompi_info_f_to_c_table, info_index);
+    return (MPI_Info)opal_pointer_array_get_item(&ompi_info_f_to_c_table, info_index);
 }
Index: ompi/mpi/c/request_f2c.c
===================================================================
--- ompi/mpi/c/request_f2c.c	(revision 16968)
+++ ompi/mpi/c/request_f2c.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -49,10 +49,10 @@
     
     if (request_index < 0 || 
         request_index >= 
-        ompi_pointer_array_get_size(&ompi_request_f_to_c_table)) {
+        opal_pointer_array_get_size(&ompi_request_f_to_c_table)) {
         return NULL;
     }
 
-    return (MPI_Request)ompi_pointer_array_get_item(&ompi_request_f_to_c_table,
+    return (MPI_Request)opal_pointer_array_get_item(&ompi_request_f_to_c_table,
                                                     request_index);
 }
Index: ompi/errhandler/errcode-internal.h
===================================================================
--- ompi/errhandler/errcode-internal.h	(revision 16968)
+++ ompi/errhandler/errcode-internal.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -25,12 +25,12 @@
 #include "mpi.h"
 #include "ompi/constants.h"
 #include "opal/class/opal_object.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 
 #define OMPI_MAX_ERROR_STRING 64
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+
+BEGIN_C_DECLS
+
 /**
  * Back-end type for MPI error codes
  */
@@ -43,7 +43,7 @@
 };
 typedef struct ompi_errcode_intern_t ompi_errcode_intern_t;
 
-OMPI_DECLSPEC extern ompi_pointer_array_t ompi_errcodes_intern;
+OMPI_DECLSPEC extern opal_pointer_array_t ompi_errcodes_intern;
 OMPI_DECLSPEC extern int ompi_errcode_intern_lastused;
 
 /** 
@@ -64,7 +64,7 @@
     /* Otherwise, it's an internal OMPI code and we need to translate
        it */
     for ( __i=0; __i<ompi_errcode_intern_lastused; __i++) {
-        __errc = (ompi_errcode_intern_t *)ompi_pointer_array_get_item(&ompi_errcodes_intern, __i);
+        __errc = (ompi_errcode_intern_t *)opal_pointer_array_get_item(&ompi_errcodes_intern, __i);
         if ( __errc->code == errcode ) {
             __ret = __errc->mpi_code;
             break;
@@ -73,30 +73,25 @@
     return __ret;
 }
 
-
-
-    /**
-     * Initialize the error codes
-     *
-     * @returns OMPI_SUCCESS Upon success
-     * @returns OMPI_ERROR Otherwise
-     *
-     * Invoked from ompi_mpi_init(); sets up all static MPI error codes,
-     */
-    int ompi_errcode_intern_init(void);
+/**
+ * Initialize the error codes
+ *
+ * @returns OMPI_SUCCESS Upon success
+ * @returns OMPI_ERROR Otherwise
+ *
+ * Invoked from ompi_mpi_init(); sets up all static MPI error codes,
+ */
+int ompi_errcode_intern_init(void);
     
-    /**
-     * Finalize the error codes.
-     *
-     * @returns OMPI_SUCCESS Always
-     *
-     * Invokes from ompi_mpi_finalize(); tears down the error code array.
-     */
-    int ompi_errcode_intern_finalize(void);
+/**
+ * Finalize the error codes.
+ *
+ * @returns OMPI_SUCCESS Always
+ *
+ * Invokes from ompi_mpi_finalize(); tears down the error code array.
+ */
+int ompi_errcode_intern_finalize(void);
         
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
+END_C_DECLS
 
-
 #endif /* OMPI_ERRCODE_INTERNAL_H */
Index: ompi/errhandler/errcode.c
===================================================================
--- ompi/errhandler/errcode.c	(revision 16968)
+++ ompi/errhandler/errcode.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -27,7 +27,7 @@
 #include "ompi/constants.h"
 
 /* Table holding all error codes */
-ompi_pointer_array_t ompi_mpi_errcodes;
+opal_pointer_array_t ompi_mpi_errcodes;
 int ompi_mpi_errcode_lastused=0;
 int ompi_mpi_errcode_lastpredefined=0;
 
@@ -92,346 +92,84 @@
 
 OBJ_CLASS_INSTANCE(ompi_mpi_errcode_t,opal_object_t,ompi_mpi_errcode_construct, ompi_mpi_errcode_destruct);
 
+#define CONSTRUCT_ERRCODE(VAR, ERRCODE, TXT )                             \
+do {                                                                      \
+    OBJ_CONSTRUCT(&(VAR), ompi_mpi_errcode_t);                            \
+    (VAR).code = (ERRCODE);                                               \
+    (VAR).cls = (ERRCODE);                                                \
+    strncpy((VAR).errstring, (TXT), MPI_MAX_ERROR_STRING);                \
+    opal_pointer_array_set_item(&ompi_mpi_errcodes, (ERRCODE), &(VAR));   \
+} while (0)
+
 int ompi_mpi_errcode_init (void)
 {
     /* Initialize the pointer array, which will hold the references to
        the error objects */
-    OBJ_CONSTRUCT(&ompi_mpi_errcodes, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&ompi_mpi_errcodes, opal_pointer_array_t);
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_mpi_errcodes, 0,
+                                                OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
 
     /* Initialize now each predefined error code and register
        it in the pointer-array. */
-    OBJ_CONSTRUCT(&ompi_success, ompi_mpi_errcode_t);
-    ompi_success.code = MPI_SUCCESS;
-    ompi_success.cls = MPI_SUCCESS;
-    strncpy(ompi_success.errstring, "MPI_SUCCESS: no errors", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_SUCCESS, &ompi_success);
+    CONSTRUCT_ERRCODE( ompi_success, MPI_SUCCESS, "MPI_SUCCESS: no errors" );
+    CONSTRUCT_ERRCODE( ompi_err_buffer, MPI_ERR_BUFFER, "MPI_ERR_BUFFER: invalid buffer pointer");
+    CONSTRUCT_ERRCODE( ompi_err_count, MPI_ERR_COUNT, "MPI_ERR_COUNT: invalid count argument" );
+    CONSTRUCT_ERRCODE( ompi_err_type, MPI_ERR_TYPE, "MPI_ERR_TYPE: invalid datatype" );
+    CONSTRUCT_ERRCODE( ompi_err_tag, MPI_ERR_TAG, "MPI_ERR_TAG: invalid tag" );
+    CONSTRUCT_ERRCODE( ompi_err_comm, MPI_ERR_COMM, "MPI_ERR_COMM: invalid communicator" );
+    CONSTRUCT_ERRCODE( ompi_err_rank, MPI_ERR_RANK, "MPI_ERR_RANK: invalid rank" );
+    CONSTRUCT_ERRCODE( ompi_err_request, MPI_ERR_REQUEST, "MPI_ERR_REQUEST: invalid request" );
+    CONSTRUCT_ERRCODE( ompi_err_root, MPI_ERR_ROOT, "MPI_ERR_ROOT: invalid root" );
+    CONSTRUCT_ERRCODE( ompi_err_group, MPI_ERR_GROUP, "MPI_ERR_GROUP: invalid group" );
+    CONSTRUCT_ERRCODE( ompi_err_op, MPI_ERR_OP, "MPI_ERR_OP: invalid reduce operation" );
+    CONSTRUCT_ERRCODE( ompi_err_topology, MPI_ERR_TOPOLOGY, "MPI_ERR_TOPOLOGY: invalid communicator topology" );
+    CONSTRUCT_ERRCODE( ompi_err_dims, MPI_ERR_DIMS, "MPI_ERR_DIMS: invalid topology dimension" );
+    CONSTRUCT_ERRCODE( ompi_err_arg, MPI_ERR_ARG, "MPI_ERR_ARG: invalid argument of some other kind" );
+    CONSTRUCT_ERRCODE( ompi_err_unknown, MPI_ERR_UNKNOWN, "MPI_ERR_UNKNOWN: unknown error" );
+    CONSTRUCT_ERRCODE( ompi_err_truncate, MPI_ERR_TRUNCATE, "MPI_ERR_TRUNCATE: message truncated" );
+    CONSTRUCT_ERRCODE( ompi_err_other, MPI_ERR_OTHER, "MPI_ERR_OTHER: known error not in list" );
+    CONSTRUCT_ERRCODE( ompi_err_intern, MPI_ERR_INTERN, "MPI_ERR_INTERN: internal error" );
+    CONSTRUCT_ERRCODE( ompi_err_in_status, MPI_ERR_IN_STATUS, "MPI_ERR_IN_STATUS: error code in status" );
+    CONSTRUCT_ERRCODE( ompi_err_pending, MPI_ERR_PENDING, "MPI_ERR_PENDING: pending request" );
+    CONSTRUCT_ERRCODE( ompi_err_access, MPI_ERR_ACCESS, "MPI_ERR_ACCESS: invalid access mode" );
+    CONSTRUCT_ERRCODE( ompi_err_amode, MPI_ERR_AMODE, "MPI_ERR_AMODE: invalid amode argument" );
+    CONSTRUCT_ERRCODE( ompi_err_assert, MPI_ERR_ASSERT, "MPI_ERR_ASSERT: invalid assert argument" );
+    CONSTRUCT_ERRCODE( ompi_err_bad_file, MPI_ERR_BAD_FILE, "MPI_ERR_BAD_FILE: bad file" );
+    CONSTRUCT_ERRCODE( ompi_err_base, MPI_ERR_BASE, "MPI_ERR_BASE: invalid base" );
+    CONSTRUCT_ERRCODE( ompi_err_conversion, MPI_ERR_CONVERSION, "MPI_ERR_CONVERSION: error in data conversion" );
+    CONSTRUCT_ERRCODE( ompi_err_disp, MPI_ERR_DISP, "MPI_ERR_DISP: invalid displacement" );
+    CONSTRUCT_ERRCODE( ompi_err_dup_datarep, MPI_ERR_DUP_DATAREP, "MPI_ERR_DUP_DATAREP: error while duplicating data representation" );
+    CONSTRUCT_ERRCODE( ompi_err_file_exists, MPI_ERR_FILE_EXISTS, "MPI_ERR_FILE_EXISTS: file exists alreay" );
+    CONSTRUCT_ERRCODE( ompi_err_file_in_use, MPI_ERR_FILE_IN_USE, "MPI_ERR_FILE_IN_USE: file already in use" );
+    CONSTRUCT_ERRCODE( ompi_err_file, MPI_ERR_FILE, "MPI_ERR_FILE: invalid file" );
+    CONSTRUCT_ERRCODE( ompi_err_info_key, MPI_ERR_INFO_KEY, "MPI_ERR_INFO_KEY: invalid key argument for info object" );
+    CONSTRUCT_ERRCODE( ompi_err_info_nokey, MPI_ERR_INFO_NOKEY, "MPI_ERR_INFO_NOKEY: unknown key for given info object" );
+    CONSTRUCT_ERRCODE( ompi_err_info_value, MPI_ERR_INFO_VALUE, "MPI_ERR_INFO_VALUE: invalid value argument for info object" );
+    CONSTRUCT_ERRCODE( ompi_err_info, MPI_ERR_INFO, "MPI_ERR_INFO: invalid info object" );
+    CONSTRUCT_ERRCODE( ompi_err_io, MPI_ERR_IO, "MPI_ERR_IO: input/output error" );
+    CONSTRUCT_ERRCODE( ompi_err_keyval, MPI_ERR_KEYVAL, "MPI_ERR_KEYVAL: invalid key value" );
+    CONSTRUCT_ERRCODE( ompi_err_locktype, MPI_ERR_LOCKTYPE, "MPI_ERR_LOCKTYPE: invalid lock" );
+    CONSTRUCT_ERRCODE( ompi_err_name, MPI_ERR_NAME, "MPI_ERR_NAME: invalid name argument" );
+    CONSTRUCT_ERRCODE( ompi_err_no_mem, MPI_ERR_NO_MEM, "MPI_ERR_NO_MEM: out of memory" );
+    CONSTRUCT_ERRCODE( ompi_err_not_same, MPI_ERR_NOT_SAME, "MPI_ERR_NOT_SAME: objects are not identical");
+    CONSTRUCT_ERRCODE( ompi_err_no_space, MPI_ERR_NO_SPACE, "MPI_ERR_NO_SPACE: no space left on device" );
+    CONSTRUCT_ERRCODE( ompi_err_no_such_file, MPI_ERR_NO_SUCH_FILE, "MPI_ERR_NO_SUCH_FILE: no such file or directory" );
+    CONSTRUCT_ERRCODE( ompi_err_port, MPI_ERR_PORT, "MPI_ERR_PORT: MPI_ERR_PORT: invalid port" );
+    CONSTRUCT_ERRCODE( ompi_err_quota, MPI_ERR_QUOTA, "MPI_ERR_QUOTA: out of quota" );
+    CONSTRUCT_ERRCODE( ompi_err_read_only, MPI_ERR_READ_ONLY, "MPI_ERR_READ_ONLY: file is read only" );
+    CONSTRUCT_ERRCODE( ompi_err_rma_conflict, MPI_ERR_RMA_CONFLICT, "MPI_ERR_RMA_CONFLICT: rma conflict during operation" );
+    CONSTRUCT_ERRCODE( ompi_err_rma_sync, MPI_ERR_RMA_SYNC, "MPI_ERR_RMA_SYNC: error while executing rma sync" );
+    CONSTRUCT_ERRCODE( ompi_err_service, MPI_ERR_SERVICE, "MPI_ERR_SERVICE: unknown service name" );
+    CONSTRUCT_ERRCODE( ompi_err_size, MPI_ERR_SIZE, "MPI_ERR_SIZE: invalid size" );
+    CONSTRUCT_ERRCODE( ompi_err_spawn, MPI_ERR_SPAWN, "MPI_ERR_SPAWN: could not spawn processes" );
+    CONSTRUCT_ERRCODE( ompi_err_unsupported_datarep, MPI_ERR_UNSUPPORTED_DATAREP, "MPI_ERR_UNSUPPORTED_DATAREP: requested data representation not supported" );
+    CONSTRUCT_ERRCODE( ompi_err_unsupported_operation, MPI_ERR_UNSUPPORTED_OPERATION, "MPI_ERR_UNSUPPORTED_OPERATION: requested operation not suppported" );
+    CONSTRUCT_ERRCODE( ompi_err_win, MPI_ERR_WIN, "MPI_ERR_WIN:invalid window" );
 
-    OBJ_CONSTRUCT(&ompi_err_buffer, ompi_mpi_errcode_t);
-    ompi_err_buffer.code = MPI_ERR_BUFFER;
-    ompi_err_buffer.cls = MPI_ERR_BUFFER;
-    strncpy(ompi_err_buffer.errstring, "MPI_ERR_BUFFER: invalid buffer pointer", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_BUFFER, &ompi_err_buffer);
-
-    OBJ_CONSTRUCT(&ompi_err_count, ompi_mpi_errcode_t);
-    ompi_err_count.code = MPI_ERR_COUNT;
-    ompi_err_count.cls = MPI_ERR_COUNT;
-    strncpy(ompi_err_count.errstring, "MPI_ERR_COUNT: invalid count argument", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_COUNT, &ompi_err_count);
-
-    OBJ_CONSTRUCT(&ompi_err_type, ompi_mpi_errcode_t);
-    ompi_err_type.code = MPI_ERR_TYPE;
-    ompi_err_type.cls = MPI_ERR_TYPE;
-    strncpy(ompi_err_type.errstring, "MPI_ERR_TYPE: invalid datatype", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_TYPE, &ompi_err_type);
-
-    OBJ_CONSTRUCT(&ompi_err_tag, ompi_mpi_errcode_t);
-    ompi_err_tag.code = MPI_ERR_TAG;
-    ompi_err_tag.cls = MPI_ERR_TAG;
-    strncpy(ompi_err_tag.errstring, "MPI_ERR_TAG: invalid tag", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_TAG, &ompi_err_tag);
-
-    OBJ_CONSTRUCT(&ompi_err_comm, ompi_mpi_errcode_t);
-    ompi_err_comm.code = MPI_ERR_COMM;
-    ompi_err_comm.cls = MPI_ERR_COMM;
-    strncpy(ompi_err_comm.errstring, "MPI_ERR_COMM: invalid communicator", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_COMM, &ompi_err_comm);
-
-    OBJ_CONSTRUCT(&ompi_err_rank, ompi_mpi_errcode_t);
-    ompi_err_rank.code = MPI_ERR_RANK;
-    ompi_err_rank.cls = MPI_ERR_RANK;
-    strncpy(ompi_err_rank.errstring, "MPI_ERR_RANK: invalid rank", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_RANK, &ompi_err_rank);
-
-    OBJ_CONSTRUCT(&ompi_err_request, ompi_mpi_errcode_t);
-    ompi_err_request.code = MPI_ERR_REQUEST;
-    ompi_err_request.cls = MPI_ERR_REQUEST;
-    strncpy(ompi_err_request.errstring, "MPI_ERR_REQUEST: invalid request", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_REQUEST, &ompi_err_request);
-
-    OBJ_CONSTRUCT(&ompi_err_root, ompi_mpi_errcode_t);
-    ompi_err_root.code = MPI_ERR_ROOT;
-    ompi_err_root.cls = MPI_ERR_ROOT;
-    strncpy(ompi_err_root.errstring, "MPI_ERR_ROOT: invalid root", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_ROOT, &ompi_err_root);
-
-    OBJ_CONSTRUCT(&ompi_err_group, ompi_mpi_errcode_t);
-    ompi_err_group.code = MPI_ERR_GROUP;
-    ompi_err_group.cls = MPI_ERR_GROUP;
-    strncpy(ompi_err_group.errstring, "MPI_ERR_GROUP: invalid group", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_GROUP, &ompi_err_group);
-
-    OBJ_CONSTRUCT(&ompi_err_op, ompi_mpi_errcode_t);
-    ompi_err_op.code = MPI_ERR_OP;
-    ompi_err_op.cls = MPI_ERR_OP;
-    strncpy(ompi_err_op.errstring, "MPI_ERR_OP: invalid reduce operation", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_OP, &ompi_err_op);
-
-    OBJ_CONSTRUCT(&ompi_err_topology, ompi_mpi_errcode_t);
-    ompi_err_topology.code = MPI_ERR_TOPOLOGY;
-    ompi_err_topology.cls = MPI_ERR_TOPOLOGY;
-    strncpy(ompi_err_topology.errstring, "MPI_ERR_TOPOLOGY: invalid communicator topology", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_TOPOLOGY, &ompi_err_topology);
-
-    OBJ_CONSTRUCT(&ompi_err_dims, ompi_mpi_errcode_t);
-    ompi_err_dims.code = MPI_ERR_DIMS;
-    ompi_err_dims.cls = MPI_ERR_DIMS;
-    strncpy(ompi_err_dims.errstring, "MPI_ERR_DIMS: invalid topology dimension", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_DIMS, &ompi_err_dims);
-
-    OBJ_CONSTRUCT(&ompi_err_arg, ompi_mpi_errcode_t);
-    ompi_err_arg.code = MPI_ERR_ARG;
-    ompi_err_arg.cls = MPI_ERR_ARG;
-    strncpy(ompi_err_arg.errstring, "MPI_ERR_ARG: invalid argument of some other kind", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_ARG, &ompi_err_arg);
-
-    OBJ_CONSTRUCT(&ompi_err_unknown, ompi_mpi_errcode_t);
-    ompi_err_unknown.code = MPI_ERR_UNKNOWN;
-    ompi_err_unknown.cls = MPI_ERR_UNKNOWN;
-    strncpy(ompi_err_unknown.errstring, "MPI_ERR_UNKNOWN: unknown error", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_UNKNOWN, &ompi_err_unknown);
-
-    OBJ_CONSTRUCT(&ompi_err_truncate, ompi_mpi_errcode_t);
-    ompi_err_truncate.code = MPI_ERR_TRUNCATE;
-    ompi_err_truncate.cls = MPI_ERR_TRUNCATE;
-    strncpy(ompi_err_truncate.errstring, "MPI_ERR_TRUNCATE: message truncated", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_TRUNCATE, &ompi_err_truncate);
-
-    OBJ_CONSTRUCT(&ompi_err_other, ompi_mpi_errcode_t);
-    ompi_err_other.code = MPI_ERR_OTHER;
-    ompi_err_other.cls = MPI_ERR_OTHER;
-    strncpy(ompi_err_other.errstring, "MPI_ERR_OTHER: known error not in list", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_OTHER, &ompi_err_other);
-
-    OBJ_CONSTRUCT(&ompi_err_intern, ompi_mpi_errcode_t);
-    ompi_err_intern.code = MPI_ERR_INTERN;
-    ompi_err_intern.cls = MPI_ERR_INTERN;
-    strncpy(ompi_err_intern.errstring, "MPI_ERR_INTERN: internal error", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_INTERN, &ompi_err_intern);
-
-    OBJ_CONSTRUCT(&ompi_err_in_status, ompi_mpi_errcode_t);
-    ompi_err_in_status.code = MPI_ERR_IN_STATUS;
-    ompi_err_in_status.cls = MPI_ERR_IN_STATUS;
-    strncpy(ompi_err_in_status.errstring, "MPI_ERR_IN_STATUS: error code in status", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_IN_STATUS, &ompi_err_in_status);
-
-    OBJ_CONSTRUCT(&ompi_err_pending, ompi_mpi_errcode_t);
-    ompi_err_pending.code = MPI_ERR_PENDING;
-    ompi_err_pending.cls = MPI_ERR_PENDING;
-    strncpy(ompi_err_pending.errstring, "MPI_ERR_PENDING: pending request", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_PENDING, &ompi_err_pending);
-
-    OBJ_CONSTRUCT(&ompi_err_access, ompi_mpi_errcode_t);
-    ompi_err_access.code = MPI_ERR_ACCESS;
-    ompi_err_access.cls = MPI_ERR_ACCESS;
-    strncpy(ompi_err_access.errstring, "MPI_ERR_ACCESS: invalid access mode", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_ACCESS, &ompi_err_access);
-
-    OBJ_CONSTRUCT(&ompi_err_amode, ompi_mpi_errcode_t);
-    ompi_err_amode.code = MPI_ERR_AMODE;
-    ompi_err_amode.cls = MPI_ERR_AMODE;
-    strncpy(ompi_err_amode.errstring, "MPI_ERR_AMODE: invalid amode argument", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_AMODE, &ompi_err_amode);
-
-    OBJ_CONSTRUCT(&ompi_err_assert, ompi_mpi_errcode_t);
-    ompi_err_assert.code = MPI_ERR_ASSERT;
-    ompi_err_assert.cls = MPI_ERR_ASSERT;
-    strncpy(ompi_err_assert.errstring, "MPI_ERR_ASSERT: invalid assert argument", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_ASSERT, &ompi_err_assert);
-
-    OBJ_CONSTRUCT(&ompi_err_bad_file, ompi_mpi_errcode_t);
-    ompi_err_bad_file.code = MPI_ERR_BAD_FILE;
-    ompi_err_bad_file.cls = MPI_ERR_BAD_FILE;
-    strncpy(ompi_err_bad_file.errstring, "MPI_ERR_BAD_FILE: bad file", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_BAD_FILE, &ompi_err_bad_file);
-
-    OBJ_CONSTRUCT(&ompi_err_base, ompi_mpi_errcode_t);
-    ompi_err_base.code = MPI_ERR_BASE;
-    ompi_err_base.cls = MPI_ERR_BASE;
-    strncpy(ompi_err_base.errstring, "MPI_ERR_BASE: invalid base", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_BASE, &ompi_err_base);
-
-    OBJ_CONSTRUCT(&ompi_err_conversion, ompi_mpi_errcode_t);
-    ompi_err_conversion.code = MPI_ERR_CONVERSION;
-    ompi_err_conversion.cls = MPI_ERR_CONVERSION;
-    strncpy(ompi_err_conversion.errstring, "MPI_ERR_CONVERSION: error in data conversion", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_CONVERSION, &ompi_err_conversion);
-
-    OBJ_CONSTRUCT(&ompi_err_disp, ompi_mpi_errcode_t);
-    ompi_err_disp.code = MPI_ERR_DISP;
-    ompi_err_disp.cls = MPI_ERR_DISP;
-    strncpy(ompi_err_disp.errstring, "MPI_ERR_DISP: invalid displacement", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_DISP, &ompi_err_disp);
-
-    OBJ_CONSTRUCT(&ompi_err_dup_datarep, ompi_mpi_errcode_t);
-    ompi_err_dup_datarep.code = MPI_ERR_DUP_DATAREP;
-    ompi_err_dup_datarep.cls = MPI_ERR_DUP_DATAREP;
-    strncpy(ompi_err_dup_datarep.errstring, 
-           "MPI_ERR_DUP_DATAREP: error while duplicating data representation", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_DUP_DATAREP, &ompi_err_dup_datarep);
-
-    OBJ_CONSTRUCT(&ompi_err_file_exists, ompi_mpi_errcode_t);
-    ompi_err_file_exists.code = MPI_ERR_FILE_EXISTS;
-    ompi_err_file_exists.cls = MPI_ERR_FILE_EXISTS;
-    strncpy(ompi_err_file_exists.errstring, "MPI_ERR_FILE_EXISTS: file exists alreay", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_FILE_EXISTS, &ompi_err_file_exists);
-
-    OBJ_CONSTRUCT(&ompi_err_file_in_use, ompi_mpi_errcode_t);
-    ompi_err_file_in_use.code = MPI_ERR_FILE_IN_USE;
-    ompi_err_file_in_use.cls = MPI_ERR_FILE_IN_USE;
-    strncpy(ompi_err_file_in_use.errstring, "MPI_ERR_FILE_IN_USE: file already in use", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_FILE_IN_USE, &ompi_err_file_in_use);
-
-    OBJ_CONSTRUCT(&ompi_err_file, ompi_mpi_errcode_t);
-    ompi_err_file.code = MPI_ERR_FILE;
-    ompi_err_file.cls = MPI_ERR_FILE;
-    strncpy(ompi_err_file.errstring, "MPI_ERR_FILE: invalid file", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_FILE, &ompi_err_file);
-
-    OBJ_CONSTRUCT(&ompi_err_info_key, ompi_mpi_errcode_t);
-    ompi_err_info_key.code = MPI_ERR_INFO_KEY;
-    ompi_err_info_key.cls = MPI_ERR_INFO_KEY;
-    strncpy(ompi_err_info_key.errstring, "MPI_ERR_INFO_KEY: invalid key argument for info object", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_INFO_KEY, &ompi_err_info_key);
-
-    OBJ_CONSTRUCT(&ompi_err_info_nokey, ompi_mpi_errcode_t);
-    ompi_err_info_nokey.code = MPI_ERR_INFO_NOKEY;
-    ompi_err_info_nokey.cls = MPI_ERR_INFO_NOKEY;
-    strncpy(ompi_err_info_nokey.errstring, "MPI_ERR_INFO_NOKEY: unknown key for given info object", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_INFO_NOKEY, &ompi_err_info_nokey);
-
-    OBJ_CONSTRUCT(&ompi_err_info_value, ompi_mpi_errcode_t);
-    ompi_err_info_value.code = MPI_ERR_INFO_VALUE;
-    ompi_err_info_value.cls = MPI_ERR_INFO_VALUE;
-    strncpy(ompi_err_info_value.errstring, 
-           "MPI_ERR_INFO_VALUE: invalid value argument for info object", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_INFO_VALUE, &ompi_err_info_value);
-
-    OBJ_CONSTRUCT(&ompi_err_info, ompi_mpi_errcode_t);
-    ompi_err_info.code = MPI_ERR_INFO;
-    ompi_err_info.cls = MPI_ERR_INFO;
-    strncpy(ompi_err_info.errstring, "MPI_ERR_INFO: invalid info object", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_INFO, &ompi_err_info);
-
-    OBJ_CONSTRUCT(&ompi_err_io, ompi_mpi_errcode_t);
-    ompi_err_io.code = MPI_ERR_IO;
-    ompi_err_io.cls = MPI_ERR_IO;
-    strncpy(ompi_err_io.errstring, "MPI_ERR_IO: input/output error", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_IO, &ompi_err_io);
-
-    OBJ_CONSTRUCT(&ompi_err_keyval, ompi_mpi_errcode_t);
-    ompi_err_keyval.code = MPI_ERR_KEYVAL;
-    ompi_err_keyval.cls = MPI_ERR_KEYVAL;
-    strncpy(ompi_err_keyval.errstring, "MPI_ERR_KEYVAL: invalid key value", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_KEYVAL, &ompi_err_keyval);
-
-    OBJ_CONSTRUCT(&ompi_err_locktype, ompi_mpi_errcode_t);
-    ompi_err_locktype.code = MPI_ERR_LOCKTYPE;
-    ompi_err_locktype.cls = MPI_ERR_LOCKTYPE;
-    strncpy(ompi_err_locktype.errstring, "MPI_ERR_LOCKTYPE: invalid lock", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_LOCKTYPE, &ompi_err_locktype);
-
-    OBJ_CONSTRUCT(&ompi_err_name, ompi_mpi_errcode_t);
-    ompi_err_name.code = MPI_ERR_NAME;
-    ompi_err_name.cls = MPI_ERR_NAME;
-    strncpy(ompi_err_name.errstring, "MPI_ERR_NAME: invalid name argument", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_NAME, &ompi_err_name);
-
-    OBJ_CONSTRUCT(&ompi_err_no_mem, ompi_mpi_errcode_t);
-    ompi_err_no_mem.code = MPI_ERR_NO_MEM;
-    ompi_err_no_mem.cls = MPI_ERR_NO_MEM;
-    strncpy(ompi_err_no_mem.errstring, "MPI_ERR_NO_MEM: out of memory", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_NO_MEM, &ompi_err_no_mem);
-
-    OBJ_CONSTRUCT(&ompi_err_not_same, ompi_mpi_errcode_t);
-    ompi_err_not_same.code = MPI_ERR_NOT_SAME;
-    ompi_err_not_same.cls = MPI_ERR_NOT_SAME;
-    strcpy(ompi_err_not_same.errstring, "MPI_ERR_NOT_SAME: objects are not identical");
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_NOT_SAME, &ompi_err_not_same);
-
-    OBJ_CONSTRUCT(&ompi_err_no_space, ompi_mpi_errcode_t);
-    ompi_err_no_space.code = MPI_ERR_NO_SPACE;
-    ompi_err_no_space.cls = MPI_ERR_NO_SPACE;
-    strncpy(ompi_err_no_space.errstring, "MPI_ERR_NO_SPACE: no space left on device", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_NO_SPACE, &ompi_err_no_space);
-
-    OBJ_CONSTRUCT(&ompi_err_no_such_file, ompi_mpi_errcode_t);
-    ompi_err_no_such_file.code = MPI_ERR_NO_SUCH_FILE;
-    ompi_err_no_such_file.cls = MPI_ERR_NO_SUCH_FILE;
-    strncpy(ompi_err_no_such_file.errstring, "MPI_ERR_NO_SUCH_FILE: no such file or directory", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_NO_SUCH_FILE, &ompi_err_no_such_file);
-
-    OBJ_CONSTRUCT(&ompi_err_port, ompi_mpi_errcode_t);
-    ompi_err_port.code = MPI_ERR_PORT;
-    ompi_err_port.cls = MPI_ERR_PORT;
-    strncpy(ompi_err_port.errstring, "MPI_ERR_PORT: MPI_ERR_PORT: invalid port", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_PORT, &ompi_err_port);
-
-    OBJ_CONSTRUCT(&ompi_err_quota, ompi_mpi_errcode_t);
-    ompi_err_quota.code = MPI_ERR_QUOTA;
-    ompi_err_quota.cls = MPI_ERR_QUOTA;
-    strncpy(ompi_err_quota.errstring, "MPI_ERR_QUOTA: out of quota", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_QUOTA, &ompi_err_quota);
-
-    OBJ_CONSTRUCT(&ompi_err_read_only, ompi_mpi_errcode_t);
-    ompi_err_read_only.code = MPI_ERR_READ_ONLY;
-    ompi_err_read_only.cls = MPI_ERR_READ_ONLY;
-    strncpy(ompi_err_read_only.errstring, "MPI_ERR_READ_ONLY: file is read only", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_READ_ONLY, &ompi_err_read_only);
-
-    OBJ_CONSTRUCT(&ompi_err_rma_conflict, ompi_mpi_errcode_t);
-    ompi_err_rma_conflict.code = MPI_ERR_RMA_CONFLICT;
-    ompi_err_rma_conflict.cls = MPI_ERR_RMA_CONFLICT;
-    strncpy(ompi_err_rma_conflict.errstring, "MPI_ERR_RMA_CONFLICT: rma conflict during operation", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_RMA_CONFLICT, &ompi_err_rma_conflict);
-
-    OBJ_CONSTRUCT(&ompi_err_rma_sync, ompi_mpi_errcode_t);
-    ompi_err_rma_sync.code = MPI_ERR_RMA_SYNC;
-    ompi_err_rma_sync.cls = MPI_ERR_RMA_SYNC;
-    strncpy(ompi_err_rma_sync.errstring, "MPI_ERR_RMA_SYNC: error while executing rma sync", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_RMA_SYNC, &ompi_err_rma_sync);
-
-    OBJ_CONSTRUCT(&ompi_err_service, ompi_mpi_errcode_t);
-    ompi_err_service.code = MPI_ERR_SERVICE;
-    ompi_err_service.cls = MPI_ERR_SERVICE;
-    strncpy(ompi_err_service.errstring, "MPI_ERR_SERVICE: unknown service name", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_SERVICE, &ompi_err_service);
-
-    OBJ_CONSTRUCT(&ompi_err_size, ompi_mpi_errcode_t);
-    ompi_err_size.code = MPI_ERR_SIZE;
-    ompi_err_size.cls = MPI_ERR_SIZE;
-    strncpy(ompi_err_size.errstring, "MPI_ERR_SIZE: invalid size", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_SIZE, &ompi_err_size);
-
-    OBJ_CONSTRUCT(&ompi_err_spawn, ompi_mpi_errcode_t);
-    ompi_err_spawn.code = MPI_ERR_SPAWN;
-    ompi_err_spawn.cls = MPI_ERR_SPAWN;
-    strncpy(ompi_err_spawn.errstring, "MPI_ERR_SPAWN: could not spawn processes", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_SPAWN, &ompi_err_spawn);
-
-    OBJ_CONSTRUCT(&ompi_err_unsupported_datarep, ompi_mpi_errcode_t);
-    ompi_err_unsupported_datarep.code = MPI_ERR_UNSUPPORTED_DATAREP;
-    ompi_err_unsupported_datarep.cls = MPI_ERR_UNSUPPORTED_DATAREP;
-    strncpy(ompi_err_unsupported_datarep.errstring, 
-           "MPI_ERR_UNSUPPORTED_DATAREP: requested data representation not supported", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_UNSUPPORTED_DATAREP, 
-                              &ompi_err_unsupported_datarep);
-
-    OBJ_CONSTRUCT(&ompi_err_unsupported_operation, ompi_mpi_errcode_t);
-    ompi_err_unsupported_operation.code = MPI_ERR_UNSUPPORTED_OPERATION;
-    ompi_err_unsupported_operation.cls = MPI_ERR_UNSUPPORTED_OPERATION;
-    strncpy(ompi_err_unsupported_operation.errstring, 
-           "MPI_ERR_UNSUPPORTED_OPERATION: requested operation not suppported", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_UNSUPPORTED_OPERATION, 
-                              &ompi_err_unsupported_operation);
-
-    OBJ_CONSTRUCT(&ompi_err_win, ompi_mpi_errcode_t);
-    ompi_err_win.code = MPI_ERR_WIN;
-    ompi_err_win.cls = MPI_ERR_WIN;
-    strncpy(ompi_err_win.errstring, "MPI_ERR_WIN:invalid window", MPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, MPI_ERR_WIN, &ompi_err_win);
-
-    ompi_mpi_errcode_lastused=MPI_ERR_WIN;
-    ompi_mpi_errcode_lastpredefined=MPI_ERR_WIN;
+    ompi_mpi_errcode_lastused = MPI_ERR_WIN;
+    ompi_mpi_errcode_lastpredefined = MPI_ERR_WIN;
     return OMPI_SUCCESS;
 }
 
@@ -445,7 +183,7 @@
          * there are some user defined error-codes, which
          * we have to free.
          */
-        errc = (ompi_mpi_errcode_t *)ompi_pointer_array_get_item(&ompi_mpi_errcodes, i);
+        errc = (ompi_mpi_errcode_t *)opal_pointer_array_get_item(&ompi_mpi_errcodes, i);
         OBJ_RELEASE (errc);
     }
 
@@ -515,7 +253,7 @@
     newerrcode = OBJ_NEW(ompi_mpi_errcode_t);
     newerrcode->code = (ompi_mpi_errcode_lastused+1);
     newerrcode->cls = errclass;
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, newerrcode->code, newerrcode);
+    opal_pointer_array_set_item(&ompi_mpi_errcodes, newerrcode->code, newerrcode);
     
     ompi_mpi_errcode_lastused++;
     return newerrcode->code;
@@ -527,7 +265,7 @@
 
     newerrcode = OBJ_NEW(ompi_mpi_errcode_t);
     newerrcode->cls = ( ompi_mpi_errcode_lastused+1);
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, newerrcode->cls, newerrcode);
+    opal_pointer_array_set_item(&ompi_mpi_errcodes, newerrcode->cls, newerrcode);
     
     ompi_mpi_errcode_lastused++;
     return newerrcode->cls;
@@ -537,7 +275,7 @@
 {
     ompi_mpi_errcode_t *errcodep;
 
-    errcodep = (ompi_mpi_errcode_t *)ompi_pointer_array_get_item(&ompi_mpi_errcodes, errnum);
+    errcodep = (ompi_mpi_errcode_t *)opal_pointer_array_get_item(&ompi_mpi_errcodes, errnum);
     if ( NULL == errcodep ) { 
         return OMPI_ERROR;
     }
@@ -560,6 +298,6 @@
 
 static void ompi_mpi_errcode_destruct(ompi_mpi_errcode_t *errcode)
 {
-    ompi_pointer_array_set_item(&ompi_mpi_errcodes, errcode->code, NULL);
+    opal_pointer_array_set_item(&ompi_mpi_errcodes, errcode->code, NULL);
     return;
 }
Index: ompi/errhandler/errhandler.c
===================================================================
--- ompi/errhandler/errhandler.c	(revision 16968)
+++ ompi/errhandler/errhandler.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -23,13 +23,13 @@
 #include "ompi/file/file.h"
 #include "ompi/errhandler/errhandler.h"
 #include "ompi/errhandler/errhandler_predefined.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 
 
 /*
  * Table for Fortran <-> C errhandler handle conversion
  */
-ompi_pointer_array_t *ompi_errhandler_f_to_c_table;
+opal_pointer_array_t ompi_errhandler_f_to_c_table;
 
 
 /*
@@ -68,8 +68,9 @@
 {
   /* initialize ompi_errhandler_f_to_c_table */
 
-  ompi_errhandler_f_to_c_table = OBJ_NEW(ompi_pointer_array_t);
-  if (NULL == ompi_errhandler_f_to_c_table){
+  OBJ_CONSTRUCT( &ompi_errhandler_f_to_c_table, opal_pointer_array_t);
+  if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_errhandler_f_to_c_table, 0,
+                                              OMPI_FORTRAN_HANDLE_MAX, 64) ) {
     return OMPI_ERROR;
   }
 
@@ -166,7 +167,7 @@
      decremented and they will not naturally get to 0 during FINALIZE.
      Hence, we RELEASE on the intrinsics until they are freed. */
   
-    OBJ_RELEASE(ompi_errhandler_f_to_c_table);
+    OBJ_DESTRUCT(&ompi_errhandler_f_to_c_table);
 
     /* All done */
 
@@ -237,7 +238,7 @@
 
   /* assign entry in fortran <-> c translation array */
 
-  ret_val = ompi_pointer_array_add(ompi_errhandler_f_to_c_table, 
+  ret_val = opal_pointer_array_add(&ompi_errhandler_f_to_c_table, 
                                    new_errhandler);
   new_errhandler->eh_f_to_c_index = ret_val;
 
@@ -260,10 +261,10 @@
   /* reset the ompi_errhandler_f_to_c_table entry - make sure that the
      entry is in the table */
 
-  if (NULL!= ompi_pointer_array_get_item(ompi_errhandler_f_to_c_table,
+  if (NULL!= opal_pointer_array_get_item(&ompi_errhandler_f_to_c_table,
                                         errhandler->eh_f_to_c_index)) {
-    ompi_pointer_array_set_item(ompi_errhandler_f_to_c_table,
-                               errhandler->eh_f_to_c_index, NULL);
+    opal_pointer_array_set_item(&ompi_errhandler_f_to_c_table,
+                                errhandler->eh_f_to_c_index, NULL);
   }
 
   /* Reset the static state if we're releasing one of the
Index: ompi/errhandler/errcode.h
===================================================================
--- ompi/errhandler/errcode.h	(revision 16968)
+++ ompi/errhandler/errcode.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -26,11 +26,9 @@
 
 #include "mpi.h"
 #include "opal/class/opal_object.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
 /**
  * Back-end type for MPI error codes. 
@@ -48,7 +46,7 @@
 };
 typedef struct ompi_mpi_errcode_t ompi_mpi_errcode_t;
 
-OMPI_DECLSPEC extern ompi_pointer_array_t ompi_mpi_errcodes;
+OMPI_DECLSPEC extern opal_pointer_array_t ompi_mpi_errcodes;
 OMPI_DECLSPEC extern int ompi_mpi_errcode_lastused;
 OMPI_DECLSPEC extern int ompi_mpi_errcode_lastpredefined;
 
@@ -72,7 +70,7 @@
 {
     ompi_mpi_errcode_t *err;
 
-    err = (ompi_mpi_errcode_t *)ompi_pointer_array_get_item(&ompi_mpi_errcodes, errcode);
+    err = (ompi_mpi_errcode_t *)opal_pointer_array_get_item(&ompi_mpi_errcodes, errcode);
     /* If we get a bogus errcode, return MPI_ERR_UNKNOWN */
     if (NULL != err) {
 	if ( err->code != MPI_UNDEFINED ) { 
@@ -100,7 +98,7 @@
 	return true;
     }
 
-    err = (ompi_mpi_errcode_t *)ompi_pointer_array_get_item(&ompi_mpi_errcodes, errnum);
+    err = (ompi_mpi_errcode_t *)opal_pointer_array_get_item(&ompi_mpi_errcodes, errnum);
     if (NULL != err) {
 	if ( MPI_UNDEFINED == err->code) { 
 	    /* Distinction between error class and error code is that for the 
@@ -120,7 +118,7 @@
 {
     ompi_mpi_errcode_t *err;
     
-    err = (ompi_mpi_errcode_t *)ompi_pointer_array_get_item(&ompi_mpi_errcodes, errnum);
+    err = (ompi_mpi_errcode_t *)opal_pointer_array_get_item(&ompi_mpi_errcodes, errnum);
     /* If we get a bogus errcode, return a string indicating that this
        truly should not happen */
     if (NULL != err) {
@@ -131,62 +129,59 @@
 }
 
 
-    /**
-     * Initialize the error codes
-     *
-     * @returns OMPI_SUCCESS Upon success
-     * @returns OMPI_ERROR Otherwise
-     *
-     * Invoked from ompi_mpi_init(); sets up all static MPI error codes,
-     */
-    int ompi_mpi_errcode_init(void);
+/**
+ * Initialize the error codes
+ *
+ * @returns OMPI_SUCCESS Upon success
+ * @returns OMPI_ERROR Otherwise
+ *
+ * Invoked from ompi_mpi_init(); sets up all static MPI error codes,
+ */
+int ompi_mpi_errcode_init(void);
     
-    /**
-     * Finalize the error codes.
-     *
-     * @returns OMPI_SUCCESS Always
-     *
-     * Invokes from ompi_mpi_finalize(); tears down the error code array.
-     */
-    int ompi_mpi_errcode_finalize(void);
+/**
+ * Finalize the error codes.
+ *
+ * @returns OMPI_SUCCESS Always
+ *
+ * Invokes from ompi_mpi_finalize(); tears down the error code array.
+ */
+int ompi_mpi_errcode_finalize(void);
     
-    /** 
-     * Add an error code
-     *
-     * @param: error class to which this new error code belongs to
-     *
-     * @returns the new error code on SUCCESS (>0)
-     * @returns OMPI_ERROR otherwise
-     * 
-     */
-    int ompi_mpi_errcode_add (int errclass);
+/** 
+ * Add an error code
+ *
+ * @param: error class to which this new error code belongs to
+ *
+ * @returns the new error code on SUCCESS (>0)
+ * @returns OMPI_ERROR otherwise
+ * 
+ */
+int ompi_mpi_errcode_add (int errclass);
 
-    /** 
-     * Add an error class
-     *
-     * @param: none
-     *
-     * @returns the new error class on SUCCESS (>0)
-     * @returns OMPI_ERROR otherwise
-     * 
-     */
-    int ompi_mpi_errclass_add (void);
+/** 
+ * Add an error class
+ *
+ * @param: none
+ *
+ * @returns the new error class on SUCCESS (>0)
+ * @returns OMPI_ERROR otherwise
+ * 
+ */
+int ompi_mpi_errclass_add (void);
 
-    /**
-     * Add an error string to an error code
-     *
-     * @param: error code for which the string is defined
-     * @param: error string to add
-     * @param: length of the string
-     *
-     * @returns OMPI_SUCCESS on success
-     * @returns OMPI_ERROR on error
-     */
-    int ompi_mpi_errnum_add_string (int errnum, char* string, int len);
+/**
+ * Add an error string to an error code
+ *
+ * @param: error code for which the string is defined
+ * @param: error string to add
+ * @param: length of the string
+ *
+ * @returns OMPI_SUCCESS on success
+ * @returns OMPI_ERROR on error
+ */
+int ompi_mpi_errnum_add_string (int errnum, char* string, int len);
     
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
+END_C_DECLS
 
-
 #endif /* OMPI_MPI_ERRCODE_H */
Index: ompi/errhandler/errhandler.h
===================================================================
--- ompi/errhandler/errhandler.h	(revision 16968)
+++ ompi/errhandler/errhandler.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -25,14 +25,13 @@
 #include "mpi.h"
 #include "opal/prefetch.h"
 #include "opal/class/opal_object.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "ompi/runtime/mpiruntime.h"
 #include "ompi/errhandler/errhandler_predefined.h"
 #include "ompi/errhandler/errcode-internal.h"
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
+
 /*
  * These must correspond to the fortran handle indices
  */
@@ -117,7 +116,7 @@
 /**
  * Table for Fortran <-> C errhandler handle conversion
  */
-OMPI_DECLSPEC extern ompi_pointer_array_t *ompi_errhandler_f_to_c_table;
+OMPI_DECLSPEC extern opal_pointer_array_t ompi_errhandler_f_to_c_table;
 
 
 /**
@@ -329,8 +328,7 @@
 
     return false;
 }
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
 
+END_C_DECLS
+
 #endif /* OMPI_ERRHANDLER_H */
Index: ompi/errhandler/errcode-internal.c
===================================================================
--- ompi/errhandler/errcode-internal.c	(revision 16968)
+++ ompi/errhandler/errcode-internal.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -25,7 +25,7 @@
 #include "ompi/errhandler/errcode-internal.h"
 
 /* Table holding all error codes */
-ompi_pointer_array_t ompi_errcodes_intern;
+opal_pointer_array_t ompi_errcodes_intern;
 int ompi_errcode_intern_lastused=0;
 
 static ompi_errcode_intern_t ompi_success_intern;
@@ -58,7 +58,11 @@
     int pos=0;
     /* Initialize the pointer array, which will hold the references to
        the error objects */
-    OBJ_CONSTRUCT(&ompi_errcodes_intern, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&ompi_errcodes_intern, opal_pointer_array_t);
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_errcodes_intern,
+                                                0, OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
 
     /* Initialize now each predefined error code and register
        it in the pointer-array. */
@@ -67,7 +71,7 @@
     ompi_success_intern.mpi_code = MPI_SUCCESS;
     ompi_success_intern.index = pos++;
     strncpy(ompi_success_intern.errstring, "OMPI_SUCCESS", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_success_intern.index,  
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_success_intern.index,  
                                 &ompi_success_intern);
 
     OBJ_CONSTRUCT(&ompi_error, ompi_errcode_intern_t);
@@ -75,7 +79,7 @@
     ompi_error.mpi_code = MPI_ERR_OTHER;
     ompi_error.index = pos++;
     strncpy(ompi_error.errstring, "OMPI_ERROR", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_error.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_error.index, 
                                 &ompi_error);
 
     OBJ_CONSTRUCT(&ompi_err_out_of_resource, ompi_errcode_intern_t);
@@ -83,7 +87,7 @@
     ompi_err_out_of_resource.mpi_code = MPI_ERR_INTERN;
     ompi_err_out_of_resource.index = pos++;
     strncpy(ompi_err_out_of_resource.errstring, "OMPI_ERR_OUT_OF_RESOURCE", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_out_of_resource.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_out_of_resource.index, 
                                 &ompi_err_out_of_resource);
 
     OBJ_CONSTRUCT(&ompi_err_temp_out_of_resource, ompi_errcode_intern_t);
@@ -91,7 +95,7 @@
     ompi_err_temp_out_of_resource.mpi_code = MPI_ERR_INTERN;
     ompi_err_temp_out_of_resource.index = pos++;
     strncpy(ompi_err_temp_out_of_resource.errstring, "MPI_ERR_TEMP_OUT_OF_RESOURCE", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_temp_out_of_resource.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_temp_out_of_resource.index, 
                                 &ompi_err_temp_out_of_resource);
 
     OBJ_CONSTRUCT(&ompi_err_resource_busy, ompi_errcode_intern_t);
@@ -99,7 +103,7 @@
     ompi_err_resource_busy.mpi_code = MPI_ERR_INTERN;
     ompi_err_resource_busy.index = pos++;
     strncpy(ompi_err_resource_busy.errstring, "OMPI_ERR_RESOURCE_BUSY", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_resource_busy.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_resource_busy.index, 
                                 &ompi_err_resource_busy);
 
     OBJ_CONSTRUCT(&ompi_err_bad_param, ompi_errcode_intern_t);
@@ -107,7 +111,7 @@
     ompi_err_bad_param.mpi_code = MPI_ERR_ARG;
     ompi_err_bad_param.index = pos++;
     strncpy(ompi_err_bad_param.errstring, "OMPI_ERR_BAD_PARAM", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_bad_param.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_bad_param.index, 
                                 &ompi_err_bad_param);
 
     OBJ_CONSTRUCT(&ompi_err_recv_less_than_posted, ompi_errcode_intern_t);
@@ -115,7 +119,7 @@
     ompi_err_recv_less_than_posted.mpi_code = MPI_SUCCESS;
     ompi_err_recv_less_than_posted.index = pos++;
     strncpy(ompi_err_recv_less_than_posted.errstring, "OMPI_ERR_RECV_LESS_THAN_POSTED", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_recv_less_than_posted.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_recv_less_than_posted.index, 
                                 &ompi_err_recv_less_than_posted);
 
     OBJ_CONSTRUCT(&ompi_err_recv_more_than_posted, ompi_errcode_intern_t);
@@ -123,7 +127,7 @@
     ompi_err_recv_more_than_posted.mpi_code = MPI_ERR_TRUNCATE;
     ompi_err_recv_more_than_posted.index = pos++;
     strncpy(ompi_err_recv_more_than_posted.errstring, "OMPI_ERR_RECV_MORE_THAN_POSTED", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_recv_more_than_posted.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_recv_more_than_posted.index, 
                                 &ompi_err_recv_more_than_posted);
 
     OBJ_CONSTRUCT(&ompi_err_no_match_yet, ompi_errcode_intern_t);
@@ -131,7 +135,7 @@
     ompi_err_no_match_yet.mpi_code = MPI_ERR_PENDING;
     ompi_err_no_match_yet.index = pos++;
     strncpy(ompi_err_no_match_yet.errstring, "OMPI_ERR_NO_MATCH_YET", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_no_match_yet.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_no_match_yet.index, 
                                 &ompi_err_no_match_yet);
 
     OBJ_CONSTRUCT(&ompi_err_fatal, ompi_errcode_intern_t);
@@ -139,7 +143,7 @@
     ompi_err_fatal.mpi_code = MPI_ERR_INTERN;
     ompi_err_fatal.index = pos++;
     strncpy(ompi_err_fatal.errstring, "OMPI_ERR_FATAL", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_fatal.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_fatal.index, 
                                 &ompi_err_fatal);
 
     OBJ_CONSTRUCT(&ompi_err_not_implemented, ompi_errcode_intern_t);
@@ -147,7 +151,7 @@
     ompi_err_not_implemented.mpi_code = MPI_ERR_INTERN;
     ompi_err_not_implemented.index = pos++;
     strncpy(ompi_err_not_implemented.errstring, "OMPI_ERR_NOT_IMPLEMENTED", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_not_implemented.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_not_implemented.index, 
                                 &ompi_err_not_implemented);
 
     OBJ_CONSTRUCT(&ompi_err_not_supported, ompi_errcode_intern_t);
@@ -155,7 +159,7 @@
     ompi_err_not_supported.mpi_code = MPI_ERR_INTERN;
     ompi_err_not_supported.index = pos++;
     strncpy(ompi_err_not_supported.errstring, "OMPI_ERR_NOT_SUPPORTED", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_not_supported.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_not_supported.index, 
                                 &ompi_err_not_supported);
 
     OBJ_CONSTRUCT(&ompi_err_interupted, ompi_errcode_intern_t);
@@ -163,7 +167,7 @@
     ompi_err_interupted.mpi_code = MPI_ERR_INTERN;
     ompi_err_interupted.index = pos++;
     strncpy(ompi_err_interupted.errstring, "OMPI_ERR_INTERUPTED", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_interupted.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_interupted.index, 
                                 &ompi_err_interupted);
 
     OBJ_CONSTRUCT(&ompi_err_would_block, ompi_errcode_intern_t);
@@ -171,7 +175,7 @@
     ompi_err_would_block.mpi_code = MPI_ERR_INTERN;
     ompi_err_would_block.index = pos++;
     strncpy(ompi_err_would_block.errstring, "OMPI_ERR_WOULD_BLOCK", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_would_block.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_would_block.index, 
                                 &ompi_err_would_block);
 
     OBJ_CONSTRUCT(&ompi_err_in_errno, ompi_errcode_intern_t);
@@ -179,7 +183,7 @@
     ompi_err_in_errno.mpi_code = MPI_ERR_INTERN;
     ompi_err_in_errno.index = pos++;
     strncpy(ompi_err_in_errno.errstring, "OMPI_ERR_IN_ERRNO", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_in_errno.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_in_errno.index, 
                                 &ompi_err_in_errno);
 
     OBJ_CONSTRUCT(&ompi_err_unreach, ompi_errcode_intern_t);
@@ -187,7 +191,7 @@
     ompi_err_unreach.mpi_code = MPI_ERR_INTERN;
     ompi_err_unreach.index = pos++;
     strncpy(ompi_err_unreach.errstring, "OMPI_ERR_UNREACH", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_unreach.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_unreach.index, 
                                 &ompi_err_unreach);
 
     OBJ_CONSTRUCT(&ompi_err_not_found, ompi_errcode_intern_t);
@@ -195,7 +199,7 @@
     ompi_err_not_found.mpi_code = MPI_ERR_INTERN;
     ompi_err_not_found.index = pos++;
     strncpy(ompi_err_not_found.errstring, "OMPI_ERR_NOT_FOUND", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_not_found.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_not_found.index, 
                                 &ompi_err_not_found);
 
     OBJ_CONSTRUCT(&ompi_err_buffer, ompi_errcode_intern_t);
@@ -203,7 +207,7 @@
     ompi_err_buffer.mpi_code = MPI_ERR_BUFFER;
     ompi_err_buffer.index = pos++;
     strncpy(ompi_err_buffer.errstring, "OMPI_ERR_BUFFER", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_buffer.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_buffer.index, 
                                 &ompi_err_buffer);
 
     OBJ_CONSTRUCT(&ompi_err_request, ompi_errcode_intern_t);
@@ -211,7 +215,7 @@
     ompi_err_request.mpi_code = MPI_ERR_REQUEST;
     ompi_err_request.index = pos++;
     strncpy(ompi_err_request.errstring, "OMPI_ERR_REQUEST", OMPI_MAX_ERROR_STRING);
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_request.index, 
+    opal_pointer_array_set_item(&ompi_errcodes_intern, ompi_err_request.index, 
                                 &ompi_err_request);
 
     ompi_errcode_intern_lastused=pos;
@@ -256,6 +260,6 @@
 
 static void ompi_errcode_intern_destruct(ompi_errcode_intern_t *errcode)
 {
-    ompi_pointer_array_set_item(&ompi_errcodes_intern, errcode->index, NULL);
+    opal_pointer_array_set_item(&ompi_errcodes_intern, errcode->index, NULL);
     return;
 }
Index: ompi/request/request.c
===================================================================
--- ompi/request/request.c	(revision 16968)
+++ ompi/request/request.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2007 High Performance Computing Center Stuttgart, 
@@ -24,7 +24,7 @@
 #include "ompi/request/request_default.h"
 #include "ompi/constants.h"
 
-ompi_pointer_array_t             ompi_request_f_to_c_table;
+opal_pointer_array_t             ompi_request_f_to_c_table;
 size_t                           ompi_request_waiting = 0;
 size_t                           ompi_request_completed = 0;
 opal_mutex_t                     ompi_request_lock;
@@ -46,8 +46,8 @@
 static void ompi_request_construct(ompi_request_t* req)
 {
     OMPI_REQUEST_INIT(req, false);
-    req->req_free = NULL;
-    req->req_cancel = NULL;
+    req->req_free         = NULL;
+    req->req_cancel       = NULL;
     req->req_f_to_c_index = MPI_UNDEFINED;
     req->req_mpi_object.comm = (struct ompi_communicator_t*) NULL;
 }
@@ -93,11 +93,15 @@
 
 int ompi_request_init(void)
 {
-    OBJ_CONSTRUCT(&ompi_request_f_to_c_table, ompi_pointer_array_t);
     OBJ_CONSTRUCT(&ompi_request_lock, opal_mutex_t);
     OBJ_CONSTRUCT(&ompi_request_cond, opal_condition_t);
 
     OBJ_CONSTRUCT(&ompi_request_null, ompi_request_t);
+    OBJ_CONSTRUCT(&ompi_request_f_to_c_table, opal_pointer_array_t);
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_request_f_to_c_table,
+                                                0, OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
     ompi_request_null.req_type = OMPI_REQUEST_NULL;
     ompi_request_null.req_status.MPI_SOURCE = MPI_PROC_NULL;
     ompi_request_null.req_status.MPI_TAG = MPI_ANY_TAG;
@@ -109,7 +113,7 @@
     ompi_request_null.req_state = OMPI_REQUEST_INACTIVE;
     ompi_request_null.req_persistent = false;
     ompi_request_null.req_f_to_c_index =
-        ompi_pointer_array_add(&ompi_request_f_to_c_table, &ompi_request_null);
+        opal_pointer_array_add(&ompi_request_f_to_c_table, &ompi_request_null);
     ompi_request_null.req_free = ompi_request_null_free;
     ompi_request_null.req_cancel = ompi_request_null_cancel;
     ompi_request_null.req_mpi_object.comm = &ompi_mpi_comm_world;
@@ -141,7 +145,7 @@
     ompi_request_empty.req_state = OMPI_REQUEST_ACTIVE;
     ompi_request_empty.req_persistent = false;
     ompi_request_empty.req_f_to_c_index =
-        ompi_pointer_array_add(&ompi_request_f_to_c_table, &ompi_request_empty);
+        opal_pointer_array_add(&ompi_request_f_to_c_table, &ompi_request_empty);
     ompi_request_empty.req_free = ompi_request_empty_free;
     ompi_request_empty.req_cancel = ompi_request_null_cancel;
     ompi_request_empty.req_mpi_object.comm = &ompi_mpi_comm_world;
Index: ompi/request/request.h
===================================================================
--- ompi/request/request.h	(revision 16968)
+++ ompi/request/request.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -27,7 +27,7 @@
 
 #include "mpi.h"
 #include "ompi/class/ompi_free_list.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "opal/threads/condition.h"
 
 BEGIN_C_DECLS
@@ -105,16 +105,16 @@
  * Main top-level request struct definition 
  */
 struct ompi_request_t {
-    ompi_free_list_item_t super;               /**< Base type */
-    ompi_request_type_t req_type;              /**< Enum indicating the type of the request */
-    ompi_status_public_t req_status;           /**< Completion status */
-    volatile bool req_complete;                /**< Flag indicating wether request has completed */
-    volatile ompi_request_state_t req_state;   /**< enum indicate state of the request */
-    bool req_persistent;                       /**< flag indicating if the this is a persistent request */
-    int req_f_to_c_index;                      /**< Index in Fortran <-> C translation array */
-    ompi_request_free_fn_t req_free;           /**< Called by free */
-    ompi_request_cancel_fn_t req_cancel;       /**< Optional function to cancel the request */
-    ompi_mpi_object_t req_mpi_object;          /**< Pointer to MPI object that created this request */
+    ompi_free_list_item_t super;                /**< Base type */
+    ompi_request_type_t req_type;               /**< Enum indicating the type of the request */
+    ompi_status_public_t req_status;            /**< Completion status */
+    volatile bool req_complete;                 /**< Flag indicating wether request has completed */
+    volatile ompi_request_state_t req_state;    /**< enum indicate state of the request */
+    bool req_persistent;                        /**< flag indicating if the this is a persistent request */
+    int req_f_to_c_index;                       /**< Index in Fortran <-> C translation array */
+    ompi_request_free_fn_t req_free;            /**< Called by free */
+    ompi_request_cancel_fn_t req_cancel;        /**< Optional function to cancel the request */
+    ompi_mpi_object_t req_mpi_object;           /**< Pointer to MPI object that created this request */
 };
 
 /**
@@ -155,7 +155,7 @@
 do {                                                                    \
     (request)->req_state = OMPI_REQUEST_INVALID;                        \
     if (MPI_UNDEFINED != (request)->req_f_to_c_index) {                 \
-        ompi_pointer_array_set_item(&ompi_request_f_to_c_table,         \
+        opal_pointer_array_set_item(&ompi_request_f_to_c_table,         \
                                     (request)->req_f_to_c_index, NULL); \
         (request)->req_f_to_c_index = MPI_UNDEFINED;                    \
     }                                                                   \
@@ -297,7 +297,7 @@
 /**
  * Globals used for tracking requests and request completion.
  */
-OMPI_DECLSPEC extern ompi_pointer_array_t  ompi_request_f_to_c_table;
+OMPI_DECLSPEC extern opal_pointer_array_t  ompi_request_f_to_c_table;
 OMPI_DECLSPEC extern size_t                ompi_request_waiting;
 OMPI_DECLSPEC extern size_t                ompi_request_completed;
 OMPI_DECLSPEC extern int32_t               ompi_request_poll;
Index: ompi/info/info.h
===================================================================
--- ompi/info/info.h	(revision 16968)
+++ ompi/info/info.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -24,7 +24,7 @@
 #include "mpi.h"
 #include "opal/util/strncpy.h"
 #include "opal/class/opal_list.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "opal/threads/mutex.h"
 
 
@@ -69,183 +69,179 @@
  */
 typedef struct ompi_info_entry_t ompi_info_entry_t;
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
-  /**
-   * Table for Fortran <-> C translation table
-   */ 
-  extern ompi_pointer_array_t ompi_info_f_to_c_table;
+BEGIN_C_DECLS
 
-  /**
-   * Global instance for MPI_INFO_NULL
-   */
-  OMPI_DECLSPEC extern ompi_info_t ompi_mpi_info_null;
+/**
+ * Table for Fortran <-> C translation table
+ */ 
+extern opal_pointer_array_t ompi_info_f_to_c_table;
 
-  /**
-   * \internal
-   * Some declarations needed to use OBJ_NEW and OBJ_DESTRUCT macros
-   */
-  OMPI_DECLSPEC OBJ_CLASS_DECLARATION(ompi_info_t);
+/**
+ * Global instance for MPI_INFO_NULL
+ */
+OMPI_DECLSPEC extern ompi_info_t ompi_mpi_info_null;
 
-  /**
-   * \internal
-   * Some declarations needed to use OBJ_NEW and OBJ_DESTRUCT macros
-   */
-  OMPI_DECLSPEC OBJ_CLASS_DECLARATION(ompi_info_entry_t);
+/**
+ * \internal
+ * Some declarations needed to use OBJ_NEW and OBJ_DESTRUCT macros
+ */
+OMPI_DECLSPEC OBJ_CLASS_DECLARATION(ompi_info_t);
 
-  /**
-   * This function is invoked during ompi_mpi_init() and sets up
-   * MPI_Info handling.
-   */
-  int ompi_info_init(void);
+/**
+ * \internal
+ * Some declarations needed to use OBJ_NEW and OBJ_DESTRUCT macros
+ */
+OMPI_DECLSPEC OBJ_CLASS_DECLARATION(ompi_info_entry_t);
 
-  /**
-   * This functions is called during ompi_mpi_finalize() and shuts
-   * down MPI_Info handling.
-   */
-  int ompi_info_finalize(void);
+/**
+ * This function is invoked during ompi_mpi_init() and sets up
+ * MPI_Info handling.
+ */
+int ompi_info_init(void);
 
-  /**
-   *   ompi_info_dup - Duplicate an 'MPI_Info' object
-   *
-   *   @param info source info object (handle)
-   *   @param newinfo pointer to the new info object (handle)
-   *
-   *   @retval MPI_SUCCESS upon success
-   *   @retval MPI_ERR_NO_MEM if out of memory
-   *
-   *   Not only will the (key, value) pairs be duplicated, the order
-   *   of keys will be the same in 'newinfo' as it is in 'info'.  When
-   *   an info object is no longer being used, it should be freed with
-   *   'MPI_Info_free'.
-   */
-  int ompi_info_dup (ompi_info_t *info, ompi_info_t **newinfo);
+/**
+ * This functions is called during ompi_mpi_finalize() and shuts
+ * down MPI_Info handling.
+ */
+int ompi_info_finalize(void);
 
-  /*
-   * Set a new key,value pair on info.
-   *
-   * @param info pointer to ompi_info_t object
-   * @param key pointer to the new key object
-   * @param value pointer to the new value object
-   *
-   * @retval MPI_SUCCESS upon success
-   * @retval MPI_ERR_NO_MEM if out of memory
-   */
-  int ompi_info_set (ompi_info_t *info, char *key, char *value);
+/**
+ *   ompi_info_dup - Duplicate an 'MPI_Info' object
+ *
+ *   @param info source info object (handle)
+ *   @param newinfo pointer to the new info object (handle)
+ *
+ *   @retval MPI_SUCCESS upon success
+ *   @retval MPI_ERR_NO_MEM if out of memory
+ *
+ *   Not only will the (key, value) pairs be duplicated, the order
+ *   of keys will be the same in 'newinfo' as it is in 'info'.  When
+ *   an info object is no longer being used, it should be freed with
+ *   'MPI_Info_free'.
+ */
+int ompi_info_dup (ompi_info_t *info, ompi_info_t **newinfo);
 
-  /**
-   * ompi_info_free - Free an 'MPI_Info' object.
-   *
-   *   @param info pointer to info (ompi_info_t *) object to be freed (handle)
-   *
-   *   @retval MPI_SUCCESS
-   *   @retval MPI_ERR_ARG
-   *
-   *   Upon successful completion, 'info' will be set to
-   *   'MPI_INFO_NULL'.  Free the info handle and all of its keys and
-   *   values.
-   */
-  int ompi_info_free (ompi_info_t **info);
+/*
+ * Set a new key,value pair on info.
+ *
+ * @param info pointer to ompi_info_t object
+ * @param key pointer to the new key object
+ * @param value pointer to the new value object
+ *
+ * @retval MPI_SUCCESS upon success
+ * @retval MPI_ERR_NO_MEM if out of memory
+ */
+int ompi_info_set (ompi_info_t *info, char *key, char *value);
 
-  /**
-   *   Get a (key, value) pair from an 'MPI_Info' object
-   *
-   *   @param info Pointer to ompi_info_t object
-   *   @param key null-terminated character string of the index key
-   *   @param valuelen maximum length of 'value' (integer)
-   *   @param value null-terminated character string of the value
-   *   @param flag true (1) if 'key' defined on 'info', false (0) if not
-   *               (logical)
-   *
-   *   @retval MPI_SUCCESS
-   *
-   *   In C and C++, 'valuelen' should be one less than the allocated
-   *   space to allow for for the null terminator.
-   */
-  int ompi_info_get (ompi_info_t *info, char *key, int valuelen,
-                     char *value, int *flag);
+/**
+ * ompi_info_free - Free an 'MPI_Info' object.
+ *
+ *   @param info pointer to info (ompi_info_t *) object to be freed (handle)
+ *
+ *   @retval MPI_SUCCESS
+ *   @retval MPI_ERR_ARG
+ *
+ *   Upon successful completion, 'info' will be set to
+ *   'MPI_INFO_NULL'.  Free the info handle and all of its keys and
+ *   values.
+ */
+int ompi_info_free (ompi_info_t **info);
 
-  /**
-   * Delete a (key,value) pair from "info"
-   *
-   * @param info ompi_info_t pointer on which we need to operate
-   * @param key The key portion of the (key,value) pair that
-   *            needs to be deleted
-   *
-   * @retval MPI_SUCCESS
-   * @retval MPI_ERR_NOKEY
-   */
-  int ompi_info_delete (ompi_info_t *info, char *key);
+/**
+ *   Get a (key, value) pair from an 'MPI_Info' object
+ *
+ *   @param info Pointer to ompi_info_t object
+ *   @param key null-terminated character string of the index key
+ *   @param valuelen maximum length of 'value' (integer)
+ *   @param value null-terminated character string of the value
+ *   @param flag true (1) if 'key' defined on 'info', false (0) if not
+ *               (logical)
+ *
+ *   @retval MPI_SUCCESS
+ *
+ *   In C and C++, 'valuelen' should be one less than the allocated
+ *   space to allow for for the null terminator.
+ */
+int ompi_info_get (ompi_info_t *info, char *key, int valuelen,
+                   char *value, int *flag);
 
-  /**
-   *   @param info - ompi_info_t pointer object (handle)
-   *   @param key - null-terminated character string of the index key
-   *   @param valuelen - length of the value associated with 'key' (integer)
-   *   @param flag - true (1) if 'key' defined on 'info', false (0) if not
-   *   (logical)
-   *
-   *   @retval MPI_SUCCESS
-   *   @retval MPI_ERR_ARG
-   *   @retval MPI_ERR_INFO_KEY
-   *
-   *   The length returned in C and C++ does not include the end-of-string
-   *   character.  If the 'key' is not found on 'info', 'valuelen' is left
-   *   alone.
-   */
-  OMPI_DECLSPEC int ompi_info_get_valuelen (ompi_info_t *info, char *key, int *valuelen,
+/**
+ * Delete a (key,value) pair from "info"
+ *
+ * @param info ompi_info_t pointer on which we need to operate
+ * @param key The key portion of the (key,value) pair that
+ *            needs to be deleted
+ *
+ * @retval MPI_SUCCESS
+ * @retval MPI_ERR_NOKEY
+ */
+int ompi_info_delete (ompi_info_t *info, char *key);
+
+/**
+ *   @param info - ompi_info_t pointer object (handle)
+ *   @param key - null-terminated character string of the index key
+ *   @param valuelen - length of the value associated with 'key' (integer)
+ *   @param flag - true (1) if 'key' defined on 'info', false (0) if not
+ *   (logical)
+ *
+ *   @retval MPI_SUCCESS
+ *   @retval MPI_ERR_ARG
+ *   @retval MPI_ERR_INFO_KEY
+ *
+ *   The length returned in C and C++ does not include the end-of-string
+ *   character.  If the 'key' is not found on 'info', 'valuelen' is left
+ *   alone.
+ */
+OMPI_DECLSPEC int ompi_info_get_valuelen (ompi_info_t *info, char *key, int *valuelen,
                               int *flag);
 
-  /**
-   *   ompi_info_get_nthkey - Get a key indexed by integer from an 'MPI_Info' o
-   *
-   *   @param info Pointer to ompi_info_t object
-   *   @param n index of key to retrieve (integer)
-   *   @param key character string of at least 'MPI_MAX_INFO_KEY' characters
-   *
-   *   @retval MPI_SUCCESS
-   *   @retval MPI_ERR_ARG
-   */
-  int ompi_info_get_nthkey (ompi_info_t *info, int n, char *key);
+/**
+ *   ompi_info_get_nthkey - Get a key indexed by integer from an 'MPI_Info' o
+ *
+ *   @param info Pointer to ompi_info_t object
+ *   @param n index of key to retrieve (integer)
+ *   @param key character string of at least 'MPI_MAX_INFO_KEY' characters
+ *
+ *   @retval MPI_SUCCESS
+ *   @retval MPI_ERR_ARG
+ */
+int ompi_info_get_nthkey (ompi_info_t *info, int n, char *key);
 
-  int ompi_info_value_to_int(char *value, int *interp);
+int ompi_info_value_to_int(char *value, int *interp);
 
-  /**
-   * Convert value string to boolean
-   *
-   * Convert value string \c value into a boolean, using the
-   * interpretation rules specified in MPI-2 Section 4.10.  The
-   * strings "true", "false", and integer numbers can be converted
-   * into booleans.  All others will return \c OMPI_ERR_BAD_PARAM
-   *
-   * @param value Value string for info key to interpret
-   * @param interp returned interpretation of the value key
-   *
-   * @retval OMPI_SUCCESS string was successfully interpreted
-   * @retval OMPI_ERR_BAD_PARAM string was not able to be interpreted
-   */
-  int ompi_info_value_to_bool(char *value, bool *interp);
+/**
+ * Convert value string to boolean
+ *
+ * Convert value string \c value into a boolean, using the
+ * interpretation rules specified in MPI-2 Section 4.10.  The
+ * strings "true", "false", and integer numbers can be converted
+ * into booleans.  All others will return \c OMPI_ERR_BAD_PARAM
+ *
+ * @param value Value string for info key to interpret
+ * @param interp returned interpretation of the value key
+ *
+ * @retval OMPI_SUCCESS string was successfully interpreted
+ * @retval OMPI_ERR_BAD_PARAM string was not able to be interpreted
+ */
+int ompi_info_value_to_bool(char *value, bool *interp);
 
-  /**
-   * Convert value string to integer
-   *
-   * Convert value string \c value into a integer, using the
-   * interpretation rules specified in MPI-2 Section 4.10.  
-   * All others will return \c OMPI_ERR_BAD_PARAM
-   *
-   * @param value Value string for info key to interpret
-   * @param interp returned interpretation of the value key
-   *
-   * @retval OMPI_SUCCESS string was successfully interpreted
-   * @retval OMPI_ERR_BAD_PARAM string was not able to be interpreted
-   */
-  int ompi_info_value_to_bool(char *value, bool *interp);
+/**
+ * Convert value string to integer
+ *
+ * Convert value string \c value into a integer, using the
+ * interpretation rules specified in MPI-2 Section 4.10.  
+ * All others will return \c OMPI_ERR_BAD_PARAM
+ *
+ * @param value Value string for info key to interpret
+ * @param interp returned interpretation of the value key
+ *
+ * @retval OMPI_SUCCESS string was successfully interpreted
+ * @retval OMPI_ERR_BAD_PARAM string was not able to be interpreted
+ */
+int ompi_info_value_to_bool(char *value, bool *interp);
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
+END_C_DECLS
 
-
 /**
  * Return whether this info has been freed already or not.
  *
@@ -281,5 +277,4 @@
     return MPI_SUCCESS;
 }
 
-
 #endif /* OMPI_INFO_H */
Index: ompi/info/info.c
===================================================================
--- ompi/info/info.c	(revision 16968)
+++ ompi/info/info.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -68,9 +68,8 @@
 /*
  * The global fortran <-> C translation table
  */
-ompi_pointer_array_t ompi_info_f_to_c_table;
+opal_pointer_array_t ompi_info_f_to_c_table;
 
-
 /*
  * This function is called during ompi_init and initializes the
  * fortran to C translation table.
@@ -79,7 +78,11 @@
 {
     /* initialize table */
 
-    OBJ_CONSTRUCT(&ompi_info_f_to_c_table, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&ompi_info_f_to_c_table, opal_pointer_array_t);
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_info_f_to_c_table, 0,
+                                                OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
 
     /* Create MPI_INFO_NULL */
 
@@ -303,14 +306,14 @@
        don't want to call OBJ_RELEASE on it. */
     
     OBJ_DESTRUCT(&ompi_mpi_info_null);
-    ompi_pointer_array_set_item(&ompi_info_f_to_c_table, 0, NULL);
+    opal_pointer_array_set_item(&ompi_info_f_to_c_table, 0, NULL);
     
     /* Go through the f2c table and see if anything is left.  Free them
        all. */
     
-    max = ompi_pointer_array_get_size(&ompi_info_f_to_c_table);
+    max = opal_pointer_array_get_size(&ompi_info_f_to_c_table);
     for (i = 0; i < max; ++i) {
-        info = (ompi_info_t *)ompi_pointer_array_get_item(&ompi_info_f_to_c_table, i);
+        info = (ompi_info_t *)opal_pointer_array_get_item(&ompi_info_f_to_c_table, i);
         
         /* If the info was freed but still exists because the user
            told us to never free handles, then do an OBJ_RELEASE it
@@ -319,7 +322,7 @@
         
         if (NULL != info && ompi_debug_no_free_handles && info->i_freed) {
             OBJ_RELEASE(info);
-            info = (ompi_info_t *)ompi_pointer_array_get_item(&ompi_info_f_to_c_table, i);
+            info = (ompi_info_t *)opal_pointer_array_get_item(&ompi_info_f_to_c_table, i);
         } 
         
         /* If it still exists here and was never freed, then it's an
@@ -369,7 +372,7 @@
  */
 static void info_constructor(ompi_info_t *info) 
 {
-    info->i_f_to_c_index = ompi_pointer_array_add(&ompi_info_f_to_c_table, 
+    info->i_f_to_c_index = opal_pointer_array_add(&ompi_info_f_to_c_table, 
                                                   info);
     info->i_lock = OBJ_NEW(opal_mutex_t);
     info->i_freed = false;
@@ -406,9 +409,9 @@
        entry is in the table */
     
     if (MPI_UNDEFINED != info->i_f_to_c_index &&
-        NULL != ompi_pointer_array_get_item(&ompi_info_f_to_c_table, 
+        NULL != opal_pointer_array_get_item(&ompi_info_f_to_c_table, 
                                             info->i_f_to_c_index)){
-        ompi_pointer_array_set_item(&ompi_info_f_to_c_table, 
+        opal_pointer_array_set_item(&ompi_info_f_to_c_table, 
                                     info->i_f_to_c_index, NULL);
     }
 
Index: ompi/group/group_init.c
===================================================================
--- ompi/group/group_init.c	(revision 16968)
+++ ompi/group/group_init.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -35,7 +35,7 @@
 /*
  * Table for Fortran <-> C group handle conversion
  */
-ompi_pointer_array_t *ompi_group_f_to_c_table;
+opal_pointer_array_t ompi_group_f_to_c_table;
 
 /*
  * Predefined group objects
@@ -243,7 +243,7 @@
        either). */
 
     /* assign entry in fortran <-> c translation array */
-    ret_val = ompi_pointer_array_add(ompi_group_f_to_c_table, new_group);
+    ret_val = opal_pointer_array_add(&ompi_group_f_to_c_table, new_group);
     new_group->grp_f_to_c_index = ret_val;
     new_group->grp_flags = 0;
 
@@ -289,9 +289,9 @@
 
     /* reset the ompi_group_f_to_c_table entry - make sure that the
      * entry is in the table */
-    if (NULL != ompi_pointer_array_get_item(ompi_group_f_to_c_table,
+    if (NULL != opal_pointer_array_get_item(&ompi_group_f_to_c_table,
                                            group->grp_f_to_c_index)) {
-        ompi_pointer_array_set_item(ompi_group_f_to_c_table,
+        opal_pointer_array_set_item(&ompi_group_f_to_c_table,
                                    group->grp_f_to_c_index, NULL);
     }
 
@@ -306,7 +306,11 @@
 int ompi_group_init(void)
 {
     /* initialize ompi_group_f_to_c_table */
-    ompi_group_f_to_c_table = OBJ_NEW(ompi_pointer_array_t);
+    OBJ_CONSTRUCT( &ompi_group_f_to_c_table, opal_pointer_array_t);
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_group_f_to_c_table, 0,
+                                                OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
     
     /* add MPI_GROUP_NULL to table */
     OBJ_CONSTRUCT(&ompi_mpi_group_null, ompi_group_t);
@@ -339,7 +343,7 @@
     ompi_mpi_group_null.grp_flags = 0;
     OBJ_DESTRUCT(&ompi_mpi_group_empty);
 
-    OBJ_RELEASE(ompi_group_f_to_c_table);
+    OBJ_DESTRUCT(&ompi_group_f_to_c_table);
     
     return OMPI_SUCCESS;
 }
Index: ompi/group/group.h
===================================================================
--- ompi/group/group.h	(revision 16968)
+++ ompi/group/group.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -29,7 +29,7 @@
 
 #include "opal/util/output.h"
 #include "mpi.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #if defined(c_plusplus) || defined(__cplusplus)
 extern "C" {
 #endif
@@ -120,7 +120,7 @@
 /**
  * Table for Fortran <-> C group handle conversion
  */
-OMPI_DECLSPEC extern struct ompi_pointer_array_t *ompi_group_f_to_c_table;
+OMPI_DECLSPEC extern struct opal_pointer_array_t ompi_group_f_to_c_table;
 OMPI_DECLSPEC extern ompi_group_t ompi_mpi_group_null;
 
 
Index: ompi/win/win.h
===================================================================
--- ompi/win/win.h	(revision 16968)
+++ ompi/win/win.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -48,7 +48,7 @@
 #define OMPI_WIN_STARTED      0x00000040
 #define OMPI_WIN_LOCK_ACCESS  0x00000080
 
-OMPI_DECLSPEC extern ompi_pointer_array_t ompi_mpi_windows;
+OMPI_DECLSPEC extern opal_pointer_array_t ompi_mpi_windows;
 
 struct ompi_win_t {
     opal_object_t w_base;
Index: ompi/win/win.c
===================================================================
--- ompi/win/win.c	(revision 16968)
+++ ompi/win/win.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -33,7 +33,7 @@
  * Table for Fortran <-> C communicator handle conversion.  Note that
  * these are not necessarily global.
  */
-ompi_pointer_array_t ompi_mpi_windows; 
+opal_pointer_array_t ompi_mpi_windows; 
 
 ompi_win_t ompi_mpi_win_null;
 
@@ -47,7 +47,11 @@
 ompi_win_init(void)
 {
     /* setup window Fortran array */
-    OBJ_CONSTRUCT(&ompi_mpi_windows, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&ompi_mpi_windows, opal_pointer_array_t);
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_mpi_windows, 0,
+                                                OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
 
     /* Setup MPI_WIN_NULL */
     OBJ_CONSTRUCT(&ompi_mpi_win_null, ompi_win_t);
@@ -55,7 +59,7 @@
     ompi_mpi_win_null.w_group = &ompi_mpi_group_null;
     OBJ_RETAIN(&ompi_mpi_group_null);
     ompi_win_set_name(&ompi_mpi_win_null, "MPI_WIN_NULL");
-    ompi_pointer_array_set_item(&ompi_mpi_windows, 0, &ompi_mpi_win_null);
+    opal_pointer_array_set_item(&ompi_mpi_windows, 0, &ompi_mpi_win_null);
 
     return OMPI_SUCCESS;
 }
@@ -126,7 +130,7 @@
     }
 
     /* fill in Fortran index */
-    win->w_f_to_c_index = ompi_pointer_array_add(&ompi_mpi_windows, win);
+    win->w_f_to_c_index = opal_pointer_array_add(&ompi_mpi_windows, win);
     if (-1 == win->w_f_to_c_index) {
         ompi_win_free(win);
         return OMPI_ERR_OUT_OF_RESOURCE;
@@ -144,7 +148,7 @@
     int ret = win->w_osc_module->osc_free(win);
 
     if (-1 != win->w_f_to_c_index) {
-        ompi_pointer_array_set_item(&ompi_mpi_windows,
+        opal_pointer_array_set_item(&ompi_mpi_windows,
                                     win->w_f_to_c_index,
                                     NULL);
     }
Index: ompi/communicator/comm_init.c
===================================================================
--- ompi/communicator/comm_init.c	(revision 16968)
+++ ompi/communicator/comm_init.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -39,7 +39,7 @@
 ** on cid.
 ** 
 */
-ompi_pointer_array_t ompi_mpi_communicators; 
+opal_pointer_array_t ompi_mpi_communicators; 
 
 ompi_communicator_t  ompi_mpi_comm_world;
 ompi_communicator_t  ompi_mpi_comm_self;
@@ -66,9 +66,12 @@
     size_t size;
 
     /* Setup communicator array */
-    OBJ_CONSTRUCT(&ompi_mpi_communicators, ompi_pointer_array_t); 
+    OBJ_CONSTRUCT(&ompi_mpi_communicators, opal_pointer_array_t); 
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_mpi_communicators, 0,
+                                                OMPI_FORTRAN_HANDLE_MAX, 64) ) {
+        return OMPI_ERROR;
+    }
 
-
     /* Setup MPI_COMM_WORLD */
     OBJ_CONSTRUCT(&ompi_mpi_comm_world, ompi_communicator_t);
     group = OBJ_NEW(ompi_group_t);
@@ -91,7 +94,7 @@
     ompi_mpi_comm_world.error_handler  = &ompi_mpi_errors_are_fatal;
     OBJ_RETAIN( &ompi_mpi_errors_are_fatal );
     OMPI_COMM_SET_PML_ADDED(&ompi_mpi_comm_world);
-    ompi_pointer_array_set_item (&ompi_mpi_communicators, 0, &ompi_mpi_comm_world);
+    opal_pointer_array_set_item (&ompi_mpi_communicators, 0, &ompi_mpi_comm_world);
 
     strncpy (ompi_mpi_comm_world.c_name, "MPI_COMM_WORLD", 
              strlen("MPI_COMM_WORLD")+1 );
@@ -124,7 +127,7 @@
     ompi_mpi_comm_self.error_handler  = &ompi_mpi_errors_are_fatal;
     OBJ_RETAIN( &ompi_mpi_errors_are_fatal );
     OMPI_COMM_SET_PML_ADDED(&ompi_mpi_comm_self);
-    ompi_pointer_array_set_item (&ompi_mpi_communicators, 1, &ompi_mpi_comm_self);
+    opal_pointer_array_set_item (&ompi_mpi_communicators, 1, &ompi_mpi_comm_self);
 
     strncpy(ompi_mpi_comm_self.c_name,"MPI_COMM_SELF",strlen("MPI_COMM_SELF")+1);
     ompi_mpi_comm_self.c_flags |= OMPI_COMM_NAMEISSET;
@@ -148,7 +151,7 @@
 
     ompi_mpi_comm_null.error_handler  = &ompi_mpi_errors_are_fatal;
     OBJ_RETAIN( &ompi_mpi_errors_are_fatal );
-    ompi_pointer_array_set_item (&ompi_mpi_communicators, 2, &ompi_mpi_comm_null);
+    opal_pointer_array_set_item (&ompi_mpi_communicators, 2, &ompi_mpi_comm_null);
 
     strncpy(ompi_mpi_comm_null.c_name,"MPI_COMM_NULL",strlen("MPI_COMM_NULL")+1);
     ompi_mpi_comm_null.c_flags |= OMPI_COMM_NAMEISSET;
@@ -240,13 +243,13 @@
     OBJ_DESTRUCT( &ompi_mpi_comm_null );
 
     /* Check whether we have some communicators left */
-    max = ompi_pointer_array_get_size(&ompi_mpi_communicators);
+    max = opal_pointer_array_get_size(&ompi_mpi_communicators);
     for ( i=3; i<max; i++ ) {
-        comm = (ompi_communicator_t *)ompi_pointer_array_get_item(&ompi_mpi_communicators, i);
+        comm = (ompi_communicator_t *)opal_pointer_array_get_item(&ompi_mpi_communicators, i);
         if ( NULL != comm ) {
             /* Communicator has not been freed before finalize */
             OBJ_RELEASE(comm);
-            comm=(ompi_communicator_t *)ompi_pointer_array_get_item(&ompi_mpi_communicators, i);
+            comm=(ompi_communicator_t *)opal_pointer_array_get_item(&ompi_mpi_communicators, i);
             if ( NULL != comm ) {
                 /* Still here ? */
                 if ( ompi_debug_show_handle_leaks && !(OMPI_COMM_IS_FREED(comm)) ){
@@ -411,9 +414,9 @@
 
     /* reset the ompi_comm_f_to_c_table entry */
     if ( MPI_UNDEFINED != comm->c_f_to_c_index && 
-         NULL != ompi_pointer_array_get_item(&ompi_mpi_communicators,
+         NULL != opal_pointer_array_get_item(&ompi_mpi_communicators,
                                              comm->c_f_to_c_index )) {
-        ompi_pointer_array_set_item ( &ompi_mpi_communicators,
+        opal_pointer_array_set_item ( &ompi_mpi_communicators,
                                       comm->c_f_to_c_index, NULL);
     }
 
Index: ompi/communicator/comm_dyn.c
===================================================================
--- ompi/communicator/comm_dyn.c	(revision 16968)
+++ ompi/communicator/comm_dyn.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -863,9 +863,9 @@
             return OMPI_ERR_OUT_OF_RESOURCE;
         }
 
-        max = ompi_pointer_array_get_size(&ompi_mpi_communicators);
+        max = opal_pointer_array_get_size(&ompi_mpi_communicators);
         for ( i=3; i<max; i++ ) {
-            comm = (ompi_communicator_t*)ompi_pointer_array_get_item(&ompi_mpi_communicators,i);
+            comm = (ompi_communicator_t*)opal_pointer_array_get_item(&ompi_mpi_communicators,i);
             if ( OMPI_COMM_IS_DYNAMIC(comm)) {
                 objs[j++]=ompi_comm_disconnect_init(comm);
             }
Index: ompi/communicator/communicator.h
===================================================================
--- ompi/communicator/communicator.h	(revision 16968)
+++ ompi/communicator/communicator.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -89,7 +89,7 @@
 #define OMPI_COMM_BLOCK_WORLD      16
 #define OMPI_COMM_BLOCK_OTHERS     8
 
-OMPI_DECLSPEC extern ompi_pointer_array_t ompi_mpi_communicators;
+OMPI_DECLSPEC extern opal_pointer_array_t ompi_mpi_communicators;
 
 struct ompi_communicator_t {
     opal_object_t              c_base;
@@ -231,7 +231,7 @@
     static inline ompi_communicator_t *ompi_comm_lookup(uint32_t cid)
     {
         /* array of pointers to communicators, indexed by context ID */
-        return (ompi_communicator_t*)ompi_pointer_array_get_item(&ompi_mpi_communicators, cid);
+        return (ompi_communicator_t*)opal_pointer_array_get_item(&ompi_mpi_communicators, cid);
     }
 
     static inline struct ompi_proc_t* ompi_comm_peer_lookup(ompi_communicator_t* comm, int peer_id)
Index: ompi/communicator/comm_cid.c
===================================================================
--- ompi/communicator/comm_cid.c	(revision 16968)
+++ ompi/communicator/comm_cid.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -27,7 +27,7 @@
 #include "ompi/communicator/communicator.h"
 #include "ompi/proc/proc.h"
 #include "ompi/constants.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "opal/class/opal_list.h"
 #include "ompi/mca/pml/pml.h"
 #include "ompi/mca/coll/base/base.h"
@@ -181,7 +181,7 @@
             
             
             for (i=start; i < mca_pml.pml_max_contextid ; i++) {
-                flag=ompi_pointer_array_test_and_set_item(&ompi_mpi_communicators, 
+                flag=opal_pointer_array_test_and_set_item(&ompi_mpi_communicators, 
                                                           i, comm);
                 if (true == flag) {
                     nextlocal_cid = i;
@@ -195,10 +195,10 @@
                 response = 1; /* fine with me */
             }
             else {
-                ompi_pointer_array_set_item(&ompi_mpi_communicators, 
+                opal_pointer_array_set_item(&ompi_mpi_communicators, 
                                             nextlocal_cid, NULL);
                 
-                flag = ompi_pointer_array_test_and_set_item(&ompi_mpi_communicators, 
+                flag = opal_pointer_array_test_and_set_item(&ompi_mpi_communicators, 
                                                             nextcid, comm );
                 if (true == flag) {
                     response = 1; /* works as well */
@@ -217,7 +217,7 @@
             else if ( 0 == glresponse ) {
                 if ( 1 == response ) {
                     /* we could use that, but other don't agree */
-                    ompi_pointer_array_set_item(&ompi_mpi_communicators, 
+                    opal_pointer_array_set_item(&ompi_mpi_communicators, 
                                                 nextcid, NULL);
                 }
                 start = nextcid+1; /* that's where we can start the next round */
@@ -227,7 +227,7 @@
         /* set the according values to the newcomm */
         newcomm->c_contextid = nextcid;
         newcomm->c_f_to_c_index = newcomm->c_contextid;
-        ompi_pointer_array_set_item (&ompi_mpi_communicators, nextcid, newcomm);
+        opal_pointer_array_set_item (&ompi_mpi_communicators, nextcid, newcomm);
         
         /* for synchronization purposes, avoids receiving fragments for 
            a communicator id, which might not yet been known. For single-threaded
@@ -273,7 +273,7 @@
                MPI_UNDEFINED != comm->c_id_start_index &&  
                block > comm->c_id_available - comm->c_id_start_index) {
                 nextcid = comm->c_id_available;
-                flag=ompi_pointer_array_test_and_set_item (&ompi_mpi_communicators,
+                flag=opal_pointer_array_test_and_set_item (&ompi_mpi_communicators,
                                                            nextcid, comm);
             }
             /**
@@ -295,7 +295,7 @@
     /* set the according values to the newcomm */
     newcomm->c_contextid = nextcid;
     newcomm->c_f_to_c_index = newcomm->c_contextid;
-    ompi_pointer_array_set_item (&ompi_mpi_communicators, nextcid, newcomm);
+    opal_pointer_array_set_item (&ompi_mpi_communicators, nextcid, newcomm);
 
     return (MPI_SUCCESS);
 
Index: ompi/mca/btl/elan/btl_elan.h
===================================================================
--- ompi/mca/btl/elan/btl_elan.h	(revision 16968)
+++ ompi/mca/btl/elan/btl_elan.h	(working copy)
@@ -25,7 +25,6 @@
 /* Open MPI includes */
 #include "ompi/class/ompi_free_list.h"
 #include "ompi/class/ompi_bitmap.h"
-#include "orte/class/orte_pointer_array.h"
 #include "opal/event/event.h"
 #include "ompi/mca/pml/pml.h"
 #include "ompi/mca/btl/btl.h"
Index: ompi/mca/btl/udapl/btl_udapl.c
===================================================================
--- ompi/mca/btl/udapl/btl_udapl.c	(revision 16968)
+++ ompi/mca/btl/udapl/btl_udapl.c	(working copy)
@@ -356,7 +356,8 @@
                            NULL);
 
     /* initialize eager rdma buffer info */
-    orte_pointer_array_init(&btl->udapl_eager_rdma_endpoints, 
+    btl->udapl_eager_rdma_endpoints = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(btl->udapl_eager_rdma_endpoints, 
         mca_btl_udapl_component.udapl_max_eager_rdma_peers,
         mca_btl_udapl_component.udapl_max_eager_rdma_peers, 
         0);
@@ -393,7 +394,7 @@
      */
     for (i=0; i < udapl_btl->udapl_eager_rdma_endpoint_count; i++) {
         mca_btl_udapl_endpoint_t* endpoint =
-            orte_pointer_array_get_item(udapl_btl->udapl_eager_rdma_endpoints,
+            opal_pointer_array_get_item(udapl_btl->udapl_eager_rdma_endpoints,
                 i);
 
         OBJ_DESTRUCT(endpoint);
Index: ompi/mca/btl/udapl/btl_udapl_endpoint.c
===================================================================
--- ompi/mca/btl/udapl/btl_udapl_endpoint.c	(revision 16968)
+++ ompi/mca/btl/udapl/btl_udapl_endpoint.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -32,7 +32,7 @@
 #include "orte/mca/rml/rml.h"
 #include "orte/mca/errmgr/errmgr.h"
 #include "orte/dss/dss.h"
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "ompi/class/ompi_free_list.h"
 #include "ompi/mca/mpool/rdma/mpool_rdma.h"
 #include "ompi/mca/btl/base/btl_base_error.h"
@@ -1158,8 +1158,9 @@
      }
 
     OPAL_THREAD_LOCK(&udapl_btl->udapl_eager_rdma_lock);
-    if(orte_pointer_array_add (&endpoint->endpoint_eager_rdma_index,
-                udapl_btl->udapl_eager_rdma_endpoints, endpoint) < 0)
+    endpoint->endpoint_eager_rdma_index =
+        opal_pointer_array_add(udapl_btl->udapl_eager_rdma_endpoints, endpoint);
+    if( 0 > endpoint->endpoint_eager_rdma_index )
            goto cleanup;
 
     /* record first fragment location */
@@ -1175,7 +1176,7 @@
 
     udapl_btl->udapl_eager_rdma_endpoint_count--;
     endpoint->endpoint_eager_rdma_local.base.pval = NULL;
-    orte_pointer_array_set_item(udapl_btl->udapl_eager_rdma_endpoints,
+    opal_pointer_array_set_item(udapl_btl->udapl_eager_rdma_endpoints,
             endpoint->endpoint_eager_rdma_index, NULL);
 
 cleanup:
Index: ompi/mca/btl/udapl/btl_udapl.h
===================================================================
--- ompi/mca/btl/udapl/btl_udapl.h	(revision 16968)
+++ ompi/mca/btl/udapl/btl_udapl.h	(working copy)
@@ -30,7 +30,7 @@
 #include <dat/udat.h>
 
 /* Open MPI includes */
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "ompi/class/ompi_free_list.h"
 #include "ompi/class/ompi_bitmap.h"
 #include "opal/event/event.h"
@@ -131,7 +131,7 @@
                                                  * endpoints in
                                                  * udapl_eager_rdma_endpoints
                                                  */
-    orte_pointer_array_t *udapl_eager_rdma_endpoints;   /* array of endpoints
+    opal_pointer_array_t *udapl_eager_rdma_endpoints;   /* array of endpoints
                                                          * with eager rdma
                                                          * connections
                                                          */
Index: ompi/mca/btl/udapl/btl_udapl_component.c
===================================================================
--- ompi/mca/btl/udapl/btl_udapl_component.c	(revision 16968)
+++ ompi/mca/btl/udapl/btl_udapl_component.c	(working copy)
@@ -1076,7 +1076,7 @@
             mca_btl_udapl_frag_t *local_rdma_frag;
 
             endpoint =
-                orte_pointer_array_get_item(btl->udapl_eager_rdma_endpoints, j);
+                opal_pointer_array_get_item(btl->udapl_eager_rdma_endpoints, j);
 
             OPAL_THREAD_LOCK(&endpoint->endpoint_eager_rdma_local.lock);
 
Index: ompi/mca/btl/openib/btl_openib_component.c
===================================================================
--- ompi/mca/btl/openib/btl_openib_component.c	(revision 16968)
+++ ompi/mca/btl/openib/btl_openib_component.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -138,7 +138,7 @@
     /* initialize state */
     mca_btl_openib_component.ib_num_btls = 0;
     mca_btl_openib_component.openib_btls = NULL;
-    OBJ_CONSTRUCT(&mca_btl_openib_component.hcas, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&mca_btl_openib_component.hcas, opal_pointer_array_t);
     mca_btl_openib_component.hcas_count = 0;
 
     /* initialize objects */ 
@@ -726,8 +726,9 @@
         hca->progress = false;
 #endif
 #endif
-        orte_pointer_array_init(&hca->endpoints, 10, INT_MAX, 10);
-        ompi_pointer_array_add(&mca_btl_openib_component.hcas, hca);
+        hca->endpoints = OBJ_NEW(opal_pointer_array_t);
+        opal_pointer_array_init(hca->endpoints, 10, INT_MAX, 10);
+        opal_pointer_array_add(&mca_btl_openib_component.hcas, hca);
         mca_btl_openib_component.hcas_count++;
         return OMPI_SUCCESS;
     }
@@ -908,7 +909,8 @@
         }
     }
 
-    orte_pointer_array_init(&openib_btl->eager_rdma_buffers, 
+    opanib_btl->eager_rdma_buffers = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(openib_btl->eager_rdma_buffers, 
             mca_btl_openib_component.max_eager_rdma,
             mca_btl_openib_component.max_eager_rdma, 
             0);
@@ -1530,7 +1532,7 @@
 
         for(j = 0; j < c; j++) {
             endpoint = 
-                orte_pointer_array_get_item(openib_btl->eager_rdma_buffers, j);
+                opal_pointer_array_get_item(openib_btl->eager_rdma_buffers, j);
 
             if(!endpoint) /* shouldn't happen */
                 continue;
@@ -1580,7 +1582,7 @@
 
     for(i = 0; i < mca_btl_openib_component.hcas_count; i++) {
         mca_btl_openib_hca_t *hca =
-            ompi_pointer_array_get_item(&mca_btl_openib_component.hcas, i);
+            opal_pointer_array_get_item(&mca_btl_openib_component.hcas, i);
         count += btl_openib_module_progress(hca);
     }
 
@@ -1676,7 +1678,7 @@
             case IBV_WC_RECV:
                 if(wc.wc_flags & IBV_WC_WITH_IMM) {
                     endpoint = (mca_btl_openib_endpoint_t*)
-                        orte_pointer_array_get_item(hca->endpoints, wc.imm_data);
+                        opal_pointer_array_get_item(hca->endpoints, wc.imm_data);
                     frag->endpoint = endpoint;
                     openib_btl = endpoint->endpoint_btl;
                 }
Index: ompi/mca/btl/openib/btl_openib.c
===================================================================
--- ompi/mca/btl/openib/btl_openib.c	(revision 16968)
+++ ompi/mca/btl/openib/btl_openib.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -250,8 +250,12 @@
             continue;
         }
         
-        orte_pointer_array_add((orte_std_cntr_t*)&endpoint->index,
-                               openib_btl->hca->endpoints, (void*)endpoint);
+        endpoint->index = opal_pointer_array_add(openib_btl->hca->endpoints, (void*)endpoint);
+        if( 0 > endpoint->index ) {
+            OBJ_RELEASE(endpoint);
+            OPAL_THREAD_UNLOCK(&ib_proc->proc_lock);
+            continue;
+        }
         ompi_bitmap_set_bit(reachable, i);
         OPAL_THREAD_UNLOCK(&ib_proc->proc_lock);
         
@@ -426,10 +430,10 @@
     for (i=0 ; i < (int) nprocs ; i++) {
         mca_btl_base_endpoint_t* del_endpoint = peers[i];
         for(ep_index=0;
-            ep_index < orte_pointer_array_get_size(openib_btl->hca->endpoints);
+            ep_index < opal_pointer_array_get_size(openib_btl->hca->endpoints);
             ep_index++) {
             endpoint = 
-                orte_pointer_array_get_item(openib_btl->hca->endpoints,
+                opal_pointer_array_get_item(openib_btl->hca->endpoints,
                         ep_index);
             if(!endpoint || endpoint->endpoint_btl != openib_btl) {
                 continue;
@@ -437,7 +441,7 @@
             if (endpoint == del_endpoint) {
                 BTL_VERBOSE(("in del_procs %d, setting another endpoint to null\n", 
                              ep_index));
-                orte_pointer_array_set_item(openib_btl->hca->endpoints,
+                opal_pointer_array_set_item(openib_btl->hca->endpoints,
                         ep_index, NULL);
                 assert(((opal_object_t*)endpoint)->obj_reference_count == 1);
                 OBJ_RELEASE(endpoint);
@@ -975,9 +979,9 @@
 
     /* Release eager RDMAs */
     for(rdma_index=0;
-            rdma_index < orte_pointer_array_get_size(openib_btl->eager_rdma_buffers);
+            rdma_index < opal_pointer_array_get_size(openib_btl->eager_rdma_buffers);
         rdma_index++) {
-        endpoint=orte_pointer_array_get_item(openib_btl->eager_rdma_buffers,rdma_index);
+        endpoint=opal_pointer_array_get_item(openib_btl->eager_rdma_buffers,rdma_index);
         if(!endpoint) {
             continue;
         }
@@ -985,9 +989,9 @@
     }
     /* Release all QPs */
     for(ep_index=0;
-            ep_index < orte_pointer_array_get_size(openib_btl->hca->endpoints);
+            ep_index < opal_pointer_array_get_size(openib_btl->hca->endpoints);
             ep_index++) {
-        endpoint=orte_pointer_array_get_item(openib_btl->hca->endpoints,
+        endpoint=opal_pointer_array_get_item(openib_btl->hca->endpoints,
                 ep_index);
         if(!endpoint) {
             BTL_VERBOSE(("In finalize, got another null endpoint\n"));
Index: ompi/mca/btl/openib/btl_openib_endpoint.c
===================================================================
--- ompi/mca/btl/openib/btl_openib_endpoint.c	(revision 16968)
+++ ompi/mca/btl/openib/btl_openib_endpoint.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -786,7 +786,6 @@
     char *buf;
     mca_btl_openib_recv_frag_t *headers_buf;
     int i;
-    orte_std_cntr_t index;
 
     /* Set local rdma pointer to 1 temporarily so other threads will not try
      * to enter the function */
@@ -855,8 +854,7 @@
          * at init time */
         OBJ_RETAIN(endpoint);
         assert(((opal_object_t*)endpoint)->obj_reference_count == 2);
-        orte_pointer_array_add(&index, openib_btl->eager_rdma_buffers,
-                endpoint);
+        opal_pointer_array_add(openib_btl->eager_rdma_buffers, endpoint);
         /* from this point progress function starts to poll new buffer */
         OPAL_THREAD_ADD32(&openib_btl->eager_rdma_buffers_count, 1);
         return;
Index: ompi/mca/btl/openib/btl_openib.h
===================================================================
--- ompi/mca/btl/openib/btl_openib.h	(revision 16968)
+++ ompi/mca/btl/openib/btl_openib.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2007 High Performance Computing Center Stuttgart, 
@@ -34,7 +34,7 @@
 /* Open MPI includes */
 #include "ompi/class/ompi_free_list.h"
 #include "ompi/class/ompi_bitmap.h"
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "opal/event/event.h"
 #include "ompi/mca/pml/pml.h"
 #include "ompi/mca/btl/btl.h"
@@ -103,7 +103,7 @@
     struct mca_btl_openib_module_t             **openib_btls;
     /**< array of available BTLs */
 
-    ompi_pointer_array_t hcas; /**< array of available hcas */
+    opal_pointer_array_t hcas; /**< array of available hcas */
     int hcas_count;
 
     int ib_free_list_num;
@@ -260,7 +260,7 @@
     /* Whether this HCA supports eager RDMA */
     uint8_t use_eager_rdma;
     uint8_t btls;              /** < number of btls using this HCA */
-    orte_pointer_array_t *endpoints;
+    opal_pointer_array_t *endpoints;
 #if OMPI_HAVE_THREADS
     volatile bool got_fatal_event;
 #endif
@@ -324,7 +324,7 @@
     size_t ib_inline_max; /**< max size of inline send*/ 
     
     size_t eager_rdma_frag_size;                /**< length of eager frag */
-    orte_pointer_array_t *eager_rdma_buffers;   /**< RDMA buffers to poll */
+    opal_pointer_array_t *eager_rdma_buffers;   /**< RDMA buffers to poll */
     volatile int32_t eager_rdma_buffers_count;  /**< number of RDMA buffers */
 
     mca_btl_base_module_error_cb_fn_t error_cb; /**< error handler */
Index: ompi/mca/rcache/rb/rcache_rb.c
===================================================================
--- ompi/mca/rcache/rb/rcache_rb.c	(revision 16968)
+++ ompi/mca/rcache/rb/rcache_rb.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -39,14 +39,12 @@
     mca_rcache_rb_mru_init(rcache);
 }
 
-int mca_rcache_rb_find (
-                        struct mca_rcache_base_module_t* rcache, 
+int mca_rcache_rb_find( struct mca_rcache_base_module_t* rcache, 
                         void* addr, 
                         size_t size, 
-                        ompi_pointer_array_t* regs, 
-                        uint32_t *cnt
-                        ){ 
-    
+                        opal_pointer_array_t* regs, 
+                        uint32_t *cnt )
+{ 
     int rc = OMPI_SUCCESS; 
     mca_rcache_rb_tree_item_t* tree_item = NULL; 
     void* base_addr; 
@@ -69,7 +67,7 @@
     while(base_addr <= bound_addr) { 
         tree_item = mca_rcache_rb_tree_find( (mca_rcache_rb_module_t*) rcache, base_addr ); 
         if(NULL != tree_item) { 
-            ompi_pointer_array_add(regs, (void*) tree_item->reg); 
+            opal_pointer_array_add(regs, (void*) tree_item->reg); 
             if( tree_item->reg->flags & MCA_MPOOL_FLAGS_CACHE ) { 
                 rc = mca_rcache_rb_mru_touch((mca_rcache_rb_module_t*)rcache, 
                                              tree_item->reg); 
Index: ompi/mca/rcache/rb/rcache_rb.h
===================================================================
--- ompi/mca/rcache/rb/rcache_rb.h	(revision 16968)
+++ ompi/mca/rcache/rb/rcache_rb.h	(working copy)
@@ -2,7 +2,7 @@
   * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
   *                         University Research and Technology
   *                         Corporation.  All rights reserved.
-  * Copyright (c) 2004-2006 The University of Tennessee and The University
+  * Copyright (c) 2004-2007 The University of Tennessee and The University
   *                         of Tennessee Research Foundation.  All rights
   *                         reserved.
   * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -21,6 +21,7 @@
   */
 #ifndef MCA_RCACHE_RB_H
 #define MCA_RCACHE_RB_H
+
 #include "opal/mca/mca.h"
 #include "ompi/info/info.h"
 #include "opal/class/opal_list.h" 
@@ -42,31 +43,26 @@
 
 struct mca_rcache_rb_component_t { 
     mca_rcache_base_component_t super; 
-}; typedef struct mca_rcache_rb_component_t mca_rcache_rb_component_t; 
+};
+typedef struct mca_rcache_rb_component_t mca_rcache_rb_component_t; 
 
 OMPI_MODULE_DECLSPEC extern mca_rcache_rb_component_t mca_rcache_rb_component;
 
 void mca_rcache_rb_module_init( mca_rcache_rb_module_t* rcache );
 
-int mca_rcache_rb_find (
-                        mca_rcache_base_module_t* rcache, 
+int mca_rcache_rb_find( mca_rcache_base_module_t* rcache, 
                         void* addr, 
                         size_t size, 
-                        ompi_pointer_array_t* regs, 
-                        uint32_t *cnt
-                        );
+                        opal_pointer_array_t* regs, 
+                        uint32_t *cnt );
 
-int mca_rcache_rb_insert ( 
-                          struct mca_rcache_base_module_t* rcache, 
+int mca_rcache_rb_insert( struct mca_rcache_base_module_t* rcache, 
                           mca_mpool_base_registration_t* registration, 
-                          uint32_t flags
-                          ); 
+                          uint32_t flags ); 
 
-int mca_rcache_rb_delete (
-                          struct mca_rcache_base_module_t* rcache, 
+int mca_rcache_rb_delete( struct mca_rcache_base_module_t* rcache, 
                           mca_mpool_base_registration_t* registration, 
-                          uint32_t flags
-                          ); 
+                          uint32_t flags ); 
 
 
 /**
@@ -75,14 +71,7 @@
 
 void mca_rcache_rb_module_init( mca_rcache_rb_module_t* rcache );
 
-void mca_rcache_rb_finalize(
-                            struct mca_rcache_base_module_t*
-                            );
+void mca_rcache_rb_finalize( struct mca_rcache_base_module_t* );
 
-
-
-
-
 #endif /* MCA_RCACHE_RB_H */
 
-
Index: ompi/mca/rcache/vma/rcache_vma_tree.c
===================================================================
--- ompi/mca/rcache/vma/rcache_vma_tree.c	(revision 16968)
+++ ompi/mca/rcache/vma/rcache_vma_tree.c	(working copy)
@@ -2,7 +2,7 @@
   * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
   *                         University Research and Technology
   *                         Corporation.  All rights reserved.
-  * Copyright (c) 2004-2005 The University of Tennessee and The University
+  * Copyright (c) 2004-2007 The University of Tennessee and The University
   *                         of Tennessee Research Foundation.  All rights
   *                         reserved.
   * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -285,12 +285,12 @@
     return NULL;
 }
 
-static inline bool is_reg_in_array(ompi_pointer_array_t *regs, void *p)
+static inline bool is_reg_in_array(opal_pointer_array_t *regs, void *p)
 {
     int i;
 
-    for(i = 0; i < ompi_pointer_array_get_size(regs); i++) {
-        if(ompi_pointer_array_get_item(regs, i) == p)
+    for(i = 0; i < opal_pointer_array_get_size(regs); i++) {
+        if(opal_pointer_array_get_item(regs, i) == p)
             return true;
     }
 
@@ -299,7 +299,7 @@
 
 int mca_rcache_vma_tree_find_all(
         mca_rcache_vma_module_t *vma_rcache, unsigned char *base,
-        unsigned char *bound, ompi_pointer_array_t *regs)
+        unsigned char *bound, opal_pointer_array_t *regs)
 {
     int cnt = 0;
 
@@ -330,7 +330,7 @@
             if(is_reg_in_array(regs, (void*)vma_item->reg)) {
                 continue;
             }
-            ompi_pointer_array_add(regs, (void*)vma_item->reg);
+            opal_pointer_array_add(regs, (void*)vma_item->reg);
             cnt++;
         }
 
Index: ompi/mca/rcache/vma/rcache_vma.c
===================================================================
--- ompi/mca/rcache/vma/rcache_vma.c	(revision 16968)
+++ ompi/mca/rcache/vma/rcache_vma.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -61,7 +61,7 @@
 }
 
 int mca_rcache_vma_find_all(struct mca_rcache_base_module_t* rcache,
-        void* addr, size_t size, ompi_pointer_array_t *regs)
+        void* addr, size_t size, opal_pointer_array_t *regs)
 {
     void *base_addr, *bound_addr;
 
Index: ompi/mca/rcache/vma/rcache_vma_tree.h
===================================================================
--- ompi/mca/rcache/vma/rcache_vma_tree.h	(revision 16968)
+++ ompi/mca/rcache/vma/rcache_vma_tree.h	(working copy)
@@ -3,7 +3,7 @@
   * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
   *                         University Research and Technology
   *                         Corporation.  All rights reserved.
-  * Copyright (c) 2004-2005 The University of Tennessee and The University
+  * Copyright (c) 2004-2007 The University of Tennessee and The University
   *                         of Tennessee Research Foundation.  All rights
   *                         reserved.
   * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -76,7 +76,7 @@
  */
 int mca_rcache_vma_tree_find_all(
         mca_rcache_vma_module_t *vma_rcache, unsigned char *base,
-        unsigned char *bound, ompi_pointer_array_t *regs);
+        unsigned char *bound, opal_pointer_array_t *regs);
 
 /* 
  * insert an item in the vma tree 
Index: ompi/mca/rcache/vma/rcache_vma.h
===================================================================
--- ompi/mca/rcache/vma/rcache_vma.h	(revision 16968)
+++ ompi/mca/rcache/vma/rcache_vma.h	(working copy)
@@ -2,7 +2,7 @@
   * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
   *                         University Research and Technology
   *                         Corporation.  All rights reserved.
-  * Copyright (c) 2004-2005 The University of Tennessee and The University
+  * Copyright (c) 2004-2007 The University of Tennessee and The University
   *                         of Tennessee Research Foundation.  All rights
   *                         reserved.
   * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -53,7 +53,7 @@
         size_t size, mca_mpool_base_registration_t **reg);
 
 int mca_rcache_vma_find_all(mca_rcache_base_module_t* rcache, void* addr,
-         size_t size, ompi_pointer_array_t *regs);
+         size_t size, opal_pointer_array_t *regs);
 
 int mca_rcache_vma_insert(struct mca_rcache_base_module_t* rcache,
         mca_mpool_base_registration_t* registration, size_t limit);
Index: ompi/mca/rcache/rcache.h
===================================================================
--- ompi/mca/rcache/rcache.h	(revision 16968)
+++ ompi/mca/rcache/rcache.h	(working copy)
@@ -40,7 +40,7 @@
 
 typedef int (*mca_rcache_base_module_find_all_fn_t)(
         struct mca_rcache_base_module_t* rcache, void* addr, size_t size,
-        ompi_pointer_array_t *regs);
+        opal_pointer_array_t *regs);
 
 typedef int (*mca_rcache_base_module_insert_fn_t)(
         struct mca_rcache_base_module_t* rcache,
Index: ompi/mca/mpool/rdma/mpool_rdma_module.c
===================================================================
--- ompi/mca/mpool/rdma/mpool_rdma_module.c	(revision 16968)
+++ ompi/mca/mpool/rdma/mpool_rdma_module.c	(working copy)
@@ -358,17 +358,17 @@
 {
     mca_mpool_rdma_module_t *mpool_rdma = (mca_mpool_rdma_module_t*)mpool;
     mca_mpool_base_registration_t *reg;
-    ompi_pointer_array_t regs;
+    opal_pointer_array_t regs;
     int reg_cnt, i, err = 0;
 
-    OBJ_CONSTRUCT(&regs, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&regs, opal_pointer_array_t);
 
     OPAL_THREAD_LOCK(&mpool->rcache->lock);
     reg_cnt = mpool->rcache->rcache_find_all(mpool->rcache, base, size, &regs);
 
     for(i = 0; i < reg_cnt; i++) {
         reg = (mca_mpool_base_registration_t*)
-            ompi_pointer_array_get_item(&regs, i);
+            opal_pointer_array_get_item(&regs, i);
 
         if(0 == reg->ref_count) {
             if(dereg_mem(mpool, reg) != OMPI_SUCCESS) {
@@ -393,7 +393,7 @@
         }
     }
     OPAL_THREAD_UNLOCK(&mpool->rcache->lock);
-    ompi_pointer_array_remove_all(&regs);
+    opal_pointer_array_remove_all(&regs);
 
     return err?OMPI_ERROR:OMPI_SUCCESS;
 }
@@ -402,7 +402,7 @@
 {
     mca_mpool_rdma_module_t *mpool_rdma = (mca_mpool_rdma_module_t*)mpool;
     mca_mpool_base_registration_t *reg;
-    ompi_pointer_array_t regs;
+    opal_pointer_array_t regs;
     int reg_cnt, i;
 
     /* Statistic */
@@ -415,14 +415,14 @@
                 mpool_rdma->stat_evicted);
     }
 
-    OBJ_CONSTRUCT(&regs, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&regs, opal_pointer_array_t);
 
     OPAL_THREAD_LOCK(&mpool->rcache->lock);
     reg_cnt = mpool->rcache->rcache_find_all(mpool->rcache, 0, (size_t)-1, &regs);
 
     for(i = 0; i < reg_cnt; i++) {
         reg = (mca_mpool_base_registration_t*)
-            ompi_pointer_array_get_item(&regs, i);
+            opal_pointer_array_get_item(&regs, i);
 
         if(reg->ref_count) {
             reg->ref_count = 0; /* otherway dereg will fail on assert */
@@ -443,5 +443,5 @@
     OBJ_DESTRUCT(&mpool_rdma->mru_list);
     OBJ_DESTRUCT(&mpool_rdma->reg_list);
     OPAL_THREAD_UNLOCK(&mpool->rcache->lock);
-    ompi_pointer_array_remove_all(&regs);
+    opal_pointer_array_remove_all(&regs);
 }
Index: ompi/mca/mpool/base/mpool_base_mem_cb.c
===================================================================
--- ompi/mca/mpool/base/mpool_base_mem_cb.c	(revision 16968)
+++ ompi/mca/mpool/base/mpool_base_mem_cb.c	(working copy)
@@ -25,7 +25,7 @@
 #include "orte/util/proc_info.h"
 #include "orte/mca/ns/ns_types.h"
 
-ompi_pointer_array_t mca_mpool_base_mem_cb_array; 
+opal_pointer_array_t mca_mpool_base_mem_cb_array; 
 
 /*
  *  memory hook callback, called when memory is free'd out from under us
Index: ompi/mca/mpool/base/mpool_base_close.c
===================================================================
--- ompi/mca/mpool/base/mpool_base_close.c	(revision 16968)
+++ ompi/mca/mpool/base/mpool_base_close.c	(working copy)
@@ -28,7 +28,7 @@
 #include "mpool_base_mem_cb.h"
 
 extern int mca_mpool_base_use_mem_hooks; 
-extern ompi_pointer_array_t mca_mpool_base_mem_cb_array; 
+extern opal_pointer_array_t mca_mpool_base_mem_cb_array; 
 
 int mca_mpool_base_close(void)
 {
Index: ompi/mca/mpool/base/mpool_base_lookup.c
===================================================================
--- ompi/mca/mpool/base/mpool_base_lookup.c	(revision 16968)
+++ ompi/mca/mpool/base/mpool_base_lookup.c	(working copy)
@@ -40,7 +40,7 @@
 
 
 extern int mca_mpool_base_use_mem_hooks;
-extern ompi_pointer_array_t mca_mpool_base_mem_cb_array; 
+extern opal_pointer_array_t mca_mpool_base_mem_cb_array; 
 
 mca_mpool_base_component_t* mca_mpool_base_component_lookup(const char* name)
 {
@@ -102,7 +102,7 @@
         if(mca_mpool_base_use_mem_hooks &&
 	       0 != (OPAL_MEMORY_FREE_SUPPORT & opal_mem_hooks_support_level())) {
               opal_mem_hooks_register_release(mca_mpool_base_mem_cb, NULL);
-              OBJ_CONSTRUCT(&mca_mpool_base_mem_cb_array, ompi_pointer_array_t);
+              OBJ_CONSTRUCT(&mca_mpool_base_mem_cb_array, opal_pointer_array_t);
         }
 
 #if MPOOL_BASE_CAN_DISABLE_SBRK
Index: ompi/mca/mpool/mpool.h
===================================================================
--- ompi/mca/mpool/mpool.h	(revision 16968)
+++ ompi/mca/mpool/mpool.h	(working copy)
@@ -24,7 +24,6 @@
 #include "opal/mca/mca.h"
 #include "ompi/info/info.h"
 #include "ompi/class/ompi_free_list.h" 
-#include "ompi/class/ompi_pointer_array.h" 
 
 #include "opal/mca/crs/crs.h"
 #include "opal/mca/crs/base/base.h"
Index: ompi/mca/pml/ob1/pml_ob1_recvreq.h
===================================================================
--- ompi/mca/pml/ob1/pml_ob1_recvreq.h	(revision 16968)
+++ ompi/mca/pml/ob1/pml_ob1_recvreq.h	(working copy)
@@ -30,11 +30,8 @@
 #include "ompi/mca/pml/base/pml_base_recvreq.h"
 #include "ompi/datatype/datatype.h"
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
-
 struct mca_pml_ob1_recv_request_t {
     mca_pml_base_recv_request_t req_recv;
     ompi_ptr_t req_send;
@@ -436,8 +433,7 @@
  * operation cannot be accomplished for some reason. */
 void mca_pml_ob1_recv_request_process_pending(void);
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
+END_C_DECLS
+
 #endif
-#endif
 
Index: ompi/mca/pml/dr/pml_dr.c
===================================================================
--- ompi/mca/pml/dr/pml_dr.c	(revision 16968)
+++ ompi/mca/pml/dr/pml_dr.c	(working copy)
@@ -117,7 +117,7 @@
     OBJ_CONSTRUCT(&mca_pml_dr.send_active, opal_list_t);
     OBJ_CONSTRUCT(&mca_pml_dr.acks_pending, opal_list_t);
     OBJ_CONSTRUCT(&mca_pml_dr.buffers, ompi_free_list_t);
-    OBJ_CONSTRUCT(&mca_pml_dr.endpoints, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&mca_pml_dr.endpoints, opal_pointer_array_t);
     OBJ_CONSTRUCT(&mca_pml_dr.lock, opal_mutex_t);
 
     mca_pml_dr.enabled = true;
@@ -240,8 +240,7 @@
         
         /* this won't work for comm spawn and other dynamic
            processes, but will work for initial job start */
-        idx = ompi_pointer_array_add(&mca_pml_dr.endpoints,
-                                     (void*) endpoint);
+        idx = opal_pointer_array_add(&mca_pml_dr.endpoints, (void*) endpoint);
         if(orte_ns.compare_fields(ORTE_NS_CMP_ALL,
                            orte_process_info.my_name,
                            &(endpoint->proc_ompi->proc_name)) == ORTE_EQUAL) {
@@ -256,7 +255,7 @@
     
     for(i = 0; i < nprocs; i++) { 
         mca_pml_dr_endpoint_t* ep =  (mca_pml_dr_endpoint_t*) 
-            ompi_pointer_array_get_item(&mca_pml_dr.endpoints, i);
+            opal_pointer_array_get_item(&mca_pml_dr.endpoints, i);
             ep->src = mca_pml_dr.my_rank;
     }
     /* no longer need this */
Index: ompi/mca/pml/dr/pml_dr.h
===================================================================
--- ompi/mca/pml/dr/pml_dr.h	(revision 16968)
+++ ompi/mca/pml/dr/pml_dr.h	(working copy)
@@ -30,7 +30,7 @@
 #include "ompi/mca/pml/base/pml_base_request.h"
 #include "ompi/mca/pml/base/pml_base_bsend.h"
 #include "ompi/mca/pml/base/pml_base_sendreq.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "ompi/mca/btl/btl.h"
 #include "ompi/datatype/datatype.h"
 
@@ -72,7 +72,7 @@
     ompi_free_list_t buffers;
     
     /* endpoint pointer array */
-    ompi_pointer_array_t endpoints;
+    opal_pointer_array_t endpoints;
     
     /* my 'global' rank */ 
     int32_t my_rank;
Index: ompi/mca/pml/dr/pml_dr_comm.c
===================================================================
--- ompi/mca/pml/dr/pml_dr_comm.c	(revision 16968)
+++ ompi/mca/pml/dr/pml_dr_comm.c	(working copy)
@@ -54,7 +54,7 @@
 {
     OBJ_CONSTRUCT(&comm->wild_receives, opal_list_t);
     OBJ_CONSTRUCT(&comm->matching_lock, opal_mutex_t);
-    OBJ_CONSTRUCT(&comm->sparse_procs, ompi_pointer_array_t);
+    OBJ_CONSTRUCT(&comm->sparse_procs, opal_pointer_array_t);
     comm->recv_sequence = 0;
     comm->procs = NULL;
     comm->num_procs = 0;
@@ -104,7 +104,7 @@
         ompi_proc = ompi_group_peer_lookup(ompi_comm->c_remote_group,i);
         proc->ompi_proc = ompi_proc;
         pml_ep = (mca_pml_dr_endpoint_t*) ompi_proc->proc_pml;
-        ompi_pointer_array_set_item(&dr_comm->sparse_procs, 
+        opal_pointer_array_set_item(&dr_comm->sparse_procs, 
                                     pml_ep->dst,  /* from our view this is the 
                                                   peers source 'global rank' */
                                     proc); 
Index: ompi/mca/pml/dr/pml_dr_recvfrag.c
===================================================================
--- ompi/mca/pml/dr/pml_dr_recvfrag.c	(revision 16968)
+++ ompi/mca/pml/dr/pml_dr_recvfrag.c	(working copy)
@@ -51,7 +51,7 @@
             return;                                                                            \
         }                                                                                      \
     }                                                                                          \
-    ep = (mca_pml_dr_endpoint_t*)ompi_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);          \
+    ep = (mca_pml_dr_endpoint_t*)opal_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);          \
     assert(ep != NULL);                                                                        \
     if(ompi_seq_tracker_check_duplicate(&ep->seq_sends, hdr->hdr_common.hdr_vid)) {            \
         MCA_PML_DR_DEBUG(0, (0, "%s:%d: dropping duplicate ack, vfrag ID %d", \
@@ -138,7 +138,7 @@
                                      __FILE__, __LINE__, hdr->hdr_common.hdr_src, hdr->hdr_common.hdr_dst));            
                 return;                                                                                
             } 
-            ep = (mca_pml_dr_endpoint_t*)ompi_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);              
+            ep = (mca_pml_dr_endpoint_t*)opal_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);              
             assert(ep != NULL);                                                                        
 
             if(ompi_seq_tracker_check_duplicate(&ep->seq_recvs, hdr->hdr_common.hdr_vid)) {    
@@ -158,8 +158,8 @@
                 return;                                                                                
             }                                                                                          
             comm = (mca_pml_dr_comm_t*)ompi_comm->c_pml_comm;                                          
-            assert(hdr->hdr_common.hdr_src < ompi_pointer_array_get_size(&comm->sparse_procs));        
-            proc = (mca_pml_dr_comm_proc_t*)ompi_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);          
+            assert(hdr->hdr_common.hdr_src < opal_pointer_array_get_size(&comm->sparse_procs));        
+            proc = (mca_pml_dr_comm_proc_t*)opal_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);          
             assert(proc != NULL);                                                                      
             assert(ep == proc->pml_endpoint);                                                              
             mca_pml_dr_recv_frag_match(comm,proc,btl,&hdr->hdr_match,segments,des->des_dst_cnt);
@@ -188,7 +188,7 @@
                                      __FILE__, __LINE__, hdr->hdr_common.hdr_src, hdr->hdr_common.hdr_dst));
                 return;
             } 
-            ep = (mca_pml_dr_endpoint_t*)ompi_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);
+            ep = (mca_pml_dr_endpoint_t*)opal_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);
             assert(ep != NULL);
             
             /* seq_recvs protected by matching lock */
@@ -211,8 +211,8 @@
                     }
                 }
                 comm = (mca_pml_dr_comm_t*)ompi_comm->c_pml_comm;
-                assert(hdr->hdr_common.hdr_src < ompi_pointer_array_get_size(&comm->sparse_procs));
-                proc = (mca_pml_dr_comm_proc_t*)ompi_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);
+                assert(hdr->hdr_common.hdr_src < opal_pointer_array_get_size(&comm->sparse_procs));
+                proc = (mca_pml_dr_comm_proc_t*)opal_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);
                 assert(proc != NULL);
                 assert(ep == proc->pml_endpoint);
                 
@@ -243,8 +243,8 @@
                     orte_errmgr.abort();
                 }
                 comm = (mca_pml_dr_comm_t*)ompi_comm->c_pml_comm;
-                assert(hdr->hdr_common.hdr_src < ompi_pointer_array_get_size(&comm->sparse_procs));
-                proc = (mca_pml_dr_comm_proc_t*)ompi_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);
+                assert(hdr->hdr_common.hdr_src < opal_pointer_array_get_size(&comm->sparse_procs));
+                proc = (mca_pml_dr_comm_proc_t*)opal_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);
                 assert(proc != NULL);
                 assert(ep == proc->pml_endpoint);
                 mca_pml_dr_recv_frag_match(comm,proc,btl,&hdr->hdr_match,segments,des->des_dst_cnt);
@@ -274,7 +274,7 @@
                              __FILE__, __LINE__, hdr->hdr_common.hdr_src, hdr->hdr_common.hdr_dst));
                 return;                                                                                
             } 
-            ep = (mca_pml_dr_endpoint_t*)ompi_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);
+            ep = (mca_pml_dr_endpoint_t*)opal_pointer_array_get_item(&mca_pml_dr.endpoints, hdr->hdr_common.hdr_src);
             assert(ep != NULL);                                                                        
             
             /* seq_recvs protected by matching lock */
@@ -292,8 +292,8 @@
                     orte_errmgr.abort();
                 }
                 comm = (mca_pml_dr_comm_t*)ompi_comm->c_pml_comm;                                          
-                assert(hdr->hdr_common.hdr_src < ompi_pointer_array_get_size(&comm->sparse_procs));        
-                proc = (mca_pml_dr_comm_proc_t*)ompi_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);          
+                assert(hdr->hdr_common.hdr_src < opal_pointer_array_get_size(&comm->sparse_procs));        
+                proc = (mca_pml_dr_comm_proc_t*)opal_pointer_array_get_item(&comm->sparse_procs, hdr->hdr_common.hdr_src);          
                 assert(proc != NULL);                                                                      
                 assert(ep == proc->pml_endpoint); 
                 
@@ -927,7 +927,7 @@
                  *   look only at "specific" receives, or "wild" receives,
                  *   or if we need to traverse both sets at the same time.
                  */
-                proc = (mca_pml_dr_comm_proc_t*)ompi_pointer_array_get_item(&comm->sparse_procs, 
+                proc = (mca_pml_dr_comm_proc_t*)opal_pointer_array_get_item(&comm->sparse_procs, 
                                                                             hdr->hdr_common.hdr_src);
                 
                 if (opal_list_get_size(&proc->specific_receives) == 0 ) {
Index: ompi/mca/pml/dr/pml_dr_comm.h
===================================================================
--- ompi/mca/pml/dr/pml_dr_comm.h	(revision 16968)
+++ ompi/mca/pml/dr/pml_dr_comm.h	(working copy)
@@ -63,7 +63,7 @@
 #endif
     opal_mutex_t matching_lock;   /**< matching lock */
     opal_list_t wild_receives;    /**< queue of unmatched wild (source process not specified) receives */
-    ompi_pointer_array_t sparse_procs;   /**< sparse array, allows lookup of comm_proc using a global rank */  
+    opal_pointer_array_t sparse_procs;   /**< sparse array, allows lookup of comm_proc using a global rank */  
     mca_pml_dr_comm_proc_t* procs;
     size_t num_procs;
 };
Index: ompi/mca/pml/base/pml_base_recvreq.h
===================================================================
--- ompi/mca/pml/base/pml_base_recvreq.h	(revision 16968)
+++ ompi/mca/pml/base/pml_base_recvreq.h	(working copy)
@@ -26,9 +26,7 @@
 #include "ompi/datatype/convertor.h"
 #include "ompi/peruse/peruse-internal.h"
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
 /**
  * Base type for receive requests.
@@ -118,8 +116,7 @@
         ompi_convertor_cleanup( &((request)->req_base.req_convertor) ); \
     } while (0)
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
+END_C_DECLS
+
 #endif
-#endif
 
Index: ompi/mca/pml/base/base.h
===================================================================
--- ompi/mca/pml/base/base.h	(revision 16968)
+++ ompi/mca/pml/base/base.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -23,15 +23,13 @@
 
 #include "opal/mca/mca.h"
 #include "ompi/mca/pml/pml.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 
 /*
  * Global functions for the PML
  */
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
 /*
  * This is the base priority for a PML wrapper component
@@ -64,9 +62,8 @@
 OMPI_DECLSPEC extern opal_list_t mca_pml_base_components_available;
 OMPI_DECLSPEC extern mca_pml_base_component_t mca_pml_base_selected_component;
 OMPI_DECLSPEC extern mca_pml_base_module_t mca_pml;
-OMPI_DECLSPEC extern ompi_pointer_array_t mca_pml_base_pml;
+OMPI_DECLSPEC extern opal_pointer_array_t mca_pml_base_pml;
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
+END_C_DECLS
+
 #endif /* MCA_PML_BASE_H */
Index: ompi/mca/pml/base/pml_base_request.h
===================================================================
--- ompi/mca/pml/base/pml_base_request.h	(revision 16968)
+++ ompi/mca/pml/base/pml_base_request.h	(working copy)
@@ -25,9 +25,7 @@
 #include "ompi/request/request.h"
 #include "ompi/datatype/convertor.h"
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
 /**
  * External list for the requests. They are declared as lists of
@@ -76,8 +74,7 @@
 
 OMPI_DECLSPEC OBJ_CLASS_DECLARATION(mca_pml_base_request_t);
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
+END_C_DECLS
+
 #endif
-#endif
 
Index: ompi/mca/pml/base/pml_base_select.c
===================================================================
--- ompi/mca/pml/base/pml_base_select.c	(revision 16968)
+++ ompi/mca/pml/base/pml_base_select.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -78,9 +78,9 @@
 
         /* if there is an include list - item must be in the list to be included */
         found_pml = false;
-        for( i = 0; i < ompi_pointer_array_get_size(&mca_pml_base_pml); i++) { 
+        for( i = 0; i < opal_pointer_array_get_size(&mca_pml_base_pml); i++) { 
             char * tmp_val = NULL;
-            tmp_val = (char *) ompi_pointer_array_get_item(&mca_pml_base_pml, i);
+            tmp_val = (char *) opal_pointer_array_get_item(&mca_pml_base_pml, i);
             if( NULL == tmp_val) {
                 continue;
             }
@@ -92,7 +92,7 @@
             }
         }
 
-        if(!found_pml && ompi_pointer_array_get_size(&mca_pml_base_pml)) { 
+        if(!found_pml && opal_pointer_array_get_size(&mca_pml_base_pml)) { 
             opal_output_verbose( 10, mca_pml_base_output,
                                      "select: component %s not in the include list",
                                      component->pmlm_version.mca_component_name );
@@ -158,9 +158,9 @@
     
     if( NULL == best_component ) {
         opal_show_help("help-mca-base.txt", "find-available:none-found", true, "pml");
-        for( i = 0; i < ompi_pointer_array_get_size(&mca_pml_base_pml); i++) { 
+        for( i = 0; i < opal_pointer_array_get_size(&mca_pml_base_pml); i++) { 
             char * tmp_val = NULL;
-            tmp_val = (char *) ompi_pointer_array_get_item(&mca_pml_base_pml, i);
+            tmp_val = (char *) opal_pointer_array_get_item(&mca_pml_base_pml, i);
             if( NULL == tmp_val) {
                 continue;
             }
Index: ompi/mca/pml/base/pml_base_open.c
===================================================================
--- ompi/mca/pml/base/pml_base_open.c	(revision 16968)
+++ ompi/mca/pml/base/pml_base_open.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2007 High Performance Computing Center Stuttgart, 
@@ -75,7 +75,7 @@
 
 opal_list_t mca_pml_base_components_available;
 mca_pml_base_component_t mca_pml_base_selected_component;
-ompi_pointer_array_t mca_pml_base_pml;
+opal_pointer_array_t mca_pml_base_pml;
 
 /**
  * Function for finding and opening either all MCA components, or the one
@@ -123,10 +123,9 @@
      * uses BTLs and any other PMLs that do not in the mca_pml_base_pml array.
      */
 
-    OBJ_CONSTRUCT(&mca_pml_base_pml, ompi_pointer_array_t);
-    
+    OBJ_CONSTRUCT(&mca_pml_base_pml, opal_pointer_array_t);
 #if MCA_pml_DIRECT_CALL
-    ompi_pointer_array_add(&mca_pml_base_pml, 
+    opal_pointer_array_add(&mca_pml_base_pml, 
                            stringify(MCA_pml_DIRECT_CALL_COMPONENT));
 #else
     {
@@ -137,10 +136,10 @@
                                        false, false, "", &default_pml);
         
         if(0 == strlen(default_pml)){ 
-            ompi_pointer_array_add(&mca_pml_base_pml, strdup("ob1")); 
-            ompi_pointer_array_add(&mca_pml_base_pml, strdup("cm"));
+            opal_pointer_array_add(&mca_pml_base_pml, strdup("ob1")); 
+            opal_pointer_array_add(&mca_pml_base_pml, strdup("cm"));
         } else { 
-            ompi_pointer_array_add(&mca_pml_base_pml, strdup(default_pml));
+            opal_pointer_array_add(&mca_pml_base_pml, strdup(default_pml));
         }
     }
 #if OPAL_ENABLE_FT == 1
@@ -154,7 +153,7 @@
                                    false, false,
                                    NULL, &wrapper_pml);
     if( NULL != wrapper_pml ) {
-        ompi_pointer_array_add(&mca_pml_base_pml, strdup(wrapper_pml));
+        opal_pointer_array_add(&mca_pml_base_pml, strdup(wrapper_pml));
     }
 #endif
 
Index: ompi/mca/pml/base/pml_base_sendreq.h
===================================================================
--- ompi/mca/pml/base/pml_base_sendreq.h	(revision 16968)
+++ ompi/mca/pml/base/pml_base_sendreq.h	(working copy)
@@ -29,9 +29,7 @@
 #include "ompi/datatype/convertor.h"
 #include "ompi/peruse/peruse-internal.h"
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
 /**
  * Base type for send requests 
@@ -139,8 +137,7 @@
     } while (0)
 
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
+END_C_DECLS
+
 #endif
-#endif
 
Index: ompi/mca/pml/crcpw/pml_crcpw.h
===================================================================
--- ompi/mca/pml/crcpw/pml_crcpw.h	(revision 16968)
+++ ompi/mca/pml/crcpw/pml_crcpw.h	(working copy)
@@ -31,7 +31,6 @@
 #include "ompi/mca/pml/base/pml_base_request.h"
 #include "ompi/mca/pml/base/pml_base_bsend.h"
 #include "ompi/mca/pml/base/pml_base_sendreq.h"
-#include "ompi/class/ompi_pointer_array.h"
 #include "ompi/mca/btl/btl.h"
 #include "ompi/datatype/datatype.h"
 #include "ompi/mca/crcp/crcp.h"
Index: ompi/mca/coll/hierarch/coll_hierarch.c
===================================================================
--- ompi/mca/coll/hierarch/coll_hierarch.c	(revision 16968)
+++ ompi/mca/coll/hierarch/coll_hierarch.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -38,7 +38,6 @@
 #include "ompi/mca/pml/pml.h"
 #include "ompi/mca/btl/btl.h"
 
-
 /* Local functions and data */
 #define HIER_MAXPROTOCOL 7
 static int mca_coll_hierarch_max_protocol=HIER_MAXPROTOCOL;
@@ -57,9 +56,8 @@
  * this module to indicate what level of thread support it provides.
  */
 int mca_coll_hierarch_init_query(bool allow_hierarch_user_threads,
-                             bool have_hidden_user_threads)
+                                 bool have_hidden_user_threads)
 {
-
     /* Don't ask. All done */
     return OMPI_SUCCESS;
 }
@@ -151,7 +149,7 @@
      * walk through the list of registered protocols, and check which one
      * is feasable. 
      * Later we start with level=0, and introduce the multi-cell check 
-    */
+     */
     if ( ignore_sm ) {
 	mca_coll_hierarch_max_protocol = HIER_MAXPROTOCOL - 1;
     }
@@ -181,7 +179,7 @@
 	    if ( mca_coll_hierarch_verbose_param ) {
 		printf("%s:%d: nobody talks with %s. Continuing to next level.\n",  
 		       comm->c_name, rank, hier_prot[level]);
-		}
+            }
 	    continue;
         }
         else if ( maxncount == (size-1) ) {
@@ -211,8 +209,8 @@
         	return NULL;
             }
 
-           hierarch_module->hier_level = level;
-	   return &(hierarch_module->super);
+            hierarch_module->hier_level = level;
+            return &(hierarch_module->super);
         }
     }
         
@@ -260,7 +258,7 @@
        information about local leader and the according subcommunicators 
     */
     llead = (struct mca_coll_hierarch_llead_t * ) malloc ( 
-	sizeof(struct mca_coll_hierarch_llead_t));
+                                                          sizeof(struct mca_coll_hierarch_llead_t));
     if ( NULL == llead ) {
         goto exit;
     }
@@ -284,11 +282,11 @@
     llead->llcomm = llcomm;
     
     /* Store it now on the data structure */
-    OBJ_CONSTRUCT(&(hierarch_module->hier_llead), ompi_pointer_array_t);
-    ompi_pointer_array_add ( &(hierarch_module->hier_llead), llead);
+    OBJ_CONSTRUCT(&(hierarch_module->hier_llead), opal_pointer_array_t);
+    opal_pointer_array_add ( &(hierarch_module->hier_llead), llead);
     
     if ( mca_coll_hierarch_verbose_param ) {
-      mca_coll_hierarch_dump_struct (hierarch_module);
+        mca_coll_hierarch_dump_struct (hierarch_module);
     }
     
  exit:
@@ -412,9 +410,9 @@
 
 
 struct ompi_communicator_t*  mca_coll_hierarch_get_llcomm (int root, 
-						     mca_coll_hierarch_module_t *hierarch_module,
-						     int* llroot,
-						     int* lroot) 
+                                                           mca_coll_hierarch_module_t *hierarch_module,
+                                                           int* llroot,
+                                                           int* lroot) 
 {
     struct ompi_communicator_t *llcomm=NULL;
     struct ompi_group_t *llgroup=NULL;
@@ -428,12 +426,12 @@
 					    hierarch_module->hier_num_colorarr, 
 					    hierarch_module->hier_colorarr );
     
-    num_llead = ompi_pointer_array_get_size ( &(hierarch_module->hier_llead) );
+    num_llead = opal_pointer_array_get_size ( &(hierarch_module->hier_llead) );
     for ( found=0, i=0; i < num_llead; i++ ) {
-        llead = (struct mca_coll_hierarch_llead_t *) ompi_pointer_array_get_item (
-	    &(hierarch_module->hier_llead), i );
+        llead = (struct mca_coll_hierarch_llead_t *) opal_pointer_array_get_item (
+                                                                                  &(hierarch_module->hier_llead), i );
 	if ( NULL == llead ) {
-	  continue;
+            continue;
 	}
 
 	if (llead->offset == offset ) {
@@ -442,10 +440,10 @@
 	}
 #if 0
 	else if () {
-	  /* the offset of root = maxoffset of this color and
-	   * the offset on llead is larger then offset of root.
-	   * then we can also use this llead structure 
-	   */
+            /* the offset of root = maxoffset of this color and
+             * the offset on llead is larger then offset of root.
+             * then we can also use this llead structure 
+             */
 	}
 #endif
     }
@@ -453,7 +451,7 @@
     if ( !found ) {
 	/* allocate a new llead element */
 	llead = (struct mca_coll_hierarch_llead_t *) malloc (
-	    sizeof(struct mca_coll_hierarch_llead_t));
+                                                             sizeof(struct mca_coll_hierarch_llead_t));
 	if ( NULL == llead ) {
 	    return NULL;
 	}
@@ -469,7 +467,7 @@
 	llead->llcomm = llcomm;
 
 	/* Store the new element on the hierarch_module struct */
-	ompi_pointer_array_add ( &(hierarch_module->hier_llead), llead);
+	opal_pointer_array_add ( &(hierarch_module->hier_llead), llead);
     }
 
     llcomm = llead->llcomm;
@@ -552,7 +550,7 @@
     }
 
     bml_endpoints = (struct mca_bml_base_endpoint_t **) malloc ( size * 
-                     sizeof(struct mca_bml_base_endpoint_t*));
+                                                                 sizeof(struct mca_bml_base_endpoint_t*));
     if ( NULL == bml_endpoints ) {
         return;
     }
@@ -588,7 +586,7 @@
         if (! strcmp (btl->btl_version.mca_component_name, component_name)){
             counter++;
 	    if (i<firstproc ) {
-	      firstproc = i;
+                firstproc = i;
 	    }
 	    continue;
 	}	    
@@ -634,13 +632,13 @@
            rank, c->hier_comm->c_name, c->hier_comm->c_contextid);
 
     printf("%d: No of llead communicators: %d No of lleaders: %d\n", 
-	   rank, ompi_pointer_array_get_size ( &(c->hier_llead)),
+	   rank, opal_pointer_array_get_size ( &(c->hier_llead)),
 	   c->hier_num_lleaders );
 
-    for ( i=0; i < ompi_pointer_array_get_size(&(c->hier_llead)); i++ ) {
-	current = (mca_coll_hierarch_llead_t*)ompi_pointer_array_get_item (&(c->hier_llead), i);
+    for ( i=0; i < opal_pointer_array_get_size(&(c->hier_llead)); i++ ) {
+	current = (mca_coll_hierarch_llead_t*)opal_pointer_array_get_item (&(c->hier_llead), i);
 	if ( current == NULL ) {
-	  continue;
+            continue;
 	}
 
 	printf("%d:  my_leader %d am_leader %d\n", rank,
Index: ompi/mca/coll/hierarch/coll_hierarch_component.c
===================================================================
--- ompi/mca/coll/hierarch/coll_hierarch_component.c	(revision 16968)
+++ ompi/mca/coll/hierarch/coll_hierarch_component.c	(working copy)
@@ -140,7 +140,6 @@
 {
     module->hier_lcomm    = MPI_COMM_NULL;
     module->hier_reqs     = NULL;
-/*    module->hier_llead    = (ompi_pointer_array_t ) NULL; */
     module->hier_colorarr = NULL;
     module->hier_llr      = NULL;
 
@@ -161,17 +160,17 @@
     }
 
 /*    if ( NULL != hierarch_module->hier_llead ) { */
-	size = ompi_pointer_array_get_size ( &(hierarch_module->hier_llead));
+	size = opal_pointer_array_get_size ( &(hierarch_module->hier_llead));
 	for ( i=0; i<size; i++) {
-	    current = (struct mca_coll_hierarch_llead_t *)ompi_pointer_array_get_item ( 
+	    current = (struct mca_coll_hierarch_llead_t *)opal_pointer_array_get_item ( 
 		&(hierarch_module->hier_llead), i ) ;
 	    if ( current->lleaders != NULL ) {
-		ompi_comm_free ( &(current->llcomm));
-		free ( current->lleaders );
+            ompi_comm_free ( &(current->llcomm));
+            free ( current->lleaders );
 	    }
 	    free ( current );
 	}
-	ompi_pointer_array_remove_all ( &(hierarch_module->hier_llead));
+	opal_pointer_array_remove_all ( &(hierarch_module->hier_llead));
 	OBJ_DESTRUCT (&(hierarch_module->hier_llead));
 /*    } */
 
Index: ompi/mca/coll/hierarch/coll_hierarch.h
===================================================================
--- ompi/mca/coll/hierarch/coll_hierarch.h	(revision 16968)
+++ ompi/mca/coll/hierarch/coll_hierarch.h	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -57,46 +57,44 @@
 */
 
 struct mca_coll_hierarch_module_t {
-        struct mca_coll_base_module_1_1_0_t super;
+    struct mca_coll_base_module_1_1_0_t super;
 
-	struct ompi_communicator_t        *hier_comm; /* link back to the attached comm */ 
-	struct ompi_communicator_t       *hier_lcomm; /* low level communicator */
-	ompi_pointer_array_t              hier_llead; /* local leader communicator structure */
-	int                        hier_num_lleaders; /* number of local leaders */
-	int                               hier_level; /* level in the hierarchy. For debugging*/
- 	int                            hier_num_reqs; /* num. of requests */
-	ompi_request_t                   **hier_reqs; /* list of requests */
-	int                        hier_num_colorarr; /* size of the colorarr array */
-	int                                *hier_llr; /* color array compacted (1 entry per color).
-						         Array of size hier_num_lleaders */
-	int                         *hier_max_offset; /* Number of processes for each color. 
-							 Array of size hier_num_lleaders */
-	int                           *hier_colorarr; /* array containing the color of all procs */
+    struct ompi_communicator_t        *hier_comm; /* link back to the attached comm */ 
+    struct ompi_communicator_t       *hier_lcomm; /* low level communicator */
+    opal_pointer_array_t              hier_llead; /* local leader communicator structure */
+    int                        hier_num_lleaders; /* number of local leaders */
+    int                               hier_level; /* level in the hierarchy. For debugging*/
+    int                            hier_num_reqs; /* num. of requests */
+    ompi_request_t                   **hier_reqs; /* list of requests */
+    int                        hier_num_colorarr; /* size of the colorarr array */
+    int                                *hier_llr; /* color array compacted (1 entry per color).
+                                                     Array of size hier_num_lleaders */
+    int                         *hier_max_offset; /* Number of processes for each color. 
+                                                     Array of size hier_num_lleaders */
+    int                           *hier_colorarr; /* array containing the color of all procs */
 };
 typedef struct mca_coll_hierarch_module_t mca_coll_hierarch_module_t;
 OBJ_CLASS_DECLARATION(mca_coll_hierarch_module_t);
 
-
-    struct mca_coll_hierarch_llead_t {
-	struct ompi_communicator_t    *llcomm; /* local leader communicator */
-	int                         *lleaders; /* list of local leaders, ranks in comm */
-	int                        my_lleader; /* rank of my lleader in lcomm */
-	int                        am_lleader; /* am I an lleader? */
-	int                            offset; /* Offset used for this llcomm */
-    };
+struct mca_coll_hierarch_llead_t {
+    struct ompi_communicator_t    *llcomm; /* local leader communicator */
+    int                         *lleaders; /* list of local leaders, ranks in comm */
+    int                        my_lleader; /* rank of my lleader in lcomm */
+    int                        am_lleader; /* am I an lleader? */
+    int                            offset; /* Offset used for this llcomm */
+};
     
     typedef struct mca_coll_hierarch_llead_t mca_coll_hierarch_llead_t;
 
 
 static inline int mca_coll_hierarch_count_lleaders ( int size, int *carr)
 {
-
-/* 
- * Determine the number of local leaders. Please note, that any process
- * with color = MPI_UNDEFINED will be counted as the head of a group of its own.
- * Please note furthermore, that every process with color=MPI_UNDEFINED will be
- * stored in this array on its own...
- */ 
+    /* 
+     * Determine the number of local leaders. Please note, that any process
+     * with color = MPI_UNDEFINED will be counted as the head of a group of its own.
+     * Please note furthermore, that every process with color=MPI_UNDEFINED will be
+     * stored in this array on its own...
+     */ 
     int cnt, i, j, found;
     int *llr=NULL;
 
Index: ompi/peruse/peruse_module.c
===================================================================
--- ompi/peruse/peruse_module.c	(revision 16968)
+++ ompi/peruse/peruse_module.c	(working copy)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2006 High Performance Computing Center Stuttgart, 
@@ -17,9 +17,7 @@
 #include "ompi/peruse/peruse.h"
 #include "ompi/peruse/peruse-internal.h"
 #include "ompi/constants.h"
-#include "class/ompi_pointer_array.h"
 
-
 static opal_list_t peruse_handle_list;
 static opal_mutex_t peruse_handle_list_lock;
 static int ompi_peruse_initialized = 0;
Index: ompi/class/ompi_bitmap.h
===================================================================
--- ompi/class/ompi_bitmap.h	(revision 16968)
+++ ompi/class/ompi_bitmap.h	(working copy)
@@ -40,7 +40,6 @@
  * ORTE implementations.  As of this writing:
  *
  * - ompi_bitmap and orte_bitmap
- * - ompi_pointer_array and orte_pointer_array
  * - opal_value_array and orte_value_array
  *
  * Short version: 
Index: ompi/class/Makefile.am
===================================================================
--- ompi/class/Makefile.am	(revision 16968)
+++ ompi/class/Makefile.am	(working copy)
@@ -3,7 +3,7 @@
 # Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
 #                         University Research and Technology
 #                         Corporation.  All rights reserved.
-# Copyright (c) 2004-2005 The University of Tennessee and The University
+# Copyright (c) 2004-2007 The University of Tennessee and The University
 #                         of Tennessee Research Foundation.  All rights
 #                         reserved.
 # Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -24,14 +24,12 @@
         class/ompi_fifo.h \
         class/ompi_free_list.h \
         class/ompi_bitmap.h \
-        class/ompi_pointer_array.h \
-	class/ompi_rb_tree.h \
+	    class/ompi_rb_tree.h \
         class/ompi_seq_tracker.h
 
 libmpi_la_SOURCES += \
         class/ompi_bitmap.c \
         class/ompi_free_list.c \
-        class/ompi_pointer_array.c \
-	class/ompi_rb_tree.c \
+        class/ompi_rb_tree.c \
         class/ompi_seq_tracker.c
 
Index: ompi/debuggers/ompi_dll.c
===================================================================
--- ompi/debuggers/ompi_dll.c	(revision 16968)
+++ ompi/debuggers/ompi_dll.c	(working copy)
@@ -628,16 +628,16 @@
      * And now let's look at the communicator and group structures.
      */
     {
-        mqs_type* qh_type = mqs_find_type( image, "ompi_pointer_array_t", mqs_lang_c );
+        mqs_type* qh_type = mqs_find_type( image, "opal_pointer_array_t", mqs_lang_c );
         if( !qh_type ) {
-            missing_in_action = "ompi_pointer_array_t";
+            missing_in_action = "opal_pointer_array_t";
             goto type_missing;
         }
-        i_info->ompi_pointer_array_t.size = mqs_sizeof(qh_type);
-        i_info->ompi_pointer_array_t.offset.lowest_free = mqs_field_offset(qh_type, "lowest_free");
-        i_info->ompi_pointer_array_t.offset.number_free = mqs_field_offset(qh_type, "number_free");
-        i_info->ompi_pointer_array_t.offset.size = mqs_field_offset(qh_type, "size");
-        i_info->ompi_pointer_array_t.offset.addr = mqs_field_offset(qh_type, "addr");
+        i_info->opal_pointer_array_t.size = mqs_sizeof(qh_type);
+        i_info->opal_pointer_array_t.offset.lowest_free = mqs_field_offset(qh_type, "lowest_free");
+        i_info->opal_pointer_array_t.offset.number_free = mqs_field_offset(qh_type, "number_free");
+        i_info->opal_pointer_array_t.offset.size = mqs_field_offset(qh_type, "size");
+        i_info->opal_pointer_array_t.offset.addr = mqs_field_offset(qh_type, "addr");
     }
     {
         mqs_type* qh_type = mqs_find_type( image, "ompi_communicator_t", mqs_lang_c );
@@ -824,10 +824,10 @@
     mqs_tword_t lowest_free;         /* the lowest free communicator */
 
     lowest_free = fetch_int( proc,
-                             p_info->commlist_base + i_info->ompi_pointer_array_t.offset.lowest_free,
+                             p_info->commlist_base + i_info->opal_pointer_array_t.offset.lowest_free,
                              p_info );
     number_free = fetch_int( proc,
-                             p_info->commlist_base + i_info->ompi_pointer_array_t.offset.number_free,
+                             p_info->commlist_base + i_info->opal_pointer_array_t.offset.number_free,
                              p_info );
     if( (lowest_free != p_info->comm_lowest_free) ||
         (number_free != p_info->comm_number_free) ) {
@@ -889,20 +889,20 @@
     DEBUG(VERBOSE_COMM,("rebuild_communicator_list called "
                         "(commlist_base %llx, array offset %ld array size %d)\n",
                         (long long)p_info->commlist_base,
-                        (long)i_info->ompi_pointer_array_t.offset.addr,
-                        i_info->ompi_pointer_array_t.size));
+                        (long)i_info->opal_pointer_array_t.offset.addr,
+                        i_info->opal_pointer_array_t.size));
     /**
      * Start by getting the number of registered communicators in the
      * global communicator array.
      */
     comm_size = fetch_int( proc,
-                           p_info->commlist_base + i_info->ompi_pointer_array_t.offset.size,
+                           p_info->commlist_base + i_info->opal_pointer_array_t.offset.size,
                            p_info );
     lowest_free = fetch_int( proc,
-                             p_info->commlist_base + i_info->ompi_pointer_array_t.offset.lowest_free,
+                             p_info->commlist_base + i_info->opal_pointer_array_t.offset.lowest_free,
                              p_info );
     number_free = fetch_int( proc,
-                             p_info->commlist_base + i_info->ompi_pointer_array_t.offset.number_free,
+                             p_info->commlist_base + i_info->opal_pointer_array_t.offset.number_free,
                              p_info );
     p_info->comm_lowest_free = lowest_free;
     p_info->comm_number_free = number_free;
@@ -923,7 +923,7 @@
     /* Now get the pointer to the array of pointers to communicators */
     comm_addr_base =
         fetch_pointer( proc,
-                       p_info->commlist_base + i_info->ompi_pointer_array_t.offset.addr,
+                       p_info->commlist_base + i_info->opal_pointer_array_t.offset.addr,
                        p_info );
     DEBUG(VERBOSE_COMM,("Array of communicators starting at 0x%llx (sizeof(mqs_taddr_t*) = %d)\n",
                         (long long)comm_addr_base, (int)sizeof(mqs_taddr_t)));
Index: ompi/debuggers/ompi_totalview.c
===================================================================
--- ompi/debuggers/ompi_totalview.c	(revision 16968)
+++ ompi/debuggers/ompi_totalview.c	(working copy)
@@ -41,7 +41,7 @@
 #include "ompi/mca/pml/base/pml_base_request.h"
 #include "ompi/mca/pml/base/pml_base_sendreq.h"
 #include "ompi/mca/pml/base/pml_base_recvreq.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "ompi/communicator/communicator.h"
 #include "ompi/group/group.h"
 #include "ompi/datatype/datatype.h"
@@ -88,7 +88,7 @@
 OMPI_DECLSPEC mca_pml_base_request_t* mca_pml_base_request_t_type_inclusion = NULL;
 OMPI_DECLSPEC mca_pml_base_send_request_t* mca_pml_base_send_request_t_type_inclusion = NULL;
 OMPI_DECLSPEC mca_pml_base_recv_request_t* mca_pml_base_recv_request_t_type_inclusion = NULL;
-OMPI_DECLSPEC ompi_pointer_array_t* ompi_pointer_array_t_type_inclusion = NULL;
+OMPI_DECLSPEC opal_pointer_array_t* opal_pointer_array_t_type_inclusion = NULL;
 OMPI_DECLSPEC ompi_communicator_t* ompi_communicator_t_type_inclusion = NULL;
 OMPI_DECLSPEC ompi_group_t* ompi_group_t_type_inclusion = NULL;
 OMPI_DECLSPEC ompi_status_public_t* ompi_status_public_t_type_inclusion = NULL;
Index: ompi/debuggers/ompi_dll_defs.h
===================================================================
--- ompi/debuggers/ompi_dll_defs.h	(revision 16968)
+++ ompi/debuggers/ompi_dll_defs.h	(working copy)
@@ -139,7 +139,7 @@
             int size;
             int addr;
         } offset;
-    } ompi_pointer_array_t;
+    } opal_pointer_array_t;
     struct {
         int size;
         struct {
Index: ompi/datatype/dt_module.c
===================================================================
--- ompi/datatype/dt_module.c	(revision 16968)
+++ ompi/datatype/dt_module.c	(working copy)
@@ -283,7 +283,7 @@
     &ompi_mpi_unavailable
 };
 
-ompi_pointer_array_t *ompi_datatype_f_to_c_table = NULL;
+opal_pointer_array_t ompi_datatype_f_to_c_table;
 
 size_t ompi_ddt_local_sizes[DT_MAX_PREDEFINED];
 
@@ -430,8 +430,9 @@
     }
 
     /* Create the f2c translation table */
-    ompi_datatype_f_to_c_table = OBJ_NEW(ompi_pointer_array_t);
-    if (NULL == ompi_datatype_f_to_c_table) {
+    OBJ_CONSTRUCT(&ompi_datatype_f_to_c_table, opal_pointer_array_t);
+    if( OPAL_SUCCESS != opal_pointer_array_init(&ompi_datatype_f_to_c_table,
+                                                0, OMPI_FORTRAN_HANDLE_MAX, 64)) {
         return OMPI_ERROR;
     }
     /* All temporary datatypes created on the following statement will get registered
@@ -647,12 +648,12 @@
     /* This macro makes everything significantly easier to read below.
        All hail the moog!  :-) */
 
-#define MOOG(name)                                                      \
-    {                                                                   \
-        ompi_mpi_##name.d_f_to_c_index =                                \
-            ompi_pointer_array_add(ompi_datatype_f_to_c_table, &ompi_mpi_##name); \
+#define MOOG(name)                                                                  \
+    {                                                                               \
+        ompi_mpi_##name.d_f_to_c_index =                                            \
+            opal_pointer_array_add(&ompi_datatype_f_to_c_table, &ompi_mpi_##name);  \
         if( ompi_ddt_number_of_predefined_data < (ompi_mpi_##name).d_f_to_c_index ) \
-            ompi_ddt_number_of_predefined_data = (ompi_mpi_##name).d_f_to_c_index; \
+            ompi_ddt_number_of_predefined_data = (ompi_mpi_##name).d_f_to_c_index;  \
     }
 
     /*
@@ -723,7 +724,7 @@
     MOOG(cxx_ldblcplex);
 
     for( i = 0; i < ompi_mpi_cxx_ldblcplex.d_f_to_c_index; i++ ) {
-        ompi_datatype_t* datatype = (ompi_datatype_t*)ompi_pointer_array_get_item( ompi_datatype_f_to_c_table, i );
+        ompi_datatype_t* datatype = (ompi_datatype_t*)opal_pointer_array_get_item(&ompi_datatype_f_to_c_table, i );
 
         if( (datatype->ub - datatype->lb) == (ptrdiff_t)datatype->size ) {
             datatype->flags |= DT_FLAG_NO_GAPS;
@@ -752,7 +753,7 @@
     }
 
     /* Get rid of the Fortran2C translation table */
-    OBJ_RELEASE(ompi_datatype_f_to_c_table);
+    OBJ_DESTRUCT(&ompi_datatype_f_to_c_table);
 
 #if defined(VERBOSE)
     if( ompi_ddt_dfd != -1 )
Index: ompi/datatype/dt_match_size.c
===================================================================
--- ompi/datatype/dt_match_size.c	(revision 16968)
+++ ompi/datatype/dt_match_size.c	(working copy)
@@ -37,7 +37,7 @@
 
     for( i = 0; i < ompi_ddt_number_of_predefined_data; i++ ) {
 
-        datatype = (ompi_datatype_t*)ompi_pointer_array_get_item(ompi_datatype_f_to_c_table, i);
+        datatype = (ompi_datatype_t*)opal_pointer_array_get_item(&ompi_datatype_f_to_c_table, i);
 
         if( (datatype->flags & DT_FLAG_DATA_LANGUAGE) != datalang )
             continue;
Index: ompi/datatype/datatype.h
===================================================================
--- ompi/datatype/datatype.h	(revision 16968)
+++ ompi/datatype/datatype.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2006 High Performance Computing Center Stuttgart,
@@ -42,12 +42,12 @@
 #include "ompi/constants.h"
 #include "opal/class/opal_object.h"
 #include "opal/class/opal_hash_table.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "mpi.h"
 
 BEGIN_C_DECLS
 
-extern ompi_pointer_array_t *ompi_datatype_f_to_c_table;
+extern struct opal_pointer_array_t ompi_datatype_f_to_c_table;
 
 /* if there are more basic datatypes than the number of bytes in the int type
  * the bdt_used field of the data description struct should be changed to long.
Index: ompi/datatype/dt_create.c
===================================================================
--- ompi/datatype/dt_create.c	(revision 16968)
+++ ompi/datatype/dt_create.c	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2006 High Performance Computing Center Stuttgart,
@@ -22,6 +22,7 @@
 #include "ompi/datatype/datatype_internal.h"
 #include "limits.h"
 #include "ompi/attribute/attribute.h"
+#include "opal/class/opal_pointer_array.h"
 
 static void __get_free_dt_struct( ompi_datatype_t* pData )
 {
@@ -45,7 +46,7 @@
     pData->true_ub            = LONG_MIN;
     pData->lb                 = LONG_MAX;
     pData->ub                 = LONG_MIN;
-    pData->d_f_to_c_index     = ompi_pointer_array_add(ompi_datatype_f_to_c_table, pData);
+    pData->d_f_to_c_index     = opal_pointer_array_add(&ompi_datatype_f_to_c_table, pData);
     pData->d_keyhash          = NULL;
     pData->name[0]            = '\0';
     pData->packed_description = NULL;
@@ -80,8 +81,8 @@
         free( datatype->packed_description );
         datatype->packed_description = NULL;
     }
-    if( NULL != ompi_pointer_array_get_item(ompi_datatype_f_to_c_table, datatype->d_f_to_c_index) ){
-        ompi_pointer_array_set_item( ompi_datatype_f_to_c_table, datatype->d_f_to_c_index, NULL );
+    if( NULL != opal_pointer_array_get_item(&ompi_datatype_f_to_c_table, datatype->d_f_to_c_index) ){
+        opal_pointer_array_set_item( &ompi_datatype_f_to_c_table, datatype->d_f_to_c_index, NULL );
     }
     /* any pending attributes ? */
     if (NULL != datatype->d_keyhash) {
Index: ompi/op/op.c
===================================================================
--- ompi/op/op.c	(revision 16968)
+++ ompi/op/op.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2007 High Performance Computing Center Stuttgart, 
@@ -22,14 +22,14 @@
 #include "ompi/constants.h"
 #include "ompi/op/op.h"
 #include "ompi/op/op_predefined.h"
-#include "ompi/class/ompi_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "ompi/datatype/datatype_internal.h"
 
 
 /*
  * Table for Fortran <-> C op handle conversion
  */
-ompi_pointer_array_t *ompi_op_f_to_c_table;
+opal_pointer_array_t *ompi_op_f_to_c_table;
 
 
 /*
@@ -606,7 +606,7 @@
 
   /* initialize ompi_op_f_to_c_table */
 
-    ompi_op_f_to_c_table = OBJ_NEW(ompi_pointer_array_t);
+    ompi_op_f_to_c_table = OBJ_NEW(opal_pointer_array_t);
     if (NULL == ompi_op_f_to_c_table){
         return OMPI_ERROR;
     }
@@ -789,7 +789,7 @@
 
     /* assign entry in fortran <-> c translation array */
 
-    ret_val = ompi_pointer_array_add(ompi_op_f_to_c_table, new_op);
+    ret_val = opal_pointer_array_add(ompi_op_f_to_c_table, new_op);
     new_op->o_f_to_c_index = ret_val;
 }
 
@@ -802,9 +802,9 @@
     /* reset the ompi_op_f_to_c_table entry - make sure that the
        entry is in the table */
 
-    if (NULL != ompi_pointer_array_get_item(ompi_op_f_to_c_table,
+    if (NULL != opal_pointer_array_get_item(ompi_op_f_to_c_table,
                                             op->o_f_to_c_index)) {
-        ompi_pointer_array_set_item(ompi_op_f_to_c_table,
+        opal_pointer_array_set_item(ompi_op_f_to_c_table,
                                     op->o_f_to_c_index, NULL);
     }
 }
Index: ompi/op/op.h
===================================================================
--- ompi/op/op.h	(revision 16968)
+++ ompi/op/op.h	(working copy)
@@ -373,65 +373,65 @@
 /**
  * Table for Fortran <-> C op handle conversion
  */
-extern struct ompi_pointer_array_t *ompi_op_f_to_c_table;
+extern struct opal_pointer_array_t *ompi_op_f_to_c_table;
 
-  /**
-   * Initialize the op interface.
-   *
-   * @returns OMPI_SUCCESS Upon success
-   * @returns OMPI_ERROR Otherwise
-   *
-   * Invoked from ompi_mpi_init(); sets up the op interface, creates
-   * the predefined MPI operations, and creates the corresopnding F2C
-   * translation table.
-   */
-  int ompi_op_init(void);
+/**
+ * Initialize the op interface.
+ *
+ * @returns OMPI_SUCCESS Upon success
+ * @returns OMPI_ERROR Otherwise
+ *
+ * Invoked from ompi_mpi_init(); sets up the op interface, creates
+ * the predefined MPI operations, and creates the corresopnding F2C
+ * translation table.
+ */
+int ompi_op_init(void);
 
-  /**
-   * Finalize the op interface.
-   *
-   * @returns OMPI_SUCCESS Always
-   *
-   * Invokes from ompi_mpi_finalize(); tears down the op interface, and
-   * destroys the F2C translation table.
-   */
-  int ompi_op_finalize(void);
+/**
+ * Finalize the op interface.
+ *
+ * @returns OMPI_SUCCESS Always
+ *
+ * Invokes from ompi_mpi_finalize(); tears down the op interface, and
+ * destroys the F2C translation table.
+ */
+int ompi_op_finalize(void);
 
-  /**
-   * Create a ompi_op_t
-   *
-   * @param commute Boolean indicating whether the operation is
-   *        communative or not
-   * @param func Function pointer of the error handler
-   *
-   * @returns op Pointer to the ompi_op_t that will be
-   *   created and returned
-   *
-   * This function is called as the back-end of all the MPI_OP_CREATE
-   * functions.  It creates a new ompi_op_t object, initializes it to
-   * the correct object type, and sets the callback function on it.
-   *
-   * The type of the function pointer is (arbitrarily) the fortran
-   * function handler type.  Since this function has to accept 2
-   * different function pointer types (lest we have 2 different
-   * functions to create errhandlers), the fortran one was picked
-   * arbitrarily.  Note that (void*) is not sufficient because at
-   * least theoretically, a sizeof(void*) may not necessarily be the
-   * same as sizeof(void(*)).
-   *
-   * NOTE: It *always* sets the "fortran" flag to false.  The Fortran
-   * wrapper for MPI_OP_CREATE is expected to reset this flag to true
-   * manually.
-   */
-  ompi_op_t *ompi_op_create(bool commute, ompi_op_fortran_handler_fn_t *func);
+/**
+ * Create a ompi_op_t
+ *
+ * @param commute Boolean indicating whether the operation is
+ *        communative or not
+ * @param func Function pointer of the error handler
+ *
+ * @returns op Pointer to the ompi_op_t that will be
+ *   created and returned
+ *
+ * This function is called as the back-end of all the MPI_OP_CREATE
+ * functions.  It creates a new ompi_op_t object, initializes it to
+ * the correct object type, and sets the callback function on it.
+ *
+ * The type of the function pointer is (arbitrarily) the fortran
+ * function handler type.  Since this function has to accept 2
+ * different function pointer types (lest we have 2 different
+ * functions to create errhandlers), the fortran one was picked
+ * arbitrarily.  Note that (void*) is not sufficient because at
+ * least theoretically, a sizeof(void*) may not necessarily be the
+ * same as sizeof(void(*)).
+ *
+ * NOTE: It *always* sets the "fortran" flag to false.  The Fortran
+ * wrapper for MPI_OP_CREATE is expected to reset this flag to true
+ * manually.
+ */
+ompi_op_t *ompi_op_create(bool commute, ompi_op_fortran_handler_fn_t *func);
 
-  /**
-   * Mark an MPI_Op as holding a C++ callback function, and cache
-   * that function in the MPI_Op.  See a lenghty comment in
-   * ompi/mpi/cxx/op.c::ompi_mpi_cxx_op_intercept() for a full
-   * expalantion.
-   */
-  OMPI_DECLSPEC void ompi_op_set_cxx_callback(ompi_op_t *op, MPI_User_function *fn);
+/**
+ * Mark an MPI_Op as holding a C++ callback function, and cache
+ * that function in the MPI_Op.  See a lenghty comment in
+ * ompi/mpi/cxx/op.c::ompi_mpi_cxx_op_intercept() for a full
+ * expalantion.
+ */
+OMPI_DECLSPEC void ompi_op_set_cxx_callback(ompi_op_t *op, MPI_User_function *fn);
 
 /**
  * Check to see if an op is intrinsic.
Index: orte/test/unit/gpr/gpr_dt_cmp.c
===================================================================
--- orte/test/unit/gpr/gpr_dt_cmp.c	(revision 16968)
+++ orte/test/unit/gpr/gpr_dt_cmp.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -33,7 +33,7 @@
 #include "opal/util/malloc.h"
 #include "opal/util/output.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/util/proc_info.h"
 #include "orte/mca/errmgr/errmgr.h"
@@ -523,7 +523,7 @@
             } /* if keyvals */
 
             /* add the value to the data object */
-            orte_pointer_array_add(&k, src[i]->values, value);
+            opal_pointer_array_add(src[i]->values, value);
         } /* for each value */
     }
 
Index: orte/test/unit/gpr/gpr_dt_release.c
===================================================================
--- orte/test/unit/gpr/gpr_dt_release.c	(revision 16968)
+++ orte/test/unit/gpr/gpr_dt_release.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -33,7 +33,7 @@
 #include "opal/util/malloc.h"
 #include "opal/util/output.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/util/proc_info.h"
 #include "orte/mca/errmgr/errmgr.h"
@@ -535,7 +535,7 @@
             } /* if keyvals */
 
             /* add the value to the data object */
-            orte_pointer_array_add(&k, src[i]->values, value);
+            opal_pointer_array_add(src[i]->values, value);
         } /* for each value */
     }
 
Index: orte/test/unit/gpr/gpr_dt_buffer.c
===================================================================
--- orte/test/unit/gpr/gpr_dt_buffer.c	(revision 16968)
+++ orte/test/unit/gpr/gpr_dt_buffer.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -33,7 +33,7 @@
 #include "opal/util/malloc.h"
 #include "opal/util/output.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/util/proc_info.h"
 #include "orte/mca/errmgr/errmgr.h"
@@ -813,7 +813,7 @@
             } /* if keyvals */
 
             /* add the value to the data object */
-            orte_pointer_array_add(&k, src[i]->values, value);
+            opal_pointer_array_add(src[i]->values, value);
         } /* for each value */
     }
 
Index: orte/test/unit/gpr/gpr_dt_copy.c
===================================================================
--- orte/test/unit/gpr/gpr_dt_copy.c	(revision 16968)
+++ orte/test/unit/gpr/gpr_dt_copy.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -33,7 +33,7 @@
 #include "opal/util/malloc.h"
 #include "opal/util/output.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/util/proc_info.h"
 #include "orte/mca/errmgr/errmgr.h"
@@ -735,7 +735,7 @@
             } /* if keyvals */
 
             /* add the value to the data object */
-            orte_pointer_array_add(&k, src[i]->values, value);
+            opal_pointer_array_add(src[i]->values, value);
         } /* for each value */
     }
 
Index: orte/test/unit/gpr/gpr_dt_size.c
===================================================================
--- orte/test/unit/gpr/gpr_dt_size.c	(revision 16968)
+++ orte/test/unit/gpr/gpr_dt_size.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -33,7 +33,7 @@
 #include "opal/util/malloc.h"
 #include "opal/util/output.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/util/proc_info.h"
 #include "orte/mca/errmgr/errmgr.h"
@@ -613,7 +613,7 @@
             } /* if keyvals */
 
             /* add the value to the data object */
-            orte_pointer_array_add(&k, src[i]->values, value);
+            opal_pointer_array_add(src[i]->values, value);
         } /* for each value */
     }
 
Index: orte/test/unit/gpr/gpr_dt_print.c
===================================================================
--- orte/test/unit/gpr/gpr_dt_print.c	(revision 16968)
+++ orte/test/unit/gpr/gpr_dt_print.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -33,7 +33,7 @@
 #include "opal/util/malloc.h"
 #include "opal/util/output.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/util/proc_info.h"
 #include "orte/mca/errmgr/errmgr.h"
@@ -530,7 +530,7 @@
             } /* if keyvals */
 
             /* add the value to the data object */
-            orte_pointer_array_add(&k, src[i]->values, value);
+            opal_pointer_array_add(src[i]->values, value);
         } /* for each value */
     }
 
@@ -611,11 +611,11 @@
             } /* if keyvals */
 
             /* add the value to the data object */
-            orte_pointer_array_add(&k, src[i]->values, value);
+            k = opal_pointer_array_add(src[i]->values, value);
         } /* for each value */
         
         /* add the data object to the pointer array */
-        orte_pointer_array_add(&i, msg->data, src[i]);
+        i = opal_pointer_array_add(msg->data, src[i]);
     } /* for each data */
     
        if (ORTE_SUCCESS != orte_dss.print(&output, NULL, msg, ORTE_GPR_NOTIFY_MSG)) {
Index: orte/mca/ns/replica/ns_replica_class_instances.h
===================================================================
--- orte/mca/ns/replica/ns_replica_class_instances.h	(revision 16968)
+++ orte/mca/ns/replica/ns_replica_class_instances.h	(working copy)
@@ -3,7 +3,7 @@
 * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
 *                         University Research and Technology
 *                         Corporation.  All rights reserved.
-* Copyright (c) 2004-2006 The University of Tennessee and The University
+* Copyright (c) 2004-2007 The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -25,7 +25,6 @@
 #include "orte/orte_constants.h"
 #include "opal/threads/mutex.h"
 #include "opal/class/opal_object.h"
-#include "orte/class/orte_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/mca/oob/oob_types.h"
 #include "orte/mca/ns/base/base.h"
Index: orte/mca/ns/replica/ns_replica_component.c
===================================================================
--- orte/mca/ns/replica/ns_replica_component.c	(revision 16968)
+++ orte/mca/ns/replica/ns_replica_component.c	(working copy)
@@ -3,7 +3,7 @@
 * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
 *                         University Research and Technology
 *                         Corporation.  All rights reserved.
-* Copyright (c) 2004-2005 The University of Tennessee and The University
+* Copyright (c) 2004-2007 The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -189,10 +189,11 @@
         *priority = 50;
         
         /* initialize the node tracker */
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_ns_replica.nodenames),
-                                                          (orte_std_cntr_t)orte_ns_replica.block_size,
-                                                          (orte_std_cntr_t)orte_ns_replica.max_size,
-                                                          (orte_std_cntr_t)orte_ns_replica.block_size))) {
+        orte_ns_replica.nodenames = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_ns_replica.nodenames,
+                                                          orte_ns_replica.block_size,
+                                                          orte_ns_replica.max_size,
+                                                          orte_ns_replica.block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
@@ -204,10 +205,11 @@
         
         /* initialize the taglist */
         
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_ns_replica.tags),
-                                                          (orte_std_cntr_t)orte_ns_replica.block_size,
-                                                          (orte_std_cntr_t)orte_ns_replica.max_size,
-                                                          (orte_std_cntr_t)orte_ns_replica.block_size))) {
+        orte_ns_replica.tags = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_ns_replica.tags,
+                                                          orte_ns_replica.block_size,
+                                                          orte_ns_replica.max_size,
+                                                          orte_ns_replica.block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
@@ -215,10 +217,11 @@
         
         /* initialize the dtlist */
         
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_ns_replica.dts),
-                                                          (orte_std_cntr_t)orte_ns_replica.block_size,
-                                                          (orte_std_cntr_t)orte_ns_replica.max_size,
-                                                          (orte_std_cntr_t)orte_ns_replica.block_size))) {
+        orte_ns_replica.dts = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_ns_replica.dts,
+                                                          orte_ns_replica.block_size,
+                                                          orte_ns_replica.max_size,
+                                                          orte_ns_replica.block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
Index: orte/mca/ns/replica/ns_replica_general_fns.c
===================================================================
--- orte/mca/ns/replica/ns_replica_general_fns.c	(revision 16968)
+++ orte/mca/ns/replica/ns_replica_general_fns.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -217,7 +217,6 @@
     orte_ns_replica_tagitem_t *tagitem, **tags;
     orte_std_cntr_t i;
     orte_rml_tag_t j;
-    int rc;
 
     OPAL_THREAD_LOCK(&orte_ns_replica.mutex);
 
@@ -259,11 +258,10 @@
         OPAL_THREAD_UNLOCK(&orte_ns_replica.mutex);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
-    if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&i,
-                                orte_ns_replica.tags, tagitem))) {
-        ORTE_ERROR_LOG(rc);
+    if( 0 > opal_pointer_array_add(orte_ns_replica.tags, tagitem) ) {
+        ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OPAL_THREAD_UNLOCK(&orte_ns_replica.mutex);
-        return rc;
+        return ORTE_ERR_OUT_OF_RESOURCE;
     }
     tagitem->tag = orte_ns_replica.num_tags + ORTE_RML_TAG_DYNAMIC;
     (orte_ns_replica.num_tags)++;
@@ -287,7 +285,6 @@
 {
     orte_ns_replica_dti_t **dti, *dtip;
     orte_std_cntr_t i, j;
-    int rc;
 
     if (NULL == name || 0 < *type) {
         ORTE_ERROR_LOG(ORTE_ERR_BAD_PARAM);
@@ -330,11 +327,10 @@
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
     dtip->name = strdup(name);
-    if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&i,
-                                orte_ns_replica.dts, dtip))) {
-        ORTE_ERROR_LOG(rc);
+    if( 0 > opal_pointer_array_add(orte_ns_replica.dts, dtip) ) {
+        ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OPAL_THREAD_UNLOCK(&orte_ns_replica.mutex);
-        return rc;
+        return ORTE_ERR_OUT_OF_RESOURCE;
     }
     dtip->id = orte_ns_replica.num_dts;
     (orte_ns_replica.num_dts)++;
Index: orte/mca/ns/replica/ns_replica.h
===================================================================
--- orte/mca/ns/replica/ns_replica.h	(revision 16968)
+++ orte/mca/ns/replica/ns_replica.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -25,7 +25,7 @@
 #include "orte/orte_constants.h"
 #include "opal/threads/mutex.h"
 #include "opal/class/opal_object.h"
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/mca/oob/oob_types.h"
 #include "orte/mca/ns/base/base.h"
@@ -82,12 +82,12 @@
 typedef struct {
     size_t max_size, block_size;
     orte_nodeid_t next_nodeid;
-    orte_pointer_array_t *nodenames;
+    opal_pointer_array_t *nodenames;
     orte_jobid_t num_jobids;
     opal_list_t jobs;
-    orte_pointer_array_t *tags;
+    opal_pointer_array_t *tags;
     orte_rml_tag_t num_tags;
-    orte_pointer_array_t *dts;
+    opal_pointer_array_t *dts;
     orte_data_type_t num_dts;
     int debug;
     bool isolate;
Index: orte/mca/ns/proxy/ns_proxy_component.c
===================================================================
--- orte/mca/ns/proxy/ns_proxy_component.c	(revision 16968)
+++ orte/mca/ns/proxy/ns_proxy_component.c	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -226,11 +226,10 @@
            }
 
           /* initialize the taglist */
-
-          if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_ns_proxy.tags),
-                                    (orte_std_cntr_t)orte_ns_proxy.block_size,
-                                    (orte_std_cntr_t)orte_ns_proxy.max_size,
-                                    (orte_std_cntr_t)orte_ns_proxy.block_size))) {
+          orte_ns_proxy.tags = OBJ_NEW(opal_pointer_array_t);
+          if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_ns_proxy.tags,
+                                    orte_ns_proxy.block_size, orte_ns_proxy.max_size,
+                                    orte_ns_proxy.block_size))) {
                 ORTE_ERROR_LOG(rc);
                 return NULL;
             }
@@ -238,10 +237,10 @@
 
           /* initialize the dtlist */
 
-          if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_ns_proxy.dts),
-                                    (orte_std_cntr_t)orte_ns_proxy.block_size,
-                                    (orte_std_cntr_t)orte_ns_proxy.max_size,
-                                    (orte_std_cntr_t)orte_ns_proxy.block_size))) {
+          orte_ns_proxy.dts = OBJ_NEW(opal_pointer_array_t);
+          if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_ns_proxy.dts,
+                                    orte_ns_proxy.block_size, orte_ns_proxy.max_size,
+                                    orte_ns_proxy.block_size))) {
                 ORTE_ERROR_LOG(rc);
                 return NULL;
             }
Index: orte/mca/ns/proxy/ns_proxy_general_fns.c
===================================================================
--- orte/mca/ns/proxy/ns_proxy_general_fns.c	(revision 16968)
+++ orte/mca/ns/proxy/ns_proxy_general_fns.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2006 High Performance Computing Center Stuttgart,
@@ -286,11 +286,10 @@
         OPAL_THREAD_UNLOCK(&orte_ns_proxy.mutex);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
-    if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&i,
-                                orte_ns_proxy.tags, tagitem))) {
-        ORTE_ERROR_LOG(rc);
+    if( 0 > opal_pointer_array_add(orte_ns_proxy.tags, tagitem)) {
+        ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OPAL_THREAD_UNLOCK(&orte_ns_proxy.mutex);
-        return rc;
+        return ORTE_ERR_OUT_OF_RESOURCE;
     }
     tagitem->tag = *tag;
     (orte_ns_proxy.num_tags)++;
@@ -418,11 +417,10 @@
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
     dtip->name = strdup(name);
-    if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&i,
-                                orte_ns_proxy.dts, dtip))) {
-        ORTE_ERROR_LOG(rc);
+    if( 0 > opal_pointer_array_add(orte_ns_proxy.dts, dtip)) {
+        ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OPAL_THREAD_UNLOCK(&orte_ns_proxy.mutex);
-        return rc;
+        return ORTE_ERR_OUT_OF_RESOURCE;
     }
     dtip->id = *type;
     (orte_ns_proxy.num_dts)++;
Index: orte/mca/ns/proxy/ns_proxy.h
===================================================================
--- orte/mca/ns/proxy/ns_proxy.h	(revision 16968)
+++ orte/mca/ns/proxy/ns_proxy.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -75,9 +75,9 @@
 typedef struct {
     size_t max_size, block_size;
     int debug;
-    orte_pointer_array_t *tags;
+    opal_pointer_array_t *tags;
     orte_rml_tag_t num_tags;
-    orte_pointer_array_t *dts;
+    opal_pointer_array_t *dts;
     orte_data_type_t num_dts;
     opal_mutex_t mutex;
 } orte_ns_proxy_globals_t;
Index: orte/mca/rmaps/base/data_type_support/rmaps_data_type_copy_fns.c
===================================================================
--- orte/mca/rmaps/base/data_type_support/rmaps_data_type_copy_fns.c	(revision 16968)
+++ orte/mca/rmaps/base/data_type_support/rmaps_data_type_copy_fns.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -22,6 +22,9 @@
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
+#if HAVE_STRING_H
+#include <string.h>
+#endif
 
 #include "opal/util/argv.h"
 #include "opal/class/opal_list.h"
Index: orte/mca/rmaps/base/data_type_support/rmaps_data_type_size_fns.c
===================================================================
--- orte/mca/rmaps/base/data_type_support/rmaps_data_type_size_fns.c	(revision 16968)
+++ orte/mca/rmaps/base/data_type_support/rmaps_data_type_size_fns.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -20,6 +20,9 @@
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
+#if HAVE_STRING_H
+#include <string.h>
+#endif
 
 #include "opal/util/argv.h"
 #include "opal/class/opal_list.h"
Index: orte/mca/ras/localhost/ras_localhost_module.c
===================================================================
--- orte/mca/ras/localhost/ras_localhost_module.c	(revision 16968)
+++ orte/mca/ras/localhost/ras_localhost_module.c	(working copy)
@@ -32,6 +32,9 @@
 
 #include "orte/mca/ras/localhost/ras_localhost.h"
 
+#if HAVE_STRING_H
+#include <string.h>
+#endif
 
 /*
  * Local functions
Index: orte/mca/ras/dash_host/ras_dash_host_module.c
===================================================================
--- orte/mca/ras/dash_host/ras_dash_host_module.c	(revision 16968)
+++ orte/mca/ras/dash_host/ras_dash_host_module.c	(working copy)
@@ -31,6 +31,9 @@
 #include "orte/mca/ras/base/ras_private.h"
 #include "orte/mca/ras/dash_host/ras_dash_host.h"
 
+#if HAVE_STRING_H
+#include <string.h>
+#endif
 
 /*
  * Local functions
Index: orte/mca/gpr/replica/api_layer/gpr_replica_segment_ops_api.c
===================================================================
--- orte/mca/gpr/replica/api_layer/gpr_replica_segment_ops_api.c	(revision 16968)
+++ orte/mca/gpr/replica/api_layer/gpr_replica_segment_ops_api.c	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -30,7 +30,7 @@
 #include "orte/orte_constants.h"
 #include "opal/util/trace.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/mca/errmgr/errmgr.h"
 
 #include "gpr_replica_api.h"
@@ -51,7 +51,7 @@
         return rc;
     }
 
-    rc = orte_pointer_array_set_size(seg->containers, num_slots);
+    rc = opal_pointer_array_set_size(seg->containers, num_slots);
 
     OPAL_THREAD_UNLOCK(&orte_gpr_replica_globals.mutex);
 
Index: orte/mca/gpr/replica/api_layer/gpr_replica_api.h
===================================================================
--- orte/mca/gpr/replica/api_layer/gpr_replica_api.h	(revision 16968)
+++ orte/mca/gpr/replica/api_layer/gpr_replica_api.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -28,8 +28,6 @@
 
 #include <time.h>
 
-#include "orte/class/orte_pointer_array.h"
-
 #include "opal/threads/mutex.h"
 #include "opal/threads/condition.h"
 
Index: orte/mca/gpr/replica/transition_layer/gpr_replica_segment_tl.c
===================================================================
--- orte/mca/gpr/replica/transition_layer/gpr_replica_segment_tl.c	(revision 16968)
+++ orte/mca/gpr/replica/transition_layer/gpr_replica_segment_tl.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -34,7 +34,6 @@
 int orte_gpr_replica_find_seg(orte_gpr_replica_segment_t **seg,
                               bool create, char *segment)
 {
-    int rc=ORTE_SUCCESS;
     orte_std_cntr_t i, cntri;
     orte_gpr_replica_segment_t **ptr;
 
@@ -74,11 +73,11 @@
     /* add the segment to the registry */
     *seg = OBJ_NEW(orte_gpr_replica_segment_t);
     (*seg)->name = strdup(segment);
-    if (0 > orte_pointer_array_add(&i, orte_gpr_replica.segments, (void*)(*seg))) {
+    (*seg)->itag = opal_pointer_array_add(orte_gpr_replica.segments, (void*)(*seg));
+    if( 0 > (*seg)->itag ) {
         OBJ_RELEASE(*seg);
-        return rc;
+        return ORTE_ERR_OUT_OF_RESOURCE;
     }
-    (*seg)->itag = i;
     (orte_gpr_replica.num_segs)++;
     
     return ORTE_SUCCESS;
Index: orte/mca/gpr/replica/transition_layer/gpr_replica_dict_tl.c
===================================================================
--- orte/mca/gpr/replica/transition_layer/gpr_replica_dict_tl.c	(revision 16968)
+++ orte/mca/gpr/replica/transition_layer/gpr_replica_dict_tl.c	(working copy)
@@ -31,7 +31,7 @@
 #include "opal/util/output.h"
 #include "opal/util/trace.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/mca/errmgr/errmgr.h"
 #include "orte/mca/gpr/replica/gpr_replica.h"
 #include "orte/mca/gpr/replica/functional_layer/gpr_replica_fn.h"
@@ -42,9 +42,8 @@
                              orte_gpr_replica_segment_t *seg, char *name)
 {
     orte_gpr_replica_dict_entry_t* new_dict;
-    orte_std_cntr_t index;
     uint32_t len, hash_key;
-    int rc;
+    int rc, index;
 
     OPAL_TRACE(3);
 
@@ -70,7 +69,8 @@
     strncpy( new_dict->string, name, len );
     new_dict->string[len] = '\0';
 
-    if (0 > orte_pointer_array_add(&index, seg->dict, (void*)new_dict)) {
+    index = opal_pointer_array_add(seg->dict, (void*)new_dict);
+    if (0 > index ) {
         free(new_dict);
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
@@ -85,7 +85,7 @@
     /* otherwise, the itag violates the max value */
     free(new_dict);
     /* remove itag from segment dictionary */
-    orte_pointer_array_set_item(seg->dict, (orte_std_cntr_t)index, NULL);
+    opal_pointer_array_set_item(seg->dict, index, NULL);
     
     return ORTE_ERR_OUT_OF_RESOURCE;
 }
@@ -128,7 +128,7 @@
     free(ptr[itag]);
      
     /* remove itag from segment dictionary */
-    orte_pointer_array_set_item(seg->dict, (orte_std_cntr_t)itag, NULL);
+    opal_pointer_array_set_item(seg->dict, itag, NULL);
     
     /* decrease the dict counter */
     (seg->num_dict_entries)--;
Index: orte/mca/gpr/replica/communications/gpr_replica_comm.h
===================================================================
--- orte/mca/gpr/replica/communications/gpr_replica_comm.h	(revision 16968)
+++ orte/mca/gpr/replica/communications/gpr_replica_comm.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -28,8 +28,6 @@
 
 #include <time.h>
 
-#include "orte/class/orte_pointer_array.h"
-
 #include "opal/threads/mutex.h"
 #include "opal/threads/condition.h"
 
Index: orte/mca/gpr/replica/gpr_replica_class_instances.h
===================================================================
--- orte/mca/gpr/replica/gpr_replica_class_instances.h	(revision 16968)
+++ orte/mca/gpr/replica/gpr_replica_class_instances.h	(working copy)
@@ -81,12 +81,14 @@
     seg->itag = ORTE_GPR_REPLICA_ITAG_MAX;
 
     seg->num_dict_entries = 0;
-    orte_pointer_array_init(&(seg->dict), (orte_std_cntr_t)orte_gpr_array_block_size,
+    seg->dict = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(seg->dict, (orte_std_cntr_t)orte_gpr_array_block_size,
                             (orte_std_cntr_t)orte_gpr_array_max_size,
                             (orte_std_cntr_t)orte_gpr_array_block_size);
 
     seg->num_containers = 0;
-    orte_pointer_array_init(&(seg->containers), (orte_std_cntr_t)orte_gpr_array_block_size,
+    seg->containers = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(seg->containers, (orte_std_cntr_t)orte_gpr_array_block_size,
                             (orte_std_cntr_t)orte_gpr_array_max_size,
                             (orte_std_cntr_t)orte_gpr_array_block_size);
 
@@ -145,9 +147,9 @@
     reg->itags = NULL;
     reg->num_itags = 0;
 
-    orte_pointer_array_init(&(reg->itagvals), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    reg->itagvals = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(reg->itagvals, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size, orte_gpr_array_block_size);
     reg->num_itagvals = 0;
 
     OBJ_CONSTRUCT(&(reg->itaglist), orte_value_array_t);
@@ -303,14 +305,14 @@
     sub->action = ORTE_GPR_REPLICA_NO_ACTION;
 
     sub->num_values = 0;
-    orte_pointer_array_init(&(sub->values), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    sub->values = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(sub->values, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size, orte_gpr_array_block_size);
 
     sub->num_requestors = 0;
-    orte_pointer_array_init(&(sub->requestors), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    sub->requestors = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(sub->requestors, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size, orte_gpr_array_block_size);
 }
 
 /* destructor - used to free any resources held by instance */
@@ -388,9 +390,9 @@
     trig->idtag = ORTE_GPR_TRIGGER_ID_MAX;
 
     trig->num_attached = 0;
-    orte_pointer_array_init(&(trig->attached), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    trig->attached = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(trig->attached, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size, orte_gpr_array_block_size);
 
     trig->master = NULL;;
 
@@ -399,14 +401,15 @@
     trig->processing = false;
 
     trig->num_counters = 0;
-    orte_pointer_array_init(&(trig->counters), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    trig->counters = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(trig->counters, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size,
+                            orte_gpr_array_block_size);
 
     trig->num_subscriptions = 0;
-    orte_pointer_array_init(&(trig->subscriptions), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    trig->subscriptions = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(trig->subscriptions, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size, orte_gpr_array_block_size);
 
 }
 
Index: orte/mca/gpr/replica/gpr_replica_component.c
===================================================================
--- orte/mca/gpr/replica/gpr_replica_component.c	(revision 16968)
+++ orte/mca/gpr/replica/gpr_replica_component.c	(working copy)
@@ -215,28 +215,28 @@
         OBJ_CONSTRUCT(&orte_gpr_replica_globals.mutex, opal_mutex_t);
 
         /* initialize the registry head */
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica.segments),
-                                (orte_std_cntr_t)orte_gpr_array_block_size,
-                                (orte_std_cntr_t)orte_gpr_array_max_size,
-                                (orte_std_cntr_t)orte_gpr_array_block_size))) {
+        orte_gpr_replica.segments = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica.segments,
+                                orte_gpr_array_block_size, orte_gpr_array_max_size,
+                                orte_gpr_array_block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
         orte_gpr_replica.num_segs = 0;
 
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica.triggers),
-                                (orte_std_cntr_t)orte_gpr_array_block_size,
-                                (orte_std_cntr_t)orte_gpr_array_max_size,
-                                (orte_std_cntr_t)orte_gpr_array_block_size))) {
+        orte_gpr_replica.triggers = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica.triggers,
+                                orte_gpr_array_block_size, orte_gpr_array_max_size,
+                                orte_gpr_array_block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
         orte_gpr_replica.num_trigs = 0;
 
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica.subscriptions),
-                                (orte_std_cntr_t)orte_gpr_array_block_size,
-                                (orte_std_cntr_t)orte_gpr_array_max_size,
-                                (orte_std_cntr_t)orte_gpr_array_block_size))) {
+        orte_gpr_replica.subscriptions = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica.subscriptions,
+                                orte_gpr_array_block_size, orte_gpr_array_max_size,
+                                orte_gpr_array_block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
@@ -247,56 +247,61 @@
         orte_gpr_replica.processing_callbacks = false;
 
         /* initialize the local subscription and trigger trackers */
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(
-                                &(orte_gpr_replica_globals.local_subscriptions),
-                                (orte_std_cntr_t)orte_gpr_array_block_size,
-                                (orte_std_cntr_t)orte_gpr_array_max_size,
-                                (orte_std_cntr_t)orte_gpr_array_block_size))) {
+        orte_gpr_replica_globals.local_subscriptions = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(
+                                orte_gpr_replica_globals.local_subscriptions,
+                                orte_gpr_array_block_size, orte_gpr_array_max_size,
+                                orte_gpr_array_block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
         orte_gpr_replica_globals.num_local_subs = 0;
 
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(
-                                &(orte_gpr_replica_globals.local_triggers),
-                                (orte_std_cntr_t)orte_gpr_array_block_size,
-                                (orte_std_cntr_t)orte_gpr_array_max_size,
-                                (orte_std_cntr_t)orte_gpr_array_block_size))) {
+        orte_gpr_replica_globals.local_triggers = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(
+                                orte_gpr_replica_globals.local_triggers,
+                                orte_gpr_array_block_size, orte_gpr_array_max_size,
+                                orte_gpr_array_block_size))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
         orte_gpr_replica_globals.num_local_trigs = 0;
 
         /* initialize the search arrays for temporarily storing search results */
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica_globals.sub_ptrs),
-                                100, (orte_std_cntr_t)orte_gpr_array_max_size, 100))) {
+        orte_gpr_replica_globals.sub_ptrs = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica_globals.sub_ptrs,
+                                100, orte_gpr_array_max_size, 100))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
 
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica_globals.srch_cptr),
-                                100, (orte_std_cntr_t)orte_gpr_array_max_size, 100))) {
+        orte_gpr_replica_globals.srch_cptr = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica_globals.srch_cptr,
+                                100, orte_gpr_array_max_size, 100))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
         orte_gpr_replica_globals.num_srch_cptr = 0;
 
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica_globals.overwritten),
-                                20, (orte_std_cntr_t)orte_gpr_array_max_size, 20))) {
+        orte_gpr_replica_globals.overwritten = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica_globals.overwritten,
+                                20, orte_gpr_array_max_size, 20))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
         orte_gpr_replica_globals.num_overwritten = 0;
 
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica_globals.srch_ival),
-                                100, (orte_std_cntr_t)orte_gpr_array_max_size, 100))) {
+        orte_gpr_replica_globals.srch_ival = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica_globals.srch_ival,
+                                100, orte_gpr_array_max_size, 100))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
         orte_gpr_replica_globals.num_srch_ival = 0;
 
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&(orte_gpr_replica_globals.acted_upon),
-                                100, (orte_std_cntr_t)orte_gpr_array_max_size, 100))) {
+        orte_gpr_replica_globals.acted_upon = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_gpr_replica_globals.acted_upon,
+                                100, orte_gpr_array_max_size, 100))) {
             ORTE_ERROR_LOG(rc);
             return NULL;
         }
Index: orte/mca/gpr/replica/gpr_replica.h
===================================================================
--- orte/mca/gpr/replica/gpr_replica.h	(revision 16968)
+++ orte/mca/gpr/replica/gpr_replica.h	(working copy)
@@ -28,7 +28,7 @@
 #include "opal/threads/mutex.h"
 #include "opal/threads/condition.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/class/orte_value_array.h"
 #include "orte/mca/ns/ns_types.h"
 #include "orte/mca/gpr/base/base.h"
@@ -107,18 +107,18 @@
     int isolate;
     opal_mutex_t mutex;
     orte_std_cntr_t num_local_subs;
-    orte_pointer_array_t *local_subscriptions;
+    opal_pointer_array_t *local_subscriptions;
     orte_std_cntr_t num_local_trigs;
-    orte_pointer_array_t *local_triggers;
+    opal_pointer_array_t *local_triggers;
     orte_std_cntr_t num_srch_cptr;
-    orte_pointer_array_t *srch_cptr;
+    opal_pointer_array_t *srch_cptr;
     orte_std_cntr_t num_overwritten;
-    orte_pointer_array_t *overwritten;
-    orte_pointer_array_t *sub_ptrs;
+    opal_pointer_array_t *overwritten;
+    opal_pointer_array_t *sub_ptrs;
     orte_std_cntr_t num_srch_ival;
-    orte_pointer_array_t *srch_ival;
+    opal_pointer_array_t *srch_ival;
     orte_std_cntr_t num_acted_upon;
-    orte_pointer_array_t *acted_upon;
+    opal_pointer_array_t *acted_upon;
 } orte_gpr_replica_globals_t;
 
 
@@ -134,11 +134,11 @@
  *
  */
 struct orte_gpr_replica_t {
-    orte_pointer_array_t *segments;  /**< Managed array of pointers to segment objects */
+    opal_pointer_array_t *segments;  /**< Managed array of pointers to segment objects */
     orte_std_cntr_t num_segs;
-    orte_pointer_array_t *triggers;     /**< Managed array of pointers to triggers */
+    opal_pointer_array_t *triggers;     /**< Managed array of pointers to triggers */
     orte_gpr_trigger_id_t num_trigs;
-    orte_pointer_array_t *subscriptions; /**< Managed array of pointers to subscriptions */
+    opal_pointer_array_t *subscriptions; /**< Managed array of pointers to subscriptions */
     orte_gpr_subscription_id_t num_subs;
     bool processing_callbacks;
     opal_list_t callbacks;          /**< List of callbacks to be processed */
@@ -148,7 +148,7 @@
 /**
  * This structure will be used for all dictionary entries. Instead of using strcmp (& co.)
  * we will compute a quick hash value for each string and store this value together with
- * the string in the orte_pointer_array. The string have to be the last entry in the
+ * the string in the opal_pointer_array. The string have to be the last entry in the
  * structure, in order to allow us to allocate it only once.
  */
 struct orte_gpr_replica_dict_entry_t {
@@ -172,9 +172,9 @@
     char *name;                         /**< Name of the segment */
     orte_gpr_replica_itag_t itag;       /**< itag of this segment */
     orte_gpr_replica_itag_t num_dict_entries;
-    orte_pointer_array_t *dict;         /**< Managed array of dict structs */
+    opal_pointer_array_t *dict;         /**< Managed array of dict structs */
     orte_std_cntr_t num_containers;
-    orte_pointer_array_t *containers;   /**< Managed array of pointers to containers on this segment */
+    opal_pointer_array_t *containers;   /**< Managed array of pointers to containers on this segment */
 };
 typedef struct orte_gpr_replica_segment_t orte_gpr_replica_segment_t;
 
@@ -205,7 +205,7 @@
     orte_std_cntr_t index;                        /**< Location in the pointer array */
     orte_gpr_replica_itag_t *itags;   /**< Array of itags that define this container */
     orte_std_cntr_t num_itags;                    /**< Number of itags in array */
-    orte_pointer_array_t *itagvals;   /**< Array of itagval pointers */
+    opal_pointer_array_t *itagvals;   /**< Array of itagval pointers */
     orte_std_cntr_t num_itagvals;                /**< Number of itagvals in container */
     orte_value_array_t itaglist;      /**< Array of itags from all itagvals - used for rapid search */
 };
@@ -296,12 +296,12 @@
      * returned when this subscription is "fired"
      */
     orte_std_cntr_t num_values;
-    orte_pointer_array_t *values;
+    opal_pointer_array_t *values;
     /*
      * Array of requestors that are "attached" to this subscription
      */
     orte_std_cntr_t num_requestors;
-    orte_pointer_array_t *requestors;
+    opal_pointer_array_t *requestors;
 } orte_gpr_replica_subscription_t;
 
 OBJ_CLASS_DECLARATION(orte_gpr_replica_subscription_t);
@@ -330,7 +330,7 @@
     orte_gpr_trigger_id_t idtag;
     /* array of requestors that have "attached" themselves to this trigger */
     orte_std_cntr_t num_attached;
-    orte_pointer_array_t *attached;
+    opal_pointer_array_t *attached;
     /* the "master" requestor - if someone asks to have all
      * output routed through them, we record their info here
      * so we can comply
@@ -354,13 +354,13 @@
      * each counter that we are monitoring until they reach a specified level.
      */
     orte_std_cntr_t num_counters;
-    orte_pointer_array_t *counters;
+    opal_pointer_array_t *counters;
     /* a pointer to the subscriptions associated with this trigger. These
      * describe the data that will be returned when the trigger fires, and to
      * whom and where it goes.
      */
     orte_std_cntr_t num_subscriptions;
-    orte_pointer_array_t *subscriptions;
+    opal_pointer_array_t *subscriptions;
 };
 typedef struct orte_gpr_replica_trigger_t orte_gpr_replica_trigger_t;
 
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_trig_ops_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_trig_ops_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_trig_ops_fn.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -191,8 +191,9 @@
                                                 j, itag);
             }
         }
-            /* add the object to the subscription's value pointer array */
-        if (0 > (rc = orte_pointer_array_add(&(ival->index), sub->values, ival))) {
+        /* add the object to the subscription's value pointer array */
+        ival->index = opal_pointer_array_add(sub->values, ival);
+        if( 0 > ival->index ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             OBJ_RELEASE(sub);
             OBJ_RELEASE(ival);
@@ -201,7 +202,8 @@
         (sub->num_values)++;
     }
     /* add the object to the replica's subscriptions pointer array */
-    if (0 > (rc = orte_pointer_array_add(&(sub->index), orte_gpr_replica.subscriptions, sub))) {
+    sub->index = opal_pointer_array_add(orte_gpr_replica.subscriptions, sub);
+    if( 0 > sub->index ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OBJ_RELEASE(sub);
         return ORTE_ERR_OUT_OF_RESOURCE;
@@ -248,7 +250,8 @@
          req->requestor = NULL;
     }
 
-    if (0 > (rc = orte_pointer_array_add(&(req->index), sub->requestors, req))) {
+    req->index = opal_pointer_array_add(sub->requestors, req);
+    if( 0 > req->index ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
@@ -286,7 +289,7 @@
 {
     orte_gpr_replica_trigger_t *trig, **trigs;
     int rc;
-    orte_std_cntr_t i, j, k, m, num_tokens, index;
+    orte_std_cntr_t i, j, k, m, num_tokens;
     orte_gpr_replica_addr_mode_t tok_mode, key_mode;
     orte_gpr_replica_segment_t *seg;
     orte_gpr_replica_container_t **cptr, *cptr2;
@@ -358,7 +361,8 @@
     trig->action = trigger->action;
 
     /* put this trigger on the replica's list */
-    if (0 > (rc = orte_pointer_array_add(&(trig->index), orte_gpr_replica.triggers, trig))) {
+    trig->index = opal_pointer_array_add(orte_gpr_replica.triggers, trig);
+    if( 0 > trig->index ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
@@ -453,7 +457,7 @@
                         goto CLEANUP;
                     }
                 }
-                if (0 > orte_pointer_array_add(&index, trig->counters, cntr)) {
+                if( 0 > opal_pointer_array_add(trig->counters, cntr) ) {
                     ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                     rc = ORTE_ERR_OUT_OF_RESOURCE;
                     goto CLEANUP;
@@ -524,7 +528,7 @@
                                     goto CLEANUP;
                                 }
                             }
-                            if (0 > orte_pointer_array_add(&index, trig->counters, cntr)) {
+                            if( 0 > opal_pointer_array_add(trig->counters, cntr) ) {
                                 ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                                 rc = ORTE_ERR_OUT_OF_RESOURCE;
                                 goto CLEANUP;
@@ -581,7 +585,8 @@
         req->requestor = NULL;
     }
 
-    if (0 > (rc = orte_pointer_array_add(&(req->index), trig->attached, req))) {
+    req->index = opal_pointer_array_add(trig->attached, req);
+    if( 0 > req->index ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
@@ -689,18 +694,14 @@
      * requestor on this subscription, remove the subscription
      * as well
      */
-    /* must release the requestor object PRIOR to setting
-     * the indexed location to NULL or we lose the pointer
-     */
-    i = req->index;
+    opal_pointer_array_set_item(sub->requestors, req->index, NULL);
     OBJ_RELEASE(req);
-    orte_pointer_array_set_item(sub->requestors, i, NULL);
     (sub->num_requestors)--;
     if (0 == sub->num_requestors) { /* nobody left */
         /* NOTE: cannot release sub here as we still need the
          * object so we can check for it in the list of triggers
          */
-        orte_pointer_array_set_item(orte_gpr_replica.subscriptions, sub->index, NULL);
+        opal_pointer_array_set_item(orte_gpr_replica.subscriptions, sub->index, NULL);
         (orte_gpr_replica.num_subs)--;
     }
 
@@ -719,14 +720,14 @@
                 if (NULL != subs[k]) {
                     m++;
                     if (sub == subs[k]) { /* match found */
-                        orte_pointer_array_set_item(trigs[i]->subscriptions, k, NULL);
+                        opal_pointer_array_set_item(trigs[i]->subscriptions, k, NULL);
                         (trigs[i]->num_subscriptions)--;
                         /* if that was the last subscription on this trigger, then
                          * remove the trigger - not needed any more
                          */
                         if (0 == trigs[i]->num_subscriptions) {
                             OBJ_RELEASE(trigs[i]);
-                            orte_pointer_array_set_item(orte_gpr_replica.triggers, i, NULL);
+                            opal_pointer_array_set_item(orte_gpr_replica.triggers, i, NULL);
                         }
                         found = true;
                     }
@@ -794,18 +795,14 @@
      * requestor on this trigger, remove the trigger
      * as well
      */
-    /* must release the requestor object PRIOR to setting
-     * the indexed location to NULL or we lose the pointer
-     */
-    i = req->index;
+    opal_pointer_array_set_item(trig->attached, req->index, NULL);
     OBJ_RELEASE(req);
-    orte_pointer_array_set_item(trig->attached, i, NULL);
     (trig->num_attached)--;
     if (0 == trig->num_attached) { /* nobody left */
         /* NOTE: cannot release trig here as we still need the
          * object so we can clear any attached subscriptions
          */
-        orte_pointer_array_set_item(orte_gpr_replica.triggers, trig->index, NULL);
+        opal_pointer_array_set_item(orte_gpr_replica.triggers, trig->index, NULL);
         (orte_gpr_replica.num_trigs)--;
     }
 
@@ -840,8 +837,6 @@
                                    orte_gpr_replica_action_t action)
 {
     orte_gpr_replica_action_taken_t *new_action;
-    orte_std_cntr_t index;
-    int rc;
 
     OPAL_TRACE(3);
 
@@ -865,7 +860,7 @@
     OBJ_RETAIN(iptr);
 
     /* add the new action record to the array */
-    if (0 > (rc = orte_pointer_array_add(&index, orte_gpr_replica_globals.acted_upon, new_action))) {
+    if( 0 > opal_pointer_array_add(orte_gpr_replica_globals.acted_upon, new_action) ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
@@ -905,7 +900,7 @@
                             p++;
                             if (old_iptrs[k] == cntrs[j]->iptr) {
                                 if (NULL == new_iptr || replaced) {
-                                    orte_pointer_array_set_item(trig[i]->counters, j, NULL);
+                                    opal_pointer_array_set_item(trig[i]->counters, j, NULL);
                                     (trig[i]->num_counters)--;
                                 } else if (!replaced) {
                                     cntrs[j]->iptr = new_iptr;
@@ -1321,7 +1316,7 @@
     for (i=0; i < (orte_gpr_replica.triggers)->size; i++) {
         if (NULL != trig[i]) {
             if (NULL == proc && NULL == trig[i]->requestor) {
-                if (ORTE_SUCCESS != (rc = orte_pointer_array_set_item(orte_gpr_replica.triggers,
+                if (ORTE_SUCCESS != (rc = opal_pointer_array_set_item(orte_gpr_replica.triggers,
                                                 trig[i]->index, NULL))) {
                     ORTE_ERROR_LOG(rc);
                     return rc;
@@ -1329,7 +1324,7 @@
                 OBJ_RELEASE(trig);
             } else if (NULL != proc && NULL != trig[i]->requestor &&
                        ORTE_EQUAL == orte_dss.compare(Oproc, trig[i]->requestor, ORTE_NAME)) {
-                if (ORTE_SUCCESS != (rc = orte_pointer_array_set_item(orte_gpr_replica.triggers,
+                if (ORTE_SUCCESS != (rc = opal_pointer_array_set_item(orte_gpr_replica.triggers,
                                                 trig[i]->index, NULL))) {
                     ORTE_ERROR_LOG(rc);
                     return rc;
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_cleanup_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_cleanup_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_cleanup_fn.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -27,7 +27,6 @@
 
 #include "orte_config.h"
 
-#include "orte/class/orte_pointer_array.h"
 #include "opal/util/output.h"
 #include "opal/util/trace.h"
 #include "orte/util/proc_info.h"
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_put_get_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_put_get_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_put_get_fn.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -123,7 +123,7 @@
     orte_gpr_replica_itagval_t *iptr, **iptrs;
     bool overwrite, duplicate, overwritten;
     int rc;
-    orte_std_cntr_t i, j, k, m, n, index;
+    orte_std_cntr_t i, j, k, m, n;
 
     OPAL_TRACE(2);
 
@@ -144,9 +144,9 @@
     }
 
     /* initialize storage for actions taken */
-    orte_pointer_array_clear(orte_gpr_replica_globals.acted_upon);
+    opal_pointer_array_remove_all(orte_gpr_replica_globals.acted_upon);
     orte_gpr_replica_globals.num_acted_upon = 0;
-    orte_pointer_array_clear(orte_gpr_replica_globals.overwritten);
+    opal_pointer_array_remove_all(orte_gpr_replica_globals.overwritten);
     orte_gpr_replica_globals.num_overwritten = 0;
 
     /* extract the token address mode and overwrite permissions */
@@ -244,7 +244,7 @@
                                         return rc;
                                     }
                                     /* record the ival so we don't do it again */
-                                    if (0 > orte_pointer_array_add(&index, orte_gpr_replica_globals.overwritten, (void*)iptr)) {
+                                    if( 0 > opal_pointer_array_add(orte_gpr_replica_globals.overwritten, (void*)iptr) ) {
                                         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                                         return ORTE_ERR_OUT_OF_RESOURCE;
                                     }
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_del_index_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_del_index_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_del_index_fn.c	(working copy)
@@ -62,7 +62,7 @@
     }
     
     /* initialize storage for actions taken */
-    orte_pointer_array_clear(orte_gpr_replica_globals.acted_upon);
+    opal_pointer_array_remove_all(orte_gpr_replica_globals.acted_upon);
     orte_gpr_replica_globals.num_acted_upon = 0;
     
     /* extract the token address mode */
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_messaging_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_messaging_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_messaging_fn.c	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -98,7 +98,7 @@
             k++;
             if (trigs[i]->one_shot_fired) {
                 OBJ_RELEASE(trigs[i]);
-                orte_pointer_array_set_item(orte_gpr_replica.triggers, i, NULL);
+                opal_pointer_array_set_item(orte_gpr_replica.triggers, i, NULL);
                 m++;
             } else {
                 trigs[i]->processing = false;
@@ -438,7 +438,7 @@
                                         orte_std_cntr_t cnt,
                                         orte_gpr_value_t **values)
 {
-    orte_std_cntr_t i, j, k, index;
+    orte_std_cntr_t i, j, k;
     orte_gpr_notify_data_t **data, *dptr;
 
     /* check to see if this data is going to the same place as
@@ -453,7 +453,7 @@
             k++;
             if (data[i]->id == req->idtag) { /* going to the same place */
                 for (j=0; j < cnt; j++) {
-                    if (0 > orte_pointer_array_add(&index, data[i]->values, values[j])) {
+                    if( 0 > opal_pointer_array_add(data[i]->values, values[j]) ) {
                         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                         return ORTE_ERR_OUT_OF_RESOURCE;
                     }
@@ -486,13 +486,13 @@
         dptr->target = strdup(sub_name);
     }
     dptr->id = req->idtag;
-    if (0 > orte_pointer_array_add(&index, msg->data, dptr)) {
+    if( 0 > opal_pointer_array_add(msg->data, dptr) ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
     (msg->cnt)++;
     for (j=0; j < cnt; j++) {
-        if (0 > orte_pointer_array_add(&index, dptr->values, values[j])) {
+        if( 0 > opal_pointer_array_add(dptr->values, values[j]) ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             return ORTE_ERR_OUT_OF_RESOURCE;
         }
@@ -515,7 +515,7 @@
                                                        orte_std_cntr_t cnt,
                                                        orte_gpr_value_t **values)
 {
-    orte_std_cntr_t i, j, k, index;
+    orte_std_cntr_t i, j, k;
     orte_gpr_notify_data_t **data, *dptr;
 
     /* check to see if this data is going to the same place as
@@ -532,7 +532,7 @@
                  (NULL != data[i]->target && NULL != sub->name &&
                  0 == strcmp(data[i]->target, sub->name))) { /* going to the same place */
                 for (j=0; j < cnt; j++) {
-                    if (0 > orte_pointer_array_add(&index, data[i]->values, values[j])) {
+                    if( 0 > opal_pointer_array_add(data[i]->values, values[j]) ) {
                         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                         return ORTE_ERR_OUT_OF_RESOURCE;
                     }
@@ -563,13 +563,13 @@
     if (NULL != sub && NULL != sub->name) {
         dptr->target = strdup(sub->name);
     }
-    if (0 > orte_pointer_array_add(&index, msg->data, dptr)) {
+    if( 0 > opal_pointer_array_add(msg->data, dptr) ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
     (msg->cnt)++;
     for (j=0; j < cnt; j++) {
-        if (0 > orte_pointer_array_add(&index, dptr->values, values[j])) {
+        if( 0 > opal_pointer_array_add(dptr->values, values[j]) ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             return ORTE_ERR_OUT_OF_RESOURCE;
         }
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_local_trig_ops_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_local_trig_ops_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_local_trig_ops_fn.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -59,7 +59,8 @@
         }
         sub->callback = subscriptions[i]->cbfunc;
         sub->user_tag = subscriptions[i]->user_tag;
-        if (0 > orte_pointer_array_add(&sub->index, orte_gpr_replica_globals.local_subscriptions, sub)) {
+        sub->index = opal_pointer_array_add(orte_gpr_replica_globals.local_subscriptions, sub);
+        if( 0 > sub->index ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             return ORTE_ERR_OUT_OF_RESOURCE;
         }
@@ -137,7 +138,8 @@
         }
         trig->callback = trigs[i]->cbfunc;
         trig->user_tag = trigs[i]->user_tag;
-        if (0 > orte_pointer_array_add(&trig->index, orte_gpr_replica_globals.local_triggers, trig)) {
+        trig->index = opal_pointer_array_add(orte_gpr_replica_globals.local_triggers, trig);
+        if( 0 > trig->index ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             return ORTE_ERR_OUT_OF_RESOURCE;
         }
@@ -153,8 +155,6 @@
 
 int orte_gpr_replica_remove_local_subscription(orte_gpr_replica_local_subscriber_t *sub)
 {
-    orte_std_cntr_t index;
-    
     OPAL_TRACE(2);
  
     if (NULL == sub) {
@@ -162,17 +162,14 @@
         return ORTE_ERR_BAD_PARAM;
     }
 
-    index = sub->index;
+    opal_pointer_array_set_item(orte_gpr_replica_globals.local_subscriptions, sub->index, NULL);
     OBJ_RELEASE(sub);
-    orte_pointer_array_set_item(orte_gpr_replica_globals.local_subscriptions, index, NULL);
 
     return ORTE_SUCCESS;
 }
 
 int orte_gpr_replica_remove_local_trigger(orte_gpr_replica_local_trigger_t *trig)
 {
-    orte_std_cntr_t index;
-    
     OPAL_TRACE(2);
  
     if (NULL == trig) {
@@ -180,9 +177,8 @@
         return ORTE_ERR_BAD_PARAM;
     }
 
-    index = trig->index;
+    opal_pointer_array_set_item(orte_gpr_replica_globals.local_triggers, trig->index, NULL);
     OBJ_RELEASE(trig);
-    orte_pointer_array_set_item(orte_gpr_replica_globals.local_triggers, index, NULL);
 
     return ORTE_SUCCESS;
 }
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_subscribe_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_subscribe_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_subscribe_fn.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -45,7 +45,7 @@
 {
     orte_gpr_replica_subscription_t *sub=NULL, **subs, **trigsubs;
     orte_gpr_replica_trigger_t *trig=NULL;
-    orte_std_cntr_t i, j, k, m, n, index;
+    orte_std_cntr_t i, j, k, m, n;
     bool ignore;
     int rc=ORTE_SUCCESS;
 
@@ -60,7 +60,7 @@
      * use the sub_ptrs array to temporarily store the subscription pointers so we
      * can properly link them to the triggers
      */
-    orte_pointer_array_clear(orte_gpr_replica_globals.sub_ptrs);
+    opal_pointer_array_remove_all(orte_gpr_replica_globals.sub_ptrs);
     subs = (orte_gpr_replica_subscription_t**)(orte_gpr_replica_globals.sub_ptrs)->addr;
     
     for (i=0; i < num_subs; i++) {
@@ -72,7 +72,7 @@
         /* add the new subscription so we can link
          * it to the triggers later
          */
-        if (0 > orte_pointer_array_add(&index, orte_gpr_replica_globals.sub_ptrs, sub)) {
+        if( 0 > opal_pointer_array_add(orte_gpr_replica_globals.sub_ptrs, sub) ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             return ORTE_ERR_OUT_OF_RESOURCE;
         }
@@ -108,7 +108,7 @@
                     }
                 }
                 if (!ignore) { /* new sub for this trig - add it */
-                    if (0 > orte_pointer_array_add(&index, trig->subscriptions, subs[j])) {
+                    if( 0 > opal_pointer_array_add(trig->subscriptions, subs[j]) ) {
                         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                         return ORTE_ERR_OUT_OF_RESOURCE;
                     }
Index: orte/mca/gpr/replica/functional_layer/gpr_replica_segment_fn.c
===================================================================
--- orte/mca/gpr/replica/functional_layer/gpr_replica_segment_fn.c	(revision 16968)
+++ orte/mca/gpr/replica/functional_layer/gpr_replica_segment_fn.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -44,12 +44,12 @@
                                      orte_gpr_replica_itag_t *taglist, orte_std_cntr_t num_tags)
 {
     orte_gpr_replica_container_t **cptr;
-    orte_std_cntr_t i, j, index;
+    orte_std_cntr_t i, j;
 
     OPAL_TRACE(3);
 
     /* ensure the search array is clear */
-    orte_pointer_array_clear(orte_gpr_replica_globals.srch_cptr);
+    opal_pointer_array_remove_all(orte_gpr_replica_globals.srch_cptr);
     orte_gpr_replica_globals.num_srch_cptr = 0;
 
     cptr = (orte_gpr_replica_container_t**)((seg->containers)->addr);
@@ -60,9 +60,9 @@
             if (orte_gpr_replica_check_itag_list(addr_mode,
                                              num_tags, taglist,
                                              cptr[i]->num_itags, cptr[i]->itags)) {
-                if (0 > orte_pointer_array_add(&index, orte_gpr_replica_globals.srch_cptr, cptr[i])) {
+                if( 0 > opal_pointer_array_add(orte_gpr_replica_globals.srch_cptr, cptr[i]) ) {
                     ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
-                    orte_pointer_array_clear(orte_gpr_replica_globals.srch_cptr);
+                    opal_pointer_array_remove_all(orte_gpr_replica_globals.srch_cptr);
                     return ORTE_ERR_OUT_OF_RESOURCE;
                 }
                 (orte_gpr_replica_globals.num_srch_cptr)++;
@@ -79,7 +79,6 @@
                                       orte_gpr_replica_itag_t *itags)
 {
     int rc;
-    orte_std_cntr_t index;
 
     OPAL_TRACE(3);
 
@@ -97,13 +96,13 @@
 
     (*cptr)->num_itags = num_itags;
 
-    if (0 > orte_pointer_array_add(&index, seg->containers, (void*)(*cptr))) {
+    (*cptr)->index = opal_pointer_array_add(seg->containers, (void*)(*cptr));
+    if( 0 > (*cptr)->index ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         return ORTE_ERR_OUT_OF_RESOURCE;
     }
     (seg->num_containers)++;
 
-    (*cptr)->index = index;
     return ORTE_SUCCESS;
 }
 
@@ -129,9 +128,8 @@
     }
 
     /* remove container from segment and release it */
-    i = cptr->index;
+    opal_pointer_array_set_item(seg->containers, cptr->index, NULL);
     OBJ_RELEASE(cptr);
-    orte_pointer_array_set_item(seg->containers, i, NULL);
     (seg->num_containers)--;
 
     /* if the segment is now empty of containers, release it too */
@@ -213,7 +211,8 @@
         }
     }
 
-    if (0 > orte_pointer_array_add(&(iptr->index), cptr->itagvals, (void*)iptr)) {
+    iptr->index = opal_pointer_array_add(cptr->itagvals, (void*)iptr);
+    if( 0 > iptr->index ) {
         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OBJ_RELEASE(iptr);
         return ORTE_ERR_OUT_OF_RESOURCE;
@@ -222,7 +221,7 @@
 
     if (0 > (rc = orte_value_array_append_item(&(cptr->itaglist), (void*)(&(iptr->itag))))) {
         ORTE_ERROR_LOG(rc);
-        orte_pointer_array_set_item(cptr->itagvals, iptr->index, NULL);
+        opal_pointer_array_set_item(cptr->itagvals, iptr->index, NULL);
         OBJ_RELEASE(iptr);
         return rc;
     }
@@ -264,12 +263,11 @@
     return ORTE_ERR_NOT_FOUND;
 
 MOVEON:
-    /* release the data storage */
-    i = iptr->index;
-    OBJ_RELEASE(iptr);
 
     /* remove the entry from the container's itagval array */
-    orte_pointer_array_set_item(cptr->itagvals, i, NULL);
+    opal_pointer_array_set_item(cptr->itagvals, iptr->index, NULL);
+    /* release the data storage */
+    OBJ_RELEASE(iptr);
     (cptr->num_itagvals)--;
 
     /* NOTE: If the container is now empty, *don't* remove it here
@@ -285,9 +283,9 @@
                                    orte_gpr_replica_container_t *cptr,
                                    orte_gpr_keyval_t *kptr)
 {
-    orte_std_cntr_t i, j, k;
+    orte_std_cntr_t i, k;
     int rc;
-    orte_pointer_array_t *ptr;
+    opal_pointer_array_t *ptr;
     orte_gpr_replica_itagval_t *iptr;
 
     OPAL_TRACE(3);
@@ -301,8 +299,6 @@
     for (i=0; i < ptr->size; i++) {
         if (NULL != ptr->addr[i]) {
             iptr = (orte_gpr_replica_itagval_t*)ptr->addr[i];
-            /* release the data storage */
-            j = iptr->index;
             /* DON'T RECORD THE ACTION - THIS WILL PREVENT US FROM SENDING
              * BOTH THE OLD AND THE NEW DATA BACK ON A SUBSCRIPTION
              * REQUEST
@@ -318,9 +314,9 @@
             return ORTE_ERR_NOT_FOUND;
 
 MOVEON:
-            OBJ_RELEASE(iptr);
             /* remove the entry from the container's itagval array */
-            orte_pointer_array_set_item(cptr->itagvals, j, NULL);
+            opal_pointer_array_set_item(cptr->itagvals, iptr->index, NULL);
+            OBJ_RELEASE(iptr);
             (cptr->num_itagvals)--;
         }
     }
@@ -358,12 +354,12 @@
                                       orte_gpr_replica_container_t *cptr)
 {
     orte_gpr_replica_itagval_t **ptr;
-    orte_std_cntr_t i, j, index;
+    orte_std_cntr_t i, j;
 
     OPAL_TRACE(3);
 
     /* ensure the search array is clear */
-    orte_pointer_array_clear(orte_gpr_replica_globals.srch_ival);
+    opal_pointer_array_remove_all(orte_gpr_replica_globals.srch_ival);
     orte_gpr_replica_globals.num_srch_ival = 0;
 
     /* check list of itags in container to see if there is a match according
@@ -382,9 +378,9 @@
                                                  num_itags, itags,
                                                  1, &(ptr[i]->itag))) {
 
-                    if (0 > orte_pointer_array_add(&index, orte_gpr_replica_globals.srch_ival, ptr[i])) {
+                    if( 0 > opal_pointer_array_add(orte_gpr_replica_globals.srch_ival, ptr[i]) ) {
                         ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
-                        orte_pointer_array_clear(orte_gpr_replica_globals.srch_ival);
+                        opal_pointer_array_remove_all(orte_gpr_replica_globals.srch_ival);
                         return ORTE_ERR_OUT_OF_RESOURCE;
                     }
                     (orte_gpr_replica_globals.num_srch_ival)++;
@@ -429,7 +425,7 @@
     i = (*seg)->itag;
     OBJ_RELEASE(*seg);
 
-    if (0 > (rc = orte_pointer_array_set_item(orte_gpr_replica.segments, i, NULL))) {
+    if (0 > (rc = opal_pointer_array_set_item(orte_gpr_replica.segments, i, NULL))) {
         return rc;
     }
     (orte_gpr_replica.num_segs)--;
Index: orte/mca/gpr/proxy/gpr_proxy.h
===================================================================
--- orte/mca/gpr/proxy/gpr_proxy.h	(revision 16968)
+++ orte/mca/gpr/proxy/gpr_proxy.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -20,22 +20,19 @@
 #ifndef ORTE_GPR_PROXY_H
 #define ORTE_GPR_PROXY_H
 
-
 #include "orte_config.h"
 
 #include "orte/orte_types.h"
 #include "opal/class/opal_object.h"
 #include "opal/threads/mutex.h"
 #include "opal/threads/condition.h"
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/dss/dss_types.h"
 #include "orte/util/proc_info.h"
 
 #include "orte/mca/gpr/base/base.h"
 
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
+BEGIN_C_DECLS
 
 /*
  * Module open / close
@@ -59,7 +56,7 @@
 typedef struct {
      opal_object_t super;                   /**< Allows this to be an object */
      orte_gpr_subscription_id_t id;         /**< id of this subscription */
-     orte_std_cntr_t index;                          /**< location of this subscription in array */
+     int index;                             /**< location of this subscription in array */
      char *name;
      orte_gpr_notify_cb_fn_t callback;      /**< Function to be called for notificaiton */
      void *user_tag;                        /**< User-provided tag for callback function */
@@ -71,7 +68,7 @@
 typedef struct {
      opal_object_t super;                   /**< Allows this to be an object */
      orte_gpr_trigger_id_t id;              /**< id of this trigger */
-     orte_std_cntr_t index;                          /**< location of this trigger in array */
+     int index;                             /**< location of this trigger in array */
      char *name;
      orte_gpr_trigger_cb_fn_t callback;     /**< Function to be called for notification */
      void *user_tag;                        /**< User-provided tag for callback function */
@@ -86,9 +83,9 @@
 typedef struct {
     int debug;
     orte_gpr_subscription_id_t num_subs;
-    orte_pointer_array_t *subscriptions;
+    opal_pointer_array_t *subscriptions;
     orte_gpr_trigger_id_t num_trigs;
-    orte_pointer_array_t *triggers;
+    opal_pointer_array_t *triggers;
     opal_mutex_t mutex;
     bool compound_cmd_mode;
     orte_buffer_t *compound_cmd;
@@ -261,8 +258,6 @@
  */
 ORTE_MODULE_DECLSPEC extern mca_gpr_base_component_t mca_gpr_proxy_component;
 
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
+END_C_DECLS
 
 #endif
Index: orte/mca/gpr/proxy/gpr_proxy_internals.c
===================================================================
--- orte/mca/gpr/proxy/gpr_proxy_internals.c	(revision 16968)
+++ orte/mca/gpr/proxy/gpr_proxy_internals.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -31,7 +31,7 @@
 #include "opal/util/trace.h"
 
 #include "orte/mca/errmgr/errmgr.h"
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/mca/gpr/proxy/gpr_proxy.h"
 
 int
@@ -53,7 +53,8 @@
         }
         sub->callback = subscriptions[i]->cbfunc;
         sub->user_tag = subscriptions[i]->user_tag;
-        if (0 > orte_pointer_array_add(&sub->index, orte_gpr_proxy_globals.subscriptions, sub)) {
+        sub->index = opal_pointer_array_add(orte_gpr_proxy_globals.subscriptions, sub);
+        if( 0 > sub->index ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             return ORTE_ERR_OUT_OF_RESOURCE;
         }
@@ -132,7 +133,8 @@
         }
         trig->callback = trigs[i]->cbfunc;
         trig->user_tag = trigs[i]->user_tag;
-        if (0 > orte_pointer_array_add(&trig->index, orte_gpr_proxy_globals.triggers, trig)) {
+        trig->index = opal_pointer_array_add(orte_gpr_proxy_globals.triggers, trig);
+        if( 0 > trig->index ) {
             ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             return ORTE_ERR_OUT_OF_RESOURCE;
         }
@@ -149,8 +151,6 @@
 int
 orte_gpr_proxy_remove_subscription(orte_gpr_proxy_subscriber_t *sub)
 {
-    orte_std_cntr_t index;
-
     OPAL_TRACE(2);
 
     if (NULL == sub) {
@@ -158,9 +158,8 @@
         return ORTE_ERR_BAD_PARAM;
     }
 
-    index = sub->index;
+    opal_pointer_array_set_item(orte_gpr_proxy_globals.subscriptions, sub->index, NULL);
     OBJ_RELEASE(sub);
-    orte_pointer_array_set_item(orte_gpr_proxy_globals.subscriptions, index, NULL);
 
     return ORTE_SUCCESS;
 }
@@ -168,8 +167,6 @@
 int
 orte_gpr_proxy_remove_trigger(orte_gpr_proxy_trigger_t *trig)
 {
-    orte_std_cntr_t index;
-
     OPAL_TRACE(2);
 
     if (NULL == trig) {
@@ -177,9 +174,8 @@
         return ORTE_ERR_BAD_PARAM;
     }
 
-    index = trig->index;
+    opal_pointer_array_set_item(orte_gpr_proxy_globals.triggers, trig->index, NULL);
     OBJ_RELEASE(trig);
-    orte_pointer_array_set_item(orte_gpr_proxy_globals.triggers, index, NULL);
 
     return ORTE_SUCCESS;
 }
Index: orte/mca/gpr/proxy/gpr_proxy_component.c
===================================================================
--- orte/mca/gpr/proxy/gpr_proxy_component.c	(revision 16968)
+++ orte/mca/gpr/proxy/gpr_proxy_component.c	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -267,20 +267,20 @@
         orte_gpr_proxy_globals.compound_cmd = NULL;
 
         /* initialize the subscription tracker */
-        if (ORTE_SUCCESS != (ret = orte_pointer_array_init(&(orte_gpr_proxy_globals.subscriptions),
-                                (orte_std_cntr_t)orte_gpr_array_block_size,
-                                (orte_std_cntr_t)orte_gpr_array_max_size,
-                                (orte_std_cntr_t)orte_gpr_array_block_size))) {
+        orte_gpr_proxy_globals.subscriptions = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (ret = opal_pointer_array_init(orte_gpr_proxy_globals.subscriptions,
+                                orte_gpr_array_block_size,
+                                orte_gpr_array_max_size, orte_gpr_array_block_size))) {
             ORTE_ERROR_LOG(ret);
             return NULL;
         }
         orte_gpr_proxy_globals.num_subs = 0;
 
         /* initialize the trigger counter */
-        if (ORTE_SUCCESS != (ret = orte_pointer_array_init(&(orte_gpr_proxy_globals.triggers),
-                                (orte_std_cntr_t)orte_gpr_array_block_size,
-                                (orte_std_cntr_t)orte_gpr_array_max_size,
-                                (orte_std_cntr_t)orte_gpr_array_block_size))) {
+        orte_gpr_proxy_globals.triggers = OBJ_NEW(opal_pointer_array_t);
+        if (ORTE_SUCCESS != (ret = opal_pointer_array_init(orte_gpr_proxy_globals.triggers,
+                                orte_gpr_array_block_size, orte_gpr_array_max_size,
+                                orte_gpr_array_block_size))) {
             ORTE_ERROR_LOG(ret);
             return NULL;
         }
Index: orte/mca/gpr/gpr_types.h
===================================================================
--- orte/mca/gpr/gpr_types.h	(revision 16968)
+++ orte/mca/gpr/gpr_types.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -40,7 +40,7 @@
 
 #include "orte/mca/schema/schema.h"
 #include "opal/class/opal_object.h"
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 
 #include "orte/dss/dss_types.h"
 #include "orte/mca/ns/ns_types.h"
@@ -166,7 +166,7 @@
     orte_gpr_subscription_id_t id;  /**< Number of the associated subscription */
     bool remove;                    /**< Remove this subscription from recipient's tracker */
     orte_std_cntr_t cnt;                     /**< Number of value objects returned, one per container */
-    orte_pointer_array_t *values;   /**< Array of value objects returned */
+    opal_pointer_array_t *values;   /**< Array of value objects returned */
 } orte_gpr_notify_data_t;
 
 ORTE_DECLSPEC OBJ_CLASS_DECLARATION(orte_gpr_notify_data_t);
@@ -186,7 +186,7 @@
                                     (ORTE_GPR_TRIGGER_ID_MAX otherwise) */
     bool remove;                /**< Remove this trigger from recipient's tracker */
     orte_std_cntr_t cnt;                 /**< number of data objects */
-    orte_pointer_array_t *data; /**< Contiguous array of pointers to data objects */
+    opal_pointer_array_t *data; /**< Contiguous array of pointers to data objects */
 } orte_gpr_notify_message_t;
 
 ORTE_DECLSPEC OBJ_CLASS_DECLARATION(orte_gpr_notify_message_t);
Index: orte/mca/gpr/base/gpr_base_open.c
===================================================================
--- orte/mca/gpr/base/gpr_base_open.c	(revision 16968)
+++ orte/mca/gpr/base/gpr_base_open.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -129,9 +129,9 @@
     ptr->id = ORTE_GPR_SUBSCRIPTION_ID_MAX;
     ptr->remove = false;
     ptr->cnt = 0;
-    orte_pointer_array_init(&(ptr->values), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    ptr->values = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(ptr->values, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size, orte_gpr_array_block_size);
 
 }
 
@@ -244,9 +244,9 @@
     msg->id = ORTE_GPR_TRIGGER_ID_MAX;
     msg->remove = false;
     msg->cnt = 0;
-    orte_pointer_array_init(&(msg->data), (orte_std_cntr_t)orte_gpr_array_block_size,
-                            (orte_std_cntr_t)orte_gpr_array_max_size,
-                            (orte_std_cntr_t)orte_gpr_array_block_size);
+    msg->data = OBJ_NEW(opal_pointer_array_t);
+    opal_pointer_array_init(msg->data, orte_gpr_array_block_size,
+                            orte_gpr_array_max_size, orte_gpr_array_block_size);
 }
 
 /* destructor - used to free any resources held by instance */
Index: orte/mca/gpr/base/data_type_support/gpr_data_type_copy_fns.c
===================================================================
--- orte/mca/gpr/base/data_type_support/gpr_data_type_copy_fns.c	(revision 16968)
+++ orte/mca/gpr/base/data_type_support/gpr_data_type_copy_fns.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -308,7 +308,7 @@
 /* NOTIFY DATA */
 int orte_gpr_base_copy_notify_data(orte_gpr_notify_data_t **dest, orte_gpr_notify_data_t *src, orte_data_type_t type)
 {
-    orte_std_cntr_t j, k, index;
+    orte_std_cntr_t j, k;
     orte_gpr_value_t **val, *ptr;
     int rc;
 
@@ -340,10 +340,10 @@
                 return rc;
             }
             /* ...and add it to the pointer array */
-            if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&index, (*dest)->values, ptr))) {
-                ORTE_ERROR_LOG(rc);
+            if( 0 > opal_pointer_array_add((*dest)->values, ptr) ) {
+                ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                 OBJ_RELEASE(*dest);
-                return rc;
+                return ORTE_ERR_OUT_OF_RESOURCE;
             }
         }
     }
@@ -354,7 +354,7 @@
 /* NOTIFY MSG */
 int orte_gpr_base_copy_notify_msg(orte_gpr_notify_message_t **dest, orte_gpr_notify_message_t *src, orte_data_type_t type)
 {
-    orte_std_cntr_t j, k, index;
+    orte_std_cntr_t j, k;
     orte_gpr_notify_data_t **val, *ptr;
     int rc;
 
@@ -386,10 +386,10 @@
                 return rc;
             }
             /* ...and add it to the pointer array */
-            if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&index, (*dest)->data, ptr))) {
-                ORTE_ERROR_LOG(rc);
+            if( 0 > opal_pointer_array_add((*dest)->data, ptr) ) {
+                ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                 OBJ_RELEASE(*dest);
-                return rc;
+                return ORTE_ERR_OUT_OF_RESOURCE;
             }
         }
     }
Index: orte/mca/gpr/base/data_type_support/gpr_data_type_size_fns.c
===================================================================
--- orte/mca/gpr/base/data_type_support/gpr_data_type_size_fns.c	(revision 16968)
+++ orte/mca/gpr/base/data_type_support/gpr_data_type_size_fns.c	(working copy)
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2004-2005 The Trustees of Indiana University.
  *                         All rights reserved.
- * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.
+ * Copyright (c) 2004-2007 The Trustees of the University of Tennessee.
  *                         All rights reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
  *                         University of Stuttgart.  All rights reserved.
@@ -231,7 +231,7 @@
     if (NULL != src->target) {
         *size += strlen(src->target);
     }
-    *size += sizeof(orte_pointer_array_t);  /* account for size of pointer array object */
+    *size += sizeof(opal_pointer_array_t);  /* account for size of pointer array object */
     *size += (src->values)->size * sizeof(void*);  /* account for size of pointer array storage */
 
     /* size the value entries */
@@ -273,7 +273,7 @@
     if (NULL != src->target) {
         *size += strlen(src->target);
     }
-    *size += sizeof(orte_pointer_array_t);  /* account for size of pointer array object */
+    *size += sizeof(opal_pointer_array_t);  /* account for size of pointer array object */
     *size += (src->data)->size * sizeof(void*);  /* account for size of pointer array storage */
 
     /* size the notify data entries */
Index: orte/mca/gpr/base/data_type_support/gpr_data_type_unpacking_fns.c
===================================================================
--- orte/mca/gpr/base/data_type_support/gpr_data_type_unpacking_fns.c	(revision 16968)
+++ orte/mca/gpr/base/data_type_support/gpr_data_type_unpacking_fns.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -475,7 +475,7 @@
 
         /* if there are values, unpack them to the value array */
         if (0 < data[i]->cnt) {
-            if (ORTE_SUCCESS != (rc = orte_pointer_array_set_size(data[i]->values, data[i]->cnt))) {
+            if (ORTE_SUCCESS != (rc = opal_pointer_array_set_size(data[i]->values, data[i]->cnt))) {
                 ORTE_ERROR_LOG(rc);
                 return rc;
             }
@@ -556,7 +556,7 @@
 
         /* if there are datagrams, unpack them to the data array */
         if (0 < msg[i]->cnt) {
-            if (ORTE_SUCCESS != (rc = orte_pointer_array_set_size(msg[i]->data, msg[i]->cnt))) {
+            if (ORTE_SUCCESS != (rc = opal_pointer_array_set_size(msg[i]->data, msg[i]->cnt))) {
                 ORTE_ERROR_LOG(rc);
                 return rc;
             }
Index: orte/mca/rml/base/rml_base_contact.c
===================================================================
--- orte/mca/rml/base/rml_base_contact.c	(revision 16968)
+++ orte/mca/rml/base/rml_base_contact.c	(working copy)
@@ -1,3 +1,21 @@
+/*
+ * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2007 The Regents of the University of California.
+ *                         All rights reserved.
+ * $COPYRIGHT$
+ *
+ * Additional copyrights may follow
+ *
+ * $HEADER$
+ */
+
 #include "orte_config.h"
 
 #include "orte/mca/rml/base/base.h"
@@ -34,7 +52,7 @@
         NULL
     };
     orte_gpr_value_t **values;
-    orte_std_cntr_t cnt, i, idx;
+    orte_std_cntr_t cnt, i;
     int rc;
     
     /* define the segment */
@@ -61,9 +79,9 @@
             *data = OBJ_NEW(orte_gpr_notify_data_t);
         }
         for (i=0; i < cnt; i++) {
-            if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&idx, (*data)->values, (void*)values[i]))) {
-                ORTE_ERROR_LOG(rc);
-                return rc;
+            if( 0 > opal_pointer_array_add((*data)->values, (void*)values[i]) ) {
+                ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
+                return ORTE_ERR_OUT_OF_RESOURCE;
             }
             ++(*data)->cnt;
         }
Index: orte/mca/pls/xcpu/pls_xcpu.h
===================================================================
--- orte/mca/pls/xcpu/pls_xcpu.h	(revision 16968)
+++ orte/mca/pls/xcpu/pls_xcpu.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -37,7 +37,6 @@
 #include <sys/time.h>
 #endif
 
-#include "orte/class/orte_pointer_array.h"
 #include "orte/orte_constants.h"
 #include "orte/mca/pls/base/base.h"
 #include "orte/util/proc_info.h"
Index: orte/mca/pls/bproc/pls_bproc.h
===================================================================
--- orte/mca/pls/bproc/pls_bproc.h	(revision 16968)
+++ orte/mca/pls/bproc/pls_bproc.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -48,7 +48,6 @@
 
 #include "opal/threads/condition.h"
 
-#include "orte/class/orte_pointer_array.h"
 #include "orte/util/proc_info.h"
 
 #include "orte/mca/rml/rml_types.h"
Index: orte/mca/odls/bproc/odls_bproc.c
===================================================================
--- orte/mca/odls/bproc/odls_bproc.c	(revision 16968)
+++ orte/mca/odls/bproc/odls_bproc.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -78,8 +78,7 @@
 int orte_odls_bproc_get_add_procs_data(orte_gpr_notify_data_t **data, orte_job_map_t *map)
 {
     orte_gpr_notify_data_t *ndat;
-    orte_gpr_value_t **values, *value;
-    orte_std_cntr_t cnt;
+    orte_gpr_value_t *value;
     opal_list_item_t *item, *m_item;
     orte_mapped_node_t *node;
     orte_mapped_proc_t *proc;
@@ -118,7 +117,6 @@
             if (ORTE_SUCCESS != (rc = orte_gpr.create_value(&value, 0, "bogus", 5, 0))) {
                 ORTE_ERROR_LOG(rc);
                 OBJ_RELEASE(ndat);
-                OBJ_RELEASE(value);
                 return rc;
             }
             
@@ -166,12 +164,11 @@
                 OBJ_RELEASE(value);
                 return rc;
             }
-            
-            if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&cnt, ndat->values, value))) {
-                ORTE_ERROR_LOG(rc);
+            if( 0 > opal_pointer_array_add(ndat->values, value) ) {
+                ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                 OBJ_RELEASE(ndat);
-                OBJ_RELEASE(values[0]);
-                return rc;
+                OBJ_RELEASE(value);
+                return ORTE_ERR_OUT_OF_RESOURCE;
             }
             ndat->cnt += 1;
         }
Index: orte/mca/odls/base/odls_base_default_fns.c
===================================================================
--- orte/mca/odls/base/odls_base_default_fns.c	(revision 16968)
+++ orte/mca/odls/base/odls_base_default_fns.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -380,11 +380,11 @@
     }
     
     /* add the data to the notify_data object */
-    if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&i, ndat->values, value))) {
-        ORTE_ERROR_LOG(rc);
+    if( 0 > opal_pointer_array_add(ndat->values, value) ) {
+        ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OBJ_RELEASE(ndat);
         OBJ_RELEASE(value);
-        return rc;
+        return ORTE_ERR_OUT_OF_RESOURCE;
     }
     ndat->cnt = 1;
     
@@ -490,11 +490,11 @@
         }
         
         /* add this node's data to the notify_data object */
-        if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&i, ndat->values, value))) {
-            ORTE_ERROR_LOG(rc);
+        if( 0 > opal_pointer_array_add(ndat->values, value) ) {
+            ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
             OBJ_RELEASE(ndat);
             OBJ_RELEASE(value);
-            return rc;
+            return ORTE_ERR_OUT_OF_RESOURCE;
         }
         ndat->cnt += 1;
     }
Index: orte/mca/odls/process/odls_process_module.c
===================================================================
--- orte/mca/odls/process/odls_process_module.c	(revision 16968)
+++ orte/mca/odls/process/odls_process_module.c	(working copy)
@@ -72,7 +72,6 @@
 {
     orte_gpr_notify_data_t *ndat;
     orte_gpr_value_t **values, *value;
-    orte_std_cntr_t cnt;
     char *glob_tokens[] = {
         ORTE_JOB_GLOBALS,
         NULL
@@ -124,11 +123,11 @@
     /* there can only be one value here since we only specified a single container.
      * Just transfer the returned value to the ndat structure
      */
-    if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&cnt, ndat->values, values[0]))) {
-        ORTE_ERROR_LOG(rc);
+    if( 0 > opal_pointer_array_add(ndat->values, values[0]) ) {
+        ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
         OBJ_RELEASE(ndat);
         OBJ_RELEASE(values[0]);
-        return rc;
+        return ORTE_ERR_OUT_OF_RESOURCE;
     }
     ndat->cnt = 1;
     
@@ -197,11 +196,11 @@
                 OBJ_RELEASE(value);
                 return rc;
             }
-            if (ORTE_SUCCESS != (rc = orte_pointer_array_add(&cnt, ndat->values, value))) {
-                ORTE_ERROR_LOG(rc);
+            if( 0 > opal_pointer_array_add(ndat->values, value) ) {
+                ORTE_ERROR_LOG(ORTE_ERR_OUT_OF_RESOURCE);
                 OBJ_RELEASE(ndat);
-                OBJ_RELEASE(values[0]);
-                return rc;
+                OBJ_RELEASE(value);
+                return ORTE_ERR_OUT_OF_RESOURCE;
             }
             ndat->cnt += 1;
         }
Index: orte/mca/rmgr/base/rmgr_base_stage_gate.c
===================================================================
--- orte/mca/rmgr/base/rmgr_base_stage_gate.c	(revision 16968)
+++ orte/mca/rmgr/base/rmgr_base_stage_gate.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -31,7 +31,6 @@
 #include "opal/util/output.h"
 #include "opal/util/trace.h"
 
-#include "orte/class/orte_pointer_array.h"
 #include "orte/dss/dss.h"
 #include "orte/mca/gpr/gpr.h"
 #include "orte/mca/ns/ns.h"
Index: orte/tools/ortekill/ortekill.c
===================================================================
--- orte/tools/ortekill/ortekill.c	(revision 16968)
+++ orte/tools/ortekill/ortekill.c	(working copy)
@@ -53,7 +53,6 @@
 
 #include "orte/orte_constants.h"
 
-#include "orte/class/orte_pointer_array.h"
 #include "orte/util/proc_info.h"
 #include "orte/util/sys_info.h"
 #include "orte/util/universe_setup_file_io.h"
Index: orte/tools/orteboot/orteboot.c
===================================================================
--- orte/tools/orteboot/orteboot.c	(revision 16968)
+++ orte/tools/orteboot/orteboot.c	(working copy)
@@ -55,7 +55,6 @@
 
 #include "orte/orte_constants.h"
 
-#include "orte/class/orte_pointer_array.h"
 #include "orte/util/proc_info.h"
 #include "orte/util/sys_info.h"
 #include "orte/util/universe_setup_file_io.h"
Index: orte/tools/orterun/orterun.c
===================================================================
--- orte/tools/orterun/orterun.c	(revision 16968)
+++ orte/tools/orterun/orterun.c	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -65,7 +65,7 @@
 #include "opal/runtime/opal.h"
 #include "opal/util/os_path.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/util/proc_info.h"
 #include "orte/util/sys_info.h"
 #include "orte/util/universe_setup_file_io.h"
@@ -102,7 +102,7 @@
 static struct opal_event sigusr2_handler;
 #endif  /* __WINDOWS__ */
 static orte_jobid_t jobid = ORTE_JOBID_INVALID;
-static orte_pointer_array_t *apps_pa;
+static opal_pointer_array_t *apps_pa;
 static bool wait_for_job_completion = true;
 static char *orterun_basename = NULL;
 static int max_display_aborted = 1;
@@ -362,12 +362,14 @@
     parse_globals(argc, argv, &cmd_line);
     OBJ_DESTRUCT(&cmd_line);
 
+    apps_pa = OBJ_NEW(opal_pointer_array_t);
+
     /* If we're still here, parse each app */
     parse_locals(argc, argv);
 
     /* Convert the list of apps to an array of orte_app_context_t
        pointers */
-    array_size = orte_pointer_array_get_size(apps_pa);
+    array_size = opal_pointer_array_get_size(apps_pa);
     apps = (orte_app_context_t**)malloc(sizeof(orte_app_context_t *) * array_size);
     if (NULL == apps) {
         opal_show_help("help-orterun.txt", "orterun:call-failed",
@@ -377,7 +379,7 @@
     num_apps = 0;
     for (i = 0; i < array_size; ++i) {
         apps[num_apps] = (orte_app_context_t *)
-            orte_pointer_array_get_item(apps_pa, i);
+            opal_pointer_array_get_item(apps_pa, i);
         if (NULL != apps[num_apps]) {
             num_apps++;
         }
@@ -406,8 +408,7 @@
      */
     if (ORTE_SUCCESS != (rc = orte_init(ORTE_INFRASTRUCTURE))) {
         ORTE_ERROR_LOG(rc);
-        free(apps);
-        return rc;
+        goto DONE;
     }    
     
     /* If we have a prefix, then modify the PATH and
@@ -467,7 +468,7 @@
         ORTE_ERROR_LOG(rc);
         opal_show_help("help-orterun.txt", "orterun:precondition", false,
                        orterun_basename, NULL, NULL, rc);
-        return rc;
+        goto DONE;
     }
 
     /* setup our receive functions so we can fully participate in daemon
@@ -480,7 +481,7 @@
                                   ORTE_RML_NON_PERSISTENT, orte_daemon_recv_routed, NULL);
     if (rc != ORTE_SUCCESS && rc != ORTE_ERR_NOT_IMPLEMENTED) {
         ORTE_ERROR_LOG(rc);
-        return rc;
+        goto DONE;
     }
     /* setup to listen for commands sent specifically to me, even though I would probably
      * be the one sending them! Unfortunately, since I am a participating daemon,
@@ -490,7 +491,7 @@
     rc = orte_rml.recv_buffer_nb(ORTE_NAME_WILDCARD, ORTE_RML_TAG_DAEMON, ORTE_RML_NON_PERSISTENT, orte_daemon_recv, NULL);
     if (rc != ORTE_SUCCESS && rc != ORTE_ERR_NOT_IMPLEMENTED) {
         ORTE_ERROR_LOG(rc);
-        return rc;
+        goto DONE;
     }
     
     /* Prep to start the application */
@@ -1246,10 +1247,10 @@
     opal_argv_append(&temp_argc, &temp_argv, argv[0]);
     /* Make the max size of the array be INT_MAX because we may be
        parsing an app file, in which case we don't know how many
-       entries there will be.  The max size of an orte_pointer_array
+       entries there will be.  The max size of an opal_pointer_array
        is only a safety net; it only initially allocates block_size
        entries (2, in this case) */
-    orte_pointer_array_init(&apps_pa, 1, INT_MAX, 2);
+    opal_pointer_array_init(apps_pa, 1, INT_MAX, 2);
 
     /* NOTE: This bogus env variable is necessary in the calls to
        create_app(), below.  See comment immediately before the
@@ -1274,10 +1275,9 @@
                     exit(1);
                 }
                 if (made_app) {
-                    orte_std_cntr_t dummy;
                     app->idx = app_num;
                     ++app_num;
-                    orte_pointer_array_add(&dummy, apps_pa, app);
+                    opal_pointer_array_add(apps_pa, app);
                 }
 
                 /* Reset the temps */
@@ -1300,10 +1300,9 @@
             exit(1);
         }
         if (made_app) {
-            orte_std_cntr_t dummy;
             app->idx = app_num;
             ++app_num;
-            orte_pointer_array_add(&dummy, apps_pa, app);
+            opal_pointer_array_add(apps_pa, app);
         }
     }
     if (NULL != env) {
@@ -1316,11 +1315,11 @@
        course -- yay opal_environ_merge()).  */
 
     if (NULL != global_mca_env) {
-        size1 = orte_pointer_array_get_size(apps_pa);
+        size1 = opal_pointer_array_get_size(apps_pa);
         /* Iterate through all the apps */
         for (j = 0; j < size1; ++j) {
             app = (orte_app_context_t *)
-                orte_pointer_array_get_item(apps_pa, j);
+                opal_pointer_array_get_item(apps_pa, j);
             if (NULL != app) {
                 /* Use handy utility function */
                 env = opal_environ_merge(global_mca_env, app->env);
@@ -1345,16 +1344,16 @@
     if (NULL != global_mca_env) {
         env = global_mca_env;
     } else {
-        if (orte_pointer_array_get_size(apps_pa) >= 1) {
+        if (opal_pointer_array_get_size(apps_pa) >= 1) {
             /* Remember that pointer_array's can be padded with NULL
                entries; so only use the app's env if there is exactly
                1 non-NULL entry */
             app = (orte_app_context_t *)
-                orte_pointer_array_get_item(apps_pa, 0);
+                opal_pointer_array_get_item(apps_pa, 0);
             if (NULL != app) {
                 env = app->env;
-                for (j = 1; j < orte_pointer_array_get_size(apps_pa); ++j) {
-                    if (NULL != orte_pointer_array_get_item(apps_pa, j)) {
+                for (j = 1; j < opal_pointer_array_get_size(apps_pa); ++j) {
+                    if (NULL != opal_pointer_array_get_item(apps_pa, j)) {
                         env = NULL;
                         break;
                     }
@@ -1925,10 +1924,9 @@
                 opal_argv_free(tmp_env);
             }
             if (made_app) {
-                orte_std_cntr_t dummy;
                 app->idx = app_num;
                 ++app_num;
-                orte_pointer_array_add(&dummy, apps_pa, app);
+                opal_pointer_array_add(apps_pa, app);
             }
         }
     } while (!feof(fp));
Index: orte/class/Makefile.am
===================================================================
--- orte/class/Makefile.am	(revision 16968)
+++ orte/class/Makefile.am	(working copy)
@@ -21,10 +21,8 @@
 
 headers += \
         class/orte_proc_table.h \
-        class/orte_pointer_array.h \
         class/orte_value_array.h
 
 libopen_rte_la_SOURCES += \
         class/orte_proc_table.c \
-        class/orte_pointer_array.c \
         class/orte_value_array.c
Index: orte/dss/dss_compare.c
===================================================================
--- orte/dss/dss_compare.c	(revision 16968)
+++ orte/dss/dss_compare.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -42,7 +42,7 @@
     /* Lookup the compare function for this type and call it */
 
     if (!(type < orte_dss_types->size) ||
-         (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, type)))) {
+         (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, type)))) {
         ORTE_ERROR_LOG(ORTE_ERR_UNKNOWN_DATA_TYPE);
         return ORTE_ERR_UNKNOWN_DATA_TYPE;
     }
Index: orte/dss/dss_open_close.c
===================================================================
--- orte/dss/dss_open_close.c	(revision 16968)
+++ orte/dss/dss_open_close.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -36,7 +36,7 @@
 int orte_dss_verbose = -1;  /* by default disabled */
 int orte_dss_initial_size;
 int orte_dss_threshold_size;
-orte_pointer_array_t *orte_dss_types;
+opal_pointer_array_t *orte_dss_types;
 orte_data_type_t orte_dss_num_reg_types;
 orte_dss_buffer_type_t default_buf_type;
 
@@ -188,8 +188,8 @@
     mca_base_param_lookup_int(id, &orte_dss_threshold_size);
 
     /* Setup the types array */
-
-    if (ORTE_SUCCESS != (rc = orte_pointer_array_init(&orte_dss_types,
+    orte_dss_types = OBJ_NEW(opal_pointer_array_t);
+    if (ORTE_SUCCESS != (rc = opal_pointer_array_init(orte_dss_types,
                                                       ORTE_DSS_ID_DYNAMIC,
                                                       ORTE_DSS_ID_MAX,
                                                       ORTE_DSS_ID_MAX))) {
@@ -486,12 +486,12 @@
 
 int orte_dss_close(void)
 {
-    orte_std_cntr_t i;
+    int i;
 
     orte_dss_initialized = false;
 
-    for (i = 0 ; i < orte_pointer_array_get_size(orte_dss_types) ; ++i) {
-        orte_dss_type_info_t *info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, i);
+    for (i = 0 ; i < opal_pointer_array_get_size(orte_dss_types) ; ++i) {
+        orte_dss_type_info_t *info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, i);
         if (NULL != info) {
             OBJ_RELEASE(info);
         }
Index: orte/dss/dss_print.c
===================================================================
--- orte/dss/dss_print.c	(revision 16968)
+++ orte/dss/dss_print.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -43,7 +43,7 @@
     /* Lookup the print function for this type and call it */
 
     if (!(type < orte_dss_types->size) ||
-          (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, type)))) {
+          (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, type)))) {
         ORTE_ERROR_LOG(ORTE_ERR_UNKNOWN_DATA_TYPE);
         return ORTE_ERR_UNKNOWN_DATA_TYPE;
     }
Index: orte/dss/dss_internal_functions.c
===================================================================
--- orte/dss/dss_internal_functions.c	(revision 16968)
+++ orte/dss/dss_internal_functions.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
@@ -28,7 +28,7 @@
 
 #include "opal/util/output.h"
 
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 #include "orte/mca/errmgr/errmgr.h"
 
 #include "orte/dss/dss_internal.h"
@@ -119,7 +119,7 @@
 
     /* Lookup the pack function for the actual orte_data_type type and call it */
     
-    if (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, ORTE_DATA_TYPE_T))) {
+    if (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, ORTE_DATA_TYPE_T))) {
         ORTE_ERROR_LOG(ORTE_ERR_PACK_FAILURE);
         return ORTE_ERR_PACK_FAILURE;
     }
@@ -139,7 +139,7 @@
     
     /* Lookup the unpack function for the actual orte_data_type type and call it */
     
-    if (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, ORTE_DATA_TYPE_T))) {
+    if (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, ORTE_DATA_TYPE_T))) {
         ORTE_ERROR_LOG(ORTE_ERR_PACK_FAILURE);
         return ORTE_ERR_PACK_FAILURE;
     }
Index: orte/dss/dss_lookup.c
===================================================================
--- orte/dss/dss_lookup.c	(revision 16968)
+++ orte/dss/dss_lookup.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -34,7 +34,7 @@
         return NULL;
     }
 
-    info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, type);
+    info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, type);
     if (NULL != info) { /* type found on list */
         name = strdup(info->odti_name);
         return name;
Index: orte/dss/dss_size.c
===================================================================
--- orte/dss/dss_size.c	(revision 16968)
+++ orte/dss/dss_size.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -43,7 +43,7 @@
     /* Lookup the size function for this type and call it */
 
     if (!(type < orte_dss_types->size) ||
-          (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, type)))) {
+          (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, type)))) {
         ORTE_ERROR_LOG(ORTE_ERR_UNKNOWN_DATA_TYPE);
         return ORTE_ERR_UNKNOWN_DATA_TYPE;
     }
Index: orte/dss/dss_copy.c
===================================================================
--- orte/dss/dss_copy.c	(revision 16968)
+++ orte/dss/dss_copy.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -46,7 +46,7 @@
    /* Lookup the copy function for this type and call it */
 
     if (!(type < orte_dss_types->size) ||
-        (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, type)))) {
+        (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, type)))) {
         ORTE_ERROR_LOG(ORTE_ERR_UNKNOWN_DATA_TYPE);
         return ORTE_ERR_UNKNOWN_DATA_TYPE;
     }
Index: orte/dss/dss_pack.c
===================================================================
--- orte/dss/dss_pack.c	(revision 16968)
+++ orte/dss/dss_pack.c	(working copy)
@@ -80,7 +80,7 @@
 
     /* Lookup the pack function for this type and call it */
 
-    if (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, type))) {
+    if (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, type))) {
         ORTE_ERROR_LOG(ORTE_ERR_PACK_FAILURE);
         return ORTE_ERR_PACK_FAILURE;
     }
@@ -445,7 +445,7 @@
         
         /* Lookup the pack function for this type and call it */
 
-        if (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, sdv[i]->type))) {
+        if (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, sdv[i]->type))) {
             ORTE_ERROR_LOG(ORTE_ERR_PACK_FAILURE);
             return ORTE_ERR_PACK_FAILURE;
         }
Index: orte/dss/dss_release.c
===================================================================
--- orte/dss/dss_release.c	(revision 16968)
+++ orte/dss/dss_release.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -41,7 +41,7 @@
     /* Lookup the release function for this type and call it */
 
     if (!(value->type < orte_dss_types->size) ||
-        (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, value->type)))) {
+        (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, value->type)))) {
         ORTE_ERROR_LOG(ORTE_ERR_UNKNOWN_DATA_TYPE);
         return;
     }
Index: orte/dss/dss_internal.h
===================================================================
--- orte/dss/dss_internal.h	(revision 16968)
+++ orte/dss/dss_internal.h	(working copy)
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -23,7 +23,7 @@
 #include "orte_config.h"
 
 #include "orte/orte_constants.h"
-#include "orte/class/orte_pointer_array.h"
+#include "opal/class/opal_pointer_array.h"
 
 #include "orte/dss/dss.h"
 
@@ -205,7 +205,7 @@
 extern int orte_dss_verbose;
 extern int orte_dss_initial_size;
 extern int orte_dss_threshold_size;
-extern orte_pointer_array_t *orte_dss_types;
+extern opal_pointer_array_t *orte_dss_types;
 extern orte_data_type_t orte_dss_num_reg_types;
 
     /*
Index: orte/dss/dss_unpack.c
===================================================================
--- orte/dss/dss_unpack.c	(revision 16968)
+++ orte/dss/dss_unpack.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -129,7 +129,7 @@
 
     /* Lookup the unpack function for this type and call it */
 
-    if (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, type))) {
+    if (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, type))) {
         ORTE_ERROR_LOG(ORTE_ERR_UNPACK_FAILURE);
         return ORTE_ERR_UNPACK_FAILURE;
     }
@@ -554,7 +554,7 @@
 
         /* Lookup the unpack function for this type and call it */
 
-        if (NULL == (info = (orte_dss_type_info_t*)orte_pointer_array_get_item(orte_dss_types, ddv[i]->type))) {
+        if (NULL == (info = (orte_dss_type_info_t*)opal_pointer_array_get_item(orte_dss_types, ddv[i]->type))) {
             ORTE_ERROR_LOG(ORTE_ERR_PACK_FAILURE);
             return ORTE_ERR_PACK_FAILURE;
         }
Index: orte/dss/dss_register.c
===================================================================
--- orte/dss/dss_register.c	(revision 16968)
+++ orte/dss/dss_register.c	(working copy)
@@ -2,7 +2,7 @@
  * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
  *                         University Research and Technology
  *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
+ * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
@@ -95,7 +95,7 @@
     info->odti_print_fn = print_fn;
     info->odti_release_fn = release_fn;
     info->odti_structured = structured;
-    if (ORTE_SUCCESS != (ret = orte_pointer_array_set_item(orte_dss_types, *type, info))) {
+    if (ORTE_SUCCESS != (ret = opal_pointer_array_set_item(orte_dss_types, *type, info))) {
         ORTE_ERROR_LOG(ret);
     }
 

