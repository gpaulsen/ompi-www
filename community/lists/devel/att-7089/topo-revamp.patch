Index: ompi/mpi/c/cart_sub.c
===================================================================
--- ompi/mpi/c/cart_sub.c	(revision 22197)
+++ ompi/mpi/c/cart_sub.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -70,7 +70,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer on this communicator */
-    func = comm->c_topo->topo_cart_sub;
+    func = comm->c_topo_module->topom_cart_sub;
 
     /* call the function */
     err = func(comm, remain_dims, new_comm);
Index: ompi/mpi/c/cart_shift.c
===================================================================
--- ompi/mpi/c/cart_shift.c	(revision 22197)
+++ ompi/mpi/c/cart_shift.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -75,7 +75,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer on this communicator */
-    func = comm->c_topo->topo_cart_shift;
+    func = comm->c_topo_module->topom_cart_shift;
 
     /* call the function */
     err = func(comm, direction, disp, rank_source, rank_dest);
Index: ompi/mpi/c/graph_map.c
===================================================================
--- ompi/mpi/c/graph_map.c	(revision 22197)
+++ ompi/mpi/c/graph_map.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -74,7 +74,7 @@
     }
     else {
         /* map the function pointer to do the right thing */
-        func = comm->c_topo->topo_graph_map;
+        func = comm->c_topo_module->topom_graph_map;
 	
         /* call the function */
         if ( MPI_SUCCESS != 
Index: ompi/mpi/c/cart_get.c
===================================================================
--- ompi/mpi/c/cart_get.c	(revision 22197)
+++ ompi/mpi/c/cart_get.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -70,7 +70,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer to do the right thing */
-    func = comm->c_topo->topo_cart_get;
+    func = comm->c_topo_module->topom_cart_get;
 
     /* all arguments are checked and now call the back end function */
     err = func(comm, maxdims, dims, periods, coords);
Index: ompi/mpi/c/graph_neighbors_count.c
===================================================================
--- ompi/mpi/c/graph_neighbors_count.c	(revision 22197)
+++ ompi/mpi/c/graph_neighbors_count.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -74,7 +74,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer to do the right thing */
-    func = comm->c_topo->topo_graph_neighbors_count;
+    func = comm->c_topo_module->topom_graph_neighbors_count;
 
     /* call the function */
     err = func(comm, rank, nneighbors);
Index: ompi/mpi/c/cart_map.c
===================================================================
--- ompi/mpi/c/cart_map.c	(revision 22197)
+++ ompi/mpi/c/cart_map.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -74,7 +74,7 @@
     }
     else {
         /* get the function pointer on this communicator */
-        func = comm->c_topo->topo_cart_map;
+        func = comm->c_topo_module->topom_cart_map;
 	
         /* call the function */
         err = func(comm, ndims, dims, periods, newrank);
Index: ompi/mpi/c/cartdim_get.c
===================================================================
--- ompi/mpi/c/cartdim_get.c	(revision 22197)
+++ ompi/mpi/c/cartdim_get.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -69,7 +70,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer on this communicator */
-    func = comm->c_topo->topo_cartdim_get;
+    func = comm->c_topo_module->topom_cartdim_get;
 
     /* call the function */
     err = func(comm, ndims);
Index: ompi/mpi/c/graph_neighbors.c
===================================================================
--- ompi/mpi/c/graph_neighbors.c	(revision 22197)
+++ ompi/mpi/c/graph_neighbors.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -76,7 +76,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* neighbors the function pointer to do the right thing */
-    func = comm->c_topo->topo_graph_neighbors;
+    func = comm->c_topo_module->topom_graph_neighbors;
 
     /* call the function */
     err = func(comm, rank, maxneighbors, neighbors);
Index: ompi/mpi/c/cart_coords.c
===================================================================
--- ompi/mpi/c/cart_coords.c	(revision 22197)
+++ ompi/mpi/c/cart_coords.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -75,7 +75,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer on this communicator */
-    func = comm->c_topo->topo_cart_coords;
+    func = comm->c_topo_module->topom_cart_coords;
 
     /* call the function */
     err = func(comm, rank, maxdims, coords);
Index: ompi/mpi/c/cart_rank.c
===================================================================
--- ompi/mpi/c/cart_rank.c	(revision 22197)
+++ ompi/mpi/c/cart_rank.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007-2008 Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -63,7 +63,7 @@
         }
         /* Per MPI-2.1, coords is only relevant if the dimension of
            the cartesian comm is >0 */
-        if ((NULL == coords && comm->c_topo_comm->mtc_ndims_or_nnodes >= 1) ||
+        if ((NULL == coords && comm->c_topo_comm->mtc.cart.ndims >= 1) ||
             (NULL == rank)){
             return OMPI_ERRHANDLER_INVOKE (comm, MPI_ERR_ARG,
                                           FUNC_NAME);
@@ -71,10 +71,10 @@
 
         /* Check if coords[i] is within the acceptable range if
            dimension i is not periodic */
-        for (i = 0; i < comm->c_topo_comm->mtc_ndims_or_nnodes; ++i) {
-            if (!comm->c_topo_comm->mtc_periods_or_edges[i] &&
+        for (i = 0; i < comm->c_topo_comm->mtc.cart.ndims; ++i) {
+            if (!comm->c_topo_comm->mtc.cart.periods[i] &&
                 (coords[i] < 0 || 
-                 coords[i] >= comm->c_topo_comm->mtc_dims_or_index[i])) {
+                 coords[i] >= comm->c_topo_comm->mtc.cart.dims[i])) {
                 return OMPI_ERRHANDLER_INVOKE(comm, MPI_ERR_ARG, FUNC_NAME);
             }
         }
@@ -83,7 +83,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer on this communicator */
-    func = comm->c_topo->topo_cart_rank;
+    func = comm->c_topo_module->topom_cart_rank;
 
     /* call the function */
     err = func(comm, coords, rank);
Index: ompi/mpi/c/graphdims_get.c
===================================================================
--- ompi/mpi/c/graphdims_get.c	(revision 22197)
+++ ompi/mpi/c/graphdims_get.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -70,7 +70,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer to do the right thing */
-    func = comm->c_topo->topo_graphdims_get;
+    func = comm->c_topo_module->topom_graphdims_get;
 
     /* call the function */
     err = func(comm, nnodes, nedges);
Index: ompi/mpi/c/graph_get.c
===================================================================
--- ompi/mpi/c/graph_get.c	(revision 22197)
+++ ompi/mpi/c/graph_get.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -70,7 +70,7 @@
     OPAL_CR_ENTER_LIBRARY();
 
     /* get the function pointer to do the right thing */
-    func = comm->c_topo->topo_graph_get;
+    func = comm->c_topo_module->topom_graph_get;
 
     /* call the function */
     err = func(comm, maxindex, maxedges, index, edges);
Index: ompi/tools/wrappers/ompi_wrapper_script.in
===================================================================
--- ompi/tools/wrappers/ompi_wrapper_script.in	(revision 22197)
+++ ompi/tools/wrappers/ompi_wrapper_script.in	(working copy)
@@ -48,7 +48,7 @@
 my $preproc_flags = $include_flag . $includedir;
 my $comp_flags = "";
 my $linker_flags = $libdir_flag . $libdir . " " . $extra_ldflags;
-my $libs = "-lmpi -lopen-rte -lopen-pal " . $extra_libs;
+my $libs = "-lmpi " . $extra_libs;
 
 
 sub check_env {
Index: ompi/communicator/comm_init.c
===================================================================
--- ompi/communicator/comm_init.c	(revision 22197)
+++ ompi/communicator/comm_init.c	(working copy)
@@ -11,7 +11,7 @@
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
  * Copyright (c) 2006-2009 University of Houston. All rights reserved.
- * Copyright (c) 2007      Cisco Systems, Inc. All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc. All rights reserved.
  * Copyright (c) 2009      Sun Microsystems, Inc. All rights reserved.
  * $COPYRIGHT$
  * 
@@ -301,10 +301,9 @@
     comm->c_remote_group = NULL;
     comm->error_handler  = NULL;
     comm->c_pml_comm     = NULL;
-    comm->c_topo         = NULL;
+    comm->c_topo_module  = NULL;
     comm->c_topo_component = NULL;
     comm->c_topo_comm    = NULL; 
-    comm->c_topo_module  = NULL;
 
     /* A keyhash will be created if/when an attribute is cached on
        this communiucator */
@@ -345,14 +344,14 @@
 
             /* check for all pointers and free them */
 
-            if (NULL != comm->c_topo_comm->mtc_dims_or_index) {
-                free(comm->c_topo_comm->mtc_dims_or_index);
-                comm->c_topo_comm->mtc_dims_or_index = NULL;
+            if (NULL != comm->c_topo_comm->mtc.cart.dims) {
+                free(comm->c_topo_comm->mtc.cart.dims);
+                comm->c_topo_comm->mtc.cart.dims = NULL;
             }
         
-            if (NULL != comm->c_topo_comm->mtc_periods_or_edges) {
-                free(comm->c_topo_comm->mtc_periods_or_edges);
-                comm->c_topo_comm->mtc_periods_or_edges = NULL;
+            if (NULL != comm->c_topo_comm->mtc.cart.periods) {
+                free(comm->c_topo_comm->mtc.cart.periods);
+                comm->c_topo_comm->mtc.cart.periods = NULL;
             }
 
             if (NULL != comm->c_topo_comm->mtc_coords) {
@@ -366,8 +365,6 @@
 
     }
 
-    comm->c_topo_component = NULL;
-
     /* Tell the PML that this communicator is done.
        MCA_PML_CALL(add_comm()) was called explicitly in
        ompi_comm_init() when setting up COMM_WORLD and COMM_SELF; it's
@@ -387,8 +384,12 @@
         MCA_PML_CALL(del_comm (comm));
     }
 
-    /* Release topology information */
-    mca_topo_base_comm_unselect(comm);
+    /* Release topology module */
+    if (NULL != comm->c_topo_module) {
+        OBJ_RELEASE(comm->c_topo_module);
+        comm->c_topo_module = NULL;
+        comm->c_topo_component = NULL;
+    }
 
     if (NULL != comm->c_local_group) {
         ompi_group_decrement_proc_count (comm->c_local_group);
@@ -396,7 +397,8 @@
         comm->c_local_group = NULL;
         if ( OMPI_COMM_IS_INTRA(comm) ) {
             /* We have to decrement the ref count on the remote group
-               even if it is identical to the local one in case of intra-comm */
+               even if it is identical to the local one in case of
+               intra-comm */
             OBJ_RELEASE ( comm->c_remote_group );
             comm->c_remote_group = NULL;
         }
Index: ompi/communicator/communicator.h
===================================================================
--- ompi/communicator/communicator.h	(revision 22197)
+++ ompi/communicator/communicator.h	(working copy)
@@ -10,7 +10,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2006      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2006-2009 Cisco Systems, Inc.  All rights reserved.
  * Copyright (c) 2006-2009 University of Houston.  All rights reserved.
  * Copyright (c) 2009      Sun Microsystems, Inc. All rights reserved.
  * $COPYRIGHT$
@@ -118,23 +118,23 @@
     /* Attributes */
     struct opal_hash_table_t       *c_keyhash;
 
-    /**< inscribing cube dimension */
+    /* Inscribing cube dimension */
     int c_cube_dim;
 
-    /* Hooks for topo module to hang things */
-    mca_base_component_t *c_topo_component;
+    /* Standard information about the selected topology module (or NULL
+       if this is not a cart or graph communicator) */
+    struct mca_topo_base_comm_2_1_0_t* c_topo_comm; 
 
-    const struct mca_topo_base_module_1_0_0_t* c_topo; 
-    /**< structure of function pointers */
+    /* Selected topo module function pointers (or NULL if this is not
+       a cart or graph communicator) */
+    struct mca_topo_base_module_2_1_0_t* c_topo_module;
 
-    struct mca_topo_base_comm_1_0_0_t* c_topo_comm; 
-    /**< structure containing basic information about the topology */
+    /* Component of the selected topo module (used for COMM_DUP and
+       the like, to try to select the same topo module in the new
+       communicator) */
+    mca_base_component_t* c_topo_component;
 
-    struct mca_topo_base_module_comm_t *c_topo_module;
-    /**< module specific data */
-
     /* index in Fortran <-> C translation array */
-
     int c_f_to_c_index;
 
 #ifdef OMPI_WANT_PERUSE
Index: ompi/communicator/comm.c
===================================================================
--- ompi/communicator/comm.c	(revision 22197)
+++ ompi/communicator/comm.c	(working copy)
@@ -10,7 +10,7 @@
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
  * Copyright (c) 2007-2009 University of Houston. All rights reserved.
- * Copyright (c) 2007-2008 Cisco Systems, Inc. All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc. All rights reserved.
  * Copyright (c) 2009      Sun Microsystems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
@@ -1338,53 +1338,43 @@
 
     /* allocate the data for the common good */
 
-    new_comm->c_topo_comm = (mca_topo_base_comm_t*)malloc(sizeof(mca_topo_base_comm_t));
+    new_comm->c_topo_comm = (mca_topo_base_comm_t*)
+        malloc(sizeof(mca_topo_base_comm_t));
     if (NULL == new_comm->c_topo_comm) {
         OBJ_RELEASE(new_comm);
         return OMPI_ERR_OUT_OF_RESOURCE;
     }
+    new_comm->c_flags |= cart_or_graph;
 
-    /* select the topology component on the communicator */
-
-    if (OMPI_SUCCESS != (ret = mca_topo_base_comm_select (new_comm, NULL))) {
-        /* OBJ_RELEASE also frees new_comm->c_topo_comm */
-        OBJ_RELEASE(new_comm);
-        return ret;
+    if (OMPI_COMM_IS_CART(new_comm)) {
+        new_comm->c_topo_comm->mtc.cart.ndims = ndims_or_nnodes;
+        new_comm->c_topo_comm->mtc.cart.dims = NULL;
+        new_comm->c_topo_comm->mtc.cart.periods = NULL;
+    } else {
+        new_comm->c_topo_comm->mtc.graph.nnodes = ndims_or_nnodes;
+        new_comm->c_topo_comm->mtc.graph.index = NULL;
+        new_comm->c_topo_comm->mtc.graph.edges = NULL;
     }
-
-    /* since the topo component has initialised, let us now initialise
-     * the topo comm structure */
-    new_comm->c_flags |= cart_or_graph;
-
-    new_comm->c_topo_comm->mtc_ndims_or_nnodes = ndims_or_nnodes;
-    new_comm->c_topo_comm->mtc_dims_or_index = NULL;
-    new_comm->c_topo_comm->mtc_periods_or_edges = NULL;
     new_comm->c_topo_comm->mtc_reorder = reorder;
     new_comm->c_topo_comm->mtc_coords = NULL;
 
     /* MPI-2.1 allows 0-dimension cartesian communicators, so prevent
        a 0-byte malloc -- leave dims_or_index as NULL */
     if (!(OMPI_COMM_CART == cart_or_graph && 0 == ndims_or_nnodes)) {
-        new_comm->c_topo_comm->mtc_dims_or_index = 
+        new_comm->c_topo_comm->mtc.cart.dims = 
             (int *) malloc(sizeof(int) * ndims_or_nnodes);
-        if (NULL == new_comm->c_topo_comm->mtc_dims_or_index) {
+        if (NULL == new_comm->c_topo_comm->mtc.cart.dims) {
             ompi_comm_free (&new_comm);
             *comm_topo = new_comm;
             return OMPI_ERROR;
         }
-        memcpy (new_comm->c_topo_comm->mtc_dims_or_index,
+        memcpy (new_comm->c_topo_comm->mtc.cart.dims,
                 dims_or_index, ndims_or_nnodes * sizeof(int));
     }
 
-    /* Now the topology component has been selected, let the component
-     * re-arrange the proc ranks if need be. This is a down-call into
-     * the topo component and does not have anything to do with this
-     * level */
-
-    /* first, copy the proc structure from the previous communicator
-     * over to the new one. the topology component can then work on
-     * this and rearrange it as it deems fit.
-     */
+    /* Copy the proc structure from the previous communicator over to
+       the new one.  The topology module is then able to work on this
+       copy and rearrange it as it deems fit. */
     num_procs = old_comm->c_local_group->grp_proc_count;
     topo_procs = (ompi_proc_t **)malloc (num_procs * sizeof(ompi_proc_t *));
 
@@ -1394,39 +1384,35 @@
                 num_procs * sizeof(ompi_proc_t *));
     }
     else {
-        proc_list = (ompi_proc_t **) calloc (old_comm->c_local_group->grp_proc_count, 
-                                             sizeof (ompi_proc_t *));
-        for(i=0 ; i<old_comm->c_local_group->grp_proc_count ; i++)
+        proc_list = (ompi_proc_t **) 
+            calloc (old_comm->c_local_group->grp_proc_count, 
+                    sizeof (ompi_proc_t *));
+        for (i=0 ; i<old_comm->c_local_group->grp_proc_count ; i++) {
             proc_list[i] = ompi_group_peer_lookup(old_comm->c_local_group,i);
+        }
         
-        memcpy (topo_procs, 
-                proc_list,
-                num_procs * sizeof(ompi_proc_t *));
-        
+        memcpy(topo_procs, 
+               proc_list,
+               num_procs * sizeof(ompi_proc_t *));
     }
     if ( NULL != proc_list ) {
         free ( proc_list );
     }
     new_rank = old_comm->c_local_group->grp_my_rank;
 
+    /* Cartesian communicator; copy of the right data to the common
+       information */
     if (OMPI_COMM_CART == cart_or_graph) {
-
-        /* A cartesian system has been requested. Call the right function */
-
-        /* Note that we fill in the basic information, i.e, copy the
-         * information which was provided to us over into the
-         * structure. The base component functions are free to change
-         * it as they deem fit */
-
         if (ndims_or_nnodes > 0) {
-            new_comm->c_topo_comm->mtc_periods_or_edges =
+            new_comm->c_topo_comm->mtc.cart.periods =
                 (int*) malloc(sizeof(int) * ndims_or_nnodes);
-            if (NULL == new_comm->c_topo_comm->mtc_periods_or_edges) {
+            if (NULL == new_comm->c_topo_comm->mtc.cart.periods) {
                 ompi_comm_free (&new_comm);
                 *comm_topo = new_comm;
+                OBJ_RELEASE(new_comm);
                 return OMPI_ERR_OUT_OF_RESOURCE;
             }
-            memcpy (new_comm->c_topo_comm->mtc_periods_or_edges,
+            memcpy (new_comm->c_topo_comm->mtc.cart.periods,
                     periods_or_edges, ndims_or_nnodes * sizeof(int));
 
             new_comm->c_topo_comm->mtc_coords = 
@@ -1434,54 +1420,60 @@
             if (NULL == new_comm->c_topo_comm->mtc_coords) {
                 ompi_comm_free (&new_comm);
                 *comm_topo = new_comm;
+                OBJ_RELEASE(new_comm);
                 return OMPI_ERR_OUT_OF_RESOURCE;
             }
         }
+    } 
 
-        if (OMPI_SUCCESS != 
-            (ret = new_comm->c_topo->topo_cart_create (new_comm->c_topo_comm,
-                                                       &num_procs,
-                                                       topo_procs,
-                                                       &new_rank,
-                                                       ndims_or_nnodes,
-                                                       dims_or_index,
-                                                       periods_or_edges,
-                                                       reorder))) {
-            return ret;
-        }
-
-    } else if (OMPI_COMM_GRAPH == cart_or_graph) {
-
-        /* A graph system has been requested. Call the right function */
-
-        /* Note that we fill in the basic information, i.e, copy the
-         * information which was provided to us over into the
-         * structure. The base component functions are free to change
-         * it as they deem fit */
-
-        new_comm->c_topo_comm->mtc_periods_or_edges = (int *)
+    /* Graph communicator; copy of the right data to the common
+       information */
+    else if (OMPI_COMM_GRAPH == cart_or_graph) {
+        new_comm->c_topo_comm->mtc.graph.edges = (int *)
                 malloc (sizeof(int) * dims_or_index[ndims_or_nnodes-1]);
-        if (NULL == new_comm->c_topo_comm->mtc_periods_or_edges) {
+        if (NULL == new_comm->c_topo_comm->mtc.graph.edges) {
             ompi_comm_free (&new_comm);
             *comm_topo = new_comm;
             return OMPI_ERROR;
         }
-        memcpy (new_comm->c_topo_comm->mtc_periods_or_edges,
-                periods_or_edges, dims_or_index[ndims_or_nnodes-1] * sizeof(int));
+        memcpy (new_comm->c_topo_comm->mtc.graph.edges,
+                periods_or_edges, dims_or_index[ndims_or_nnodes-1] * 
+                sizeof(int));
+    }
 
-        if (OMPI_SUCCESS != 
-            (ret = new_comm->c_topo->topo_graph_create (new_comm->c_topo_comm,
-                                                        &num_procs,
-                                                        topo_procs,
-                                                        &new_rank,
-                                                        ndims_or_nnodes,
-                                                        dims_or_index,
-                                                        periods_or_edges,
-                                                        reorder))) {
-            return ret;
-        }
+    /* Now that all the "common" topology information has been filled
+       in on the communicator, select a topology module. */
+    if (OMPI_SUCCESS != (ret = mca_topo_base_comm_select(new_comm, NULL))) {
+        /* OBJ_RELEASE also frees new_comm->c_topo_comm */
+        OBJ_RELEASE(new_comm);
+        return ret;
+    }
 
+    /* Now let that topology module rearrange procs/ranks if it wants
+       to */    
+    if (OMPI_COMM_CART == cart_or_graph) {
+        ret = new_comm->c_topo_module->topom_cart_create(new_comm->c_topo_comm,
+                                                         &num_procs,
+                                                         topo_procs,
+                                                         &new_rank,
+                                                         ndims_or_nnodes,
+                                                         dims_or_index,
+                                                         periods_or_edges,
+                                                         reorder);
+    } else if (OMPI_COMM_GRAPH == cart_or_graph) {
+        ret = new_comm->c_topo_module->topom_graph_create(new_comm->c_topo_comm,
+                                                          &num_procs,
+                                                          topo_procs,
+                                                          &new_rank,
+                                                          ndims_or_nnodes,
+                                                          dims_or_index,
+                                                          periods_or_edges,
+                                                          reorder);
     }
+    if (OMPI_SUCCESS != ret) {
+        OBJ_RELEASE(new_comm);
+        return ret;
+    }
 
     /* Determine context id. It is identical to f_2_c_handle */
 
@@ -1499,8 +1491,7 @@
         return ret;
     }
 
-
-    /* Now, the topology component has been selected and the group
+    /* Now, the topology module has been selected and the group
      * which has the topology information has been created. All we
      * need to do now is to fill the rest of the information into the
      * communicator. The following steps are not just similar to
@@ -1613,53 +1604,62 @@
        information from the previous one.  Remember that MPI-2.1
        allows for 0-dimensional Cartesian communicators. */
 
-    newt->mtc_ndims_or_nnodes = oldt->mtc_ndims_or_nnodes;
     newt->mtc_reorder = oldt->mtc_reorder;
-    if (OMPI_COMM_IS_CART(oldcomm) && 0 == oldt->mtc_ndims_or_nnodes) {
-        newt->mtc_dims_or_index = NULL;
-        newt->mtc_periods_or_edges = NULL;
-        newt->mtc_coords = NULL;
-        return MPI_SUCCESS;
-    }
+    if (OMPI_COMM_IS_CART(oldcomm)) {
+        newt->mtc.cart.ndims = oldt->mtc.cart.ndims;
+        if (0 == oldt->mtc.cart.ndims) {
+            newt->mtc.cart.dims = NULL;
+            newt->mtc.cart.periods = NULL;
+            newt->mtc_coords = NULL;
+            return MPI_SUCCESS;
+        }
 
-    newt->mtc_dims_or_index = 
-        (int *)malloc(sizeof(int) * newt->mtc_ndims_or_nnodes);
-    if (NULL == newt->mtc_dims_or_index) {
-        return OMPI_ERR_OUT_OF_RESOURCE;
-    }
-    memcpy (newt->mtc_dims_or_index, oldt->mtc_dims_or_index,
-            newt->mtc_ndims_or_nnodes * sizeof(int));
+        newt->mtc.cart.dims = 
+            (int *) malloc(sizeof(int) * newt->mtc.cart.ndims);
+        if (NULL == newt->mtc.cart.dims) {
+            return OMPI_ERR_OUT_OF_RESOURCE;
+        }
+        memcpy (newt->mtc.cart.dims, oldt->mtc.cart.dims,
+                newt->mtc.cart.ndims * sizeof(int));
 
-    /* Note that the length of the mtc_periods_or_edges array is
-       different depending whether it's a cartesian or graph */
-    if (OMPI_COMM_IS_CART(oldcomm)) {
-        newt->mtc_periods_or_edges =
-            (int*) malloc (sizeof(int) * oldt->mtc_ndims_or_nnodes);
-        if (NULL == newt->mtc_periods_or_edges) {
+        newt->mtc.cart.periods =
+            (int*) malloc (sizeof(int) * oldt->mtc.cart.ndims);
+        if (NULL == newt->mtc.cart.periods) {
             return OMPI_ERR_OUT_OF_RESOURCE;
         }
         
         newt->mtc_coords =
-            (int *)malloc(sizeof(int)*
-                          newcomm->c_topo_comm->mtc_ndims_or_nnodes);   
+            (int *) malloc(sizeof(int)*
+                           newcomm->c_topo_comm->mtc.cart.ndims);   
         if (NULL == newt->mtc_coords) {
             return OMPI_ERROR;
         }
-        memcpy(newt->mtc_periods_or_edges, oldt->mtc_periods_or_edges, 
-               sizeof(int) * oldt->mtc_ndims_or_nnodes);
+        memcpy(newt->mtc.cart.periods, oldt->mtc.cart.periods, 
+               sizeof(int) * oldt->mtc.cart.ndims);
 
         memcpy (newt->mtc_coords, oldt->mtc_coords,
-                sizeof(int) * newt->mtc_ndims_or_nnodes);
+                sizeof(int) * newt->mtc.cart.ndims);
     } else {
-        int index = oldt->mtc_dims_or_index[oldt->mtc_ndims_or_nnodes-1];
+        int index;
+
+        newt->mtc.graph.nnodes = oldt->mtc.graph.nnodes;
+        newt->mtc.graph.index = 
+            (int *) malloc(sizeof(int) * newt->mtc.graph.nnodes);
+        if (NULL == newt->mtc.graph.index) {
+            return OMPI_ERR_OUT_OF_RESOURCE;
+        }
+        memcpy (newt->mtc.graph.index, oldt->mtc.graph.index,
+                newt->mtc.graph.nnodes * sizeof(int));
+
+        index = oldt->mtc.graph.index[oldt->mtc.graph.nnodes - 1];
         index = (index > 0) ? index : -index;
-        newt->mtc_periods_or_edges =
-            (int*) malloc (sizeof(int)*index);
-        if (NULL == newt->mtc_periods_or_edges) {
+        newt->mtc.graph.edges =
+            (int*) malloc (sizeof(int) * index);
+        if (NULL == newt->mtc.graph.edges) {
             return OMPI_ERR_OUT_OF_RESOURCE;
         }
         
-        memcpy(newt->mtc_periods_or_edges, oldt->mtc_periods_or_edges, 
+        memcpy(newt->mtc.graph.edges, oldt->mtc.graph.edges, 
                sizeof(int) * index );
 
         newt->mtc_coords = NULL;
Index: ompi/mca/topo/topo.h
===================================================================
--- ompi/mca/topo/topo.h	(revision 22197)
+++ ompi/mca/topo/topo.h	(working copy)
@@ -10,6 +10,7 @@
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
  * Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -26,136 +27,114 @@
 #include "opal/mca/base/base.h"
 #include "ompi/communicator/communicator.h"
 
+
 /*
- * ******************************************************************
- * ********** Use in components that are of type topo v2.0.0 ********
- * ******************************************************************
- */
-#define MCA_TOPO_BASE_VERSION_2_0_0 \
-  MCA_BASE_VERSION_2_0_0, \
-  "topo", 2, 0, 0
+ * Forward reference to ompi_proc_t.
+ */ 
+struct ompi_proc_t;
+
+
 /*
- * ******************************************************************
- * **************************** Macro ends **************************
- * ******************************************************************
+ * Component function typedefs 
  */
 
-/*
- * These are the component function prototypes. These function pointers
- * go into the component structure. These functions (query() and finalize()
- * are called during topo_base_select(). Each component is query() ied
- * and subsequently, all the unselected components are finalize() 'ed 
- * so that any *stuff* they did during query() can be undone. By
- * similar logic, finalize() is also called on the component which
- * was selected when the communicator is being destroyed.
- *
- * So, to sum it up, every component carries 4 functions:
- * 1. open() - called during MPI_INIT
- * 2. close() - called during MPI_FINALIZE
- * 3. query() - called to select a particular component
- * 4. finalize() - called when actions taken during query have 
- *                 to be undone
+/* 
+ * Initial component query, called during mca_topo_base_open.
  */
+typedef int (*mca_topo_base_component_init_query_2_1_0_fn_t)
+    (bool enable_progress_threads,
+     bool enable_mpi_threads);
 
 /*
- * **************** component struct *******************************
- * *********** These functions go in the component struct **********
- * **************** component struct *******************************
- */ 
-typedef int (*mca_topo_base_component_init_query_1_0_0_fn_t)
-  (bool enable_progress_threads,
-   bool enable_mpi_threads);
+ * Communicator query, called during cart and graph communicator
+ * creation.
+ */
+typedef struct mca_topo_base_module_2_1_0_t*
+(*mca_topo_base_component_comm_query_2_1_0_fn_t) 
+    (struct ompi_communicator_t *comm, int *priority);
 
-typedef struct mca_topo_base_module_1_0_0_t*
-  (*mca_topo_base_component_comm_query_1_0_0_fn_t) (int *priority);
-                                            
-                            
-typedef int (*mca_topo_base_component_comm_unquery_1_0_0_fn_t) 
-  (struct ompi_communicator_t *comm);
-
 /*
- * ****************** component struct ******************************
- * Structure for topo v2.0.0 components.This is chained to MCA v2.0.0
- * ****************** component struct ******************************
+ * Structure for topo v2.1.0 components.This is chained to MCA v2.0.0
  */  
-struct mca_topo_base_component_2_0_0_t {
-    mca_base_component_t topom_version;
-    mca_base_component_data_t topom_data;
+typedef struct mca_topo_base_component_2_1_0_t {
+    mca_base_component_t topoc_version;
+    mca_base_component_data_t topoc_data;
 
-    mca_topo_base_component_init_query_1_0_0_fn_t topom_init_query;
-    mca_topo_base_component_comm_query_1_0_0_fn_t topom_comm_query;
-    mca_topo_base_component_comm_unquery_1_0_0_fn_t topom_comm_unquery;
-};
-typedef struct mca_topo_base_component_2_0_0_t mca_topo_base_component_2_0_0_t;       
-typedef mca_topo_base_component_2_0_0_t mca_topo_base_component_t;
+    mca_topo_base_component_init_query_2_1_0_fn_t topoc_init_query;
+    mca_topo_base_component_comm_query_2_1_0_fn_t topoc_comm_query;
+} mca_topo_base_component_2_1_0_t;       
+typedef mca_topo_base_component_2_1_0_t mca_topo_base_component_t;
 
 /*
- * ******************************************************************
- * *********************** component struct ends here ***************
- * ******************************************************************
- */ 
+ * Struct for holding graph communicator information
+ */
+typedef struct mca_topo_base_comm_graph_2_1_0_t {
+    int nnodes;
+    int *index;
+    int *edges;
+} mca_topo_base_comm_graph_2_1_0_t;
+
 /*
- * ******************************************************************
- * *********************** information structure  *******************
- * Note for component authors:
- * If you find that this is not the most convinient form of
- * representing your topology, then please feel free to define your
- * own structure in which this struct is the first element. That way,
- * type casting can be used to communicate between 2 different topo
- * components. Note that this representation must be filled up no
- * matter what the actual topo structure might be.
- * ******************************************************************
- */ 
+ * Struct for holding cartesian communicator information
+ */
+typedef struct mca_topo_base_comm_cart_2_1_0_t {
+    int ndims;
+    int *dims;
+    int *periods;
+} mca_topo_base_comm_cart_2_1_0_t;
 
-struct mca_topo_base_comm_1_0_0_t {
+/*
+ * This union must be declared (can't be anonymous in the struct where
+ * it is used) because we need to be able to resolve it and find field
+ * offsets in the ompi/debuggers/ stuff (i.e., so that debuggers can
+ * parse/understand the individual fields on communicators).
+ */
+typedef union mca_topo_base_comm_cg_union_2_1_0_t {
+    mca_topo_base_comm_graph_2_1_0_t graph;
+    mca_topo_base_comm_cart_2_1_0_t cart;
+} mca_topo_base_comm_cg_union_2_1_0_t;
 
-    /* The first section represents data which is passed on to the 
-     * structure by the user when creating the topology. This info
-     * is cached on so that if required another component can create the
-     * topology again when comm_dup fails to pick the same component */
+/*
+ * This structure is hung off the communicator at comm->c_topo_comm.
+ * It is a basic set of information that is available to all topo
+ * modules (and they don't need to store this information themselves).  
+ *
+ * This information is filled in on the communicator before
+ * comm_query() is invoked (i.e., the component comm_query() function
+ * can rely on this information being there to help make its
+ * decision).
+ */
+typedef struct mca_topo_base_comm_2_1_0_t {
+    /* This union caches the parameters passed when the communicator
+       was created.  Look in comm->c_flags to figure out whether this
+       is a cartesian or graph communicator. */
+    mca_topo_base_comm_cg_union_2_1_0_t mtc;
 
-     int mtc_ndims_or_nnodes; /**< Number of cart dimensions or graph nodes */
-     int *mtc_dims_or_index; /**< Cart dimensions or graph indices */
-     int *mtc_periods_or_edges; /**< whether this was a periodic cart or graph */
-     bool mtc_reorder; /**< Whether the re-ordering is allowed */
+    /* Whether re-ordering is allowed */
+    bool mtc_reorder;
 
-    /* The second section is used by the unity component since it does not 
-     * hang its own structure off the communicator. Any component which wishes
-     * to use the base/topo_base* functions to fill in their unimplemented
-     * functions should and must fill this portion up */
+    /* This field is initialized to NULL when the communicator is
+       created.  It is filled in by topo_base_cart_create() and is
+       used by the test of the topo_base_cart_*() functions.  If this
+       is a graph communicator or the topo_base_cart_*() functions are
+       not being used, then this field should be left NULL. */
+     int *mtc_coords;
+} mca_topo_base_comm_2_1_0_t;
+typedef mca_topo_base_comm_2_1_0_t mca_topo_base_comm_t;
 
-     int *mtc_coords; /**< Cart coordinates */
-};
-typedef struct mca_topo_base_comm_1_0_0_t mca_topo_base_comm_1_0_0_t;
-typedef mca_topo_base_comm_1_0_0_t mca_topo_base_comm_t;
 
 /*
- * ******************************************************************
- * *********************** information structure   ******************
- * ******************************************************************
- */ 
-
-struct ompi_proc_t;
-
-/*
- * ***********************************************************************
- * ************************  Interface function definitions **************
- * These are the typedefs for the function pointers to various topology
- * backend functions which will be used by the various topology components
- * ***********************************************************************
+ * Module function typedefs
  */
-typedef int (*mca_topo_base_module_init_1_0_0_fn_t)
-  (struct ompi_communicator_t *comm);
-            
-typedef int (*mca_topo_base_module_finalize_1_0_0_fn_t)
-  (struct ompi_communicator_t *comm);
 
+/* Back end for MPI_CART_COORDS */
 typedef int (*mca_topo_base_module_cart_coords_fn_t) 
                     (struct ompi_communicator_t *comm, 
                      int rank, 
                      int maxdims, 
                      int *coords);
 
+/* Back end for MPI_CART_CREATE */
 typedef int (*mca_topo_base_module_cart_create_fn_t)
                     (mca_topo_base_comm_t *topo_data,
                      int *proc_count, 
@@ -166,6 +145,7 @@
                      int *periods, 
                      bool redorder);
 
+/* Back end for MPI_CART_GET */
 typedef int (*mca_topo_base_module_cart_get_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int maxdims, 
@@ -173,10 +153,12 @@
                      int *periods, 
                      int *coords);
 
+/* Back end for MPI_CARTDIM_GET */
 typedef int (*mca_topo_base_module_cartdim_get_fn_t)
                     (struct ompi_communicator_t *comm,
                      int *ndims);
 
+/* Back end for MPI_CART_MAP */
 typedef int (*mca_topo_base_module_cart_map_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int ndims, 
@@ -184,11 +166,13 @@
                      int *periods, 
                      int *newrank);
 
+/* Back end for MPI_CART_RANK */
 typedef int (*mca_topo_base_module_cart_rank_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int *coords, 
                      int *rank);
 
+/* Back end for MPI_CART_SHIFT */
 typedef int (*mca_topo_base_module_cart_shift_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int direction, 
@@ -196,11 +180,13 @@
                      int *rank_source, 
                      int *rank_dest);
 
+/* Back end for MPI_CART_SUB */
 typedef int (*mca_topo_base_module_cart_sub_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int *remain_dims, 
                      struct ompi_communicator_t ** new_comm);
 
+/* Back end for MPI_GRAPH_CREATE */
 typedef int (*mca_topo_base_module_graph_create_fn_t)
                     (mca_topo_base_comm_t *topo_data, 
                      int *proc_count,
@@ -211,6 +197,7 @@
                      int *edges, 
                      bool reorder);
 
+/* Back end for MPI_GRAPH_GET */
 typedef int (*mca_topo_base_module_graph_get_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int maxindex, 
@@ -218,6 +205,7 @@
                      int *index, 
                      int *edges);
 
+/* Back end for MPI_GRAPH_MAP */
 typedef int (*mca_topo_base_module_graph_map_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int nnodes, 
@@ -225,65 +213,72 @@
                      int *edges, 
                      int *newrank);
 
+/* Back end for MPI_GRAPHDIMS_GET */
 typedef int (*mca_topo_base_module_graphdims_get_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int *nnodes, 
                      int *nnedges);
 
+/* Back end for MPI_GRAPH_NEIGHBORS */
 typedef int (*mca_topo_base_module_graph_neighbors_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int rank, 
                      int maxneighbors, 
                      int *neighbors);
 
+/* Back end for MPI_GRAPH_NEIGHBORS_COUNT */
 typedef int (*mca_topo_base_module_graph_neighbors_count_fn_t)
                     (struct ompi_communicator_t *comm, 
                      int rank, 
                      int *nneighbors);
 
 /*
- * ***********************************************************************
- * ******************** Interface function definitions end  **************
- * ***********************************************************************
+ * Topo module structure.  If a given topo module needs to cache more
+ * information than what is contained in the mca_topo_base_comm_*_t,
+ * it should create its own module struct that uses
+ * mca_topo_base_module_2_1_0_t as a super.
  */ 
+typedef struct mca_topo_base_module_2_1_0_t {
+    /* Make this structure be an object so that it has a constructor
+       and destructor. */
+    opal_object_t super;
 
-/*
- * ***********************************************************************
- * ***************************  module structure *************************
- * ***********************************************************************
- */ 
-struct mca_topo_base_module_1_0_0_t {
-    /* 
-     * Per-communicator initialization function. This is called only
-     * on the module which is selected. The finalize corresponding to
-     * this function is present on the component struct above 
-     */
-    mca_topo_base_module_init_1_0_0_fn_t topo_module_init;
-    mca_topo_base_module_finalize_1_0_0_fn_t topo_module_finalize;
+    /* Pointer back to the communicator that this module is attached
+       to.  Automatically filled in by mca_topo_base_comm_select()
+       after the module is returned by topo_component.comm_query(). */
+    struct ompi_communicator_t *topom_comm;
 
-    /* Graph related functions */
-    mca_topo_base_module_cart_coords_fn_t topo_cart_coords;
-    mca_topo_base_module_cart_create_fn_t topo_cart_create;
-    mca_topo_base_module_cart_get_fn_t topo_cart_get;
-    mca_topo_base_module_cartdim_get_fn_t topo_cartdim_get;
-    mca_topo_base_module_cart_map_fn_t topo_cart_map;
-    mca_topo_base_module_cart_rank_fn_t topo_cart_rank;
-    mca_topo_base_module_cart_shift_fn_t topo_cart_shift;
-    mca_topo_base_module_cart_sub_fn_t topo_cart_sub;
-    mca_topo_base_module_graph_create_fn_t topo_graph_create;
-    mca_topo_base_module_graph_get_fn_t topo_graph_get;
-    mca_topo_base_module_graph_map_fn_t topo_graph_map;
-    mca_topo_base_module_graphdims_get_fn_t topo_graphdims_get;
-    mca_topo_base_module_graph_neighbors_fn_t topo_graph_neighbors;
-    mca_topo_base_module_graph_neighbors_count_fn_t topo_graph_neighbors_count;
-};
-typedef struct mca_topo_base_module_1_0_0_t mca_topo_base_module_1_0_0_t;
-typedef mca_topo_base_module_1_0_0_t mca_topo_base_module_t;
-/*
- * ***********************************************************************
- * *******************  component actions structure ends *****************
- * ***********************************************************************
- */ 
+    /* Cart and graph related functions */
+    mca_topo_base_module_cart_coords_fn_t topom_cart_coords;
+    mca_topo_base_module_cart_create_fn_t topom_cart_create;
+    mca_topo_base_module_cart_get_fn_t topom_cart_get;
+    mca_topo_base_module_cartdim_get_fn_t topom_cartdim_get;
+    mca_topo_base_module_cart_map_fn_t topom_cart_map;
+    mca_topo_base_module_cart_rank_fn_t topom_cart_rank;
+    mca_topo_base_module_cart_shift_fn_t topom_cart_shift;
+    mca_topo_base_module_cart_sub_fn_t topom_cart_sub;
+    mca_topo_base_module_graph_create_fn_t topom_graph_create;
+    mca_topo_base_module_graph_get_fn_t topom_graph_get;
+    mca_topo_base_module_graph_map_fn_t topom_graph_map;
+    mca_topo_base_module_graphdims_get_fn_t topom_graphdims_get;
+    mca_topo_base_module_graph_neighbors_fn_t topom_graph_neighbors;
+    mca_topo_base_module_graph_neighbors_count_fn_t topom_graph_neighbors_count;
+} mca_topo_base_module_2_1_0_t;
 
+/* Per guidence in mca.h, use the unversioned struct name if you just
+   want to always keep up with the most recent version of the
+   interace. */
+typedef mca_topo_base_module_2_1_0_t mca_topo_base_module_t;
+OMPI_DECLSPEC OBJ_CLASS_DECLARATION(mca_topo_base_module_t);
     
+
+/*
+ * ******************************************************************
+ * ********** Use in components that are of type topo v2.1.0 ********
+ * ******************************************************************
+ */
+#define MCA_TOPO_BASE_VERSION_2_1_0 \
+  MCA_BASE_VERSION_2_0_0, \
+  "topo", 2, 1, 0
+
 #endif /* MCA_TOPO_H */

Property changes on: ompi/mca/topo/unity
___________________________________________________________________
Modified: svn:ignore
   - Makefile
Makefile.in
*.lo
*.la
.libs
.deps
topo-unity-version.h*

   + Makefile
Makefile.in
*.lo
*.la
.libs
.deps


Index: ompi/mca/topo/unity/topo_unity.h
===================================================================
--- ompi/mca/topo/unity/topo_unity.h	(revision 22197)
+++ ompi/mca/topo/unity/topo_unity.h	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -37,17 +38,22 @@
  */
 BEGIN_C_DECLS
 
-int mca_topo_unity_component_init_query(bool enable_progress_threads,
-                                        bool enable_mpi_threads);
-struct mca_topo_base_module_1_0_0_t *
-    mca_topo_unity_component_comm_query (int *priority);
-int mca_topo_unity_component_comm_unquery (struct ompi_communicator_t *comm);
+/*
+ * Public component instance
+ */
+OMPI_MODULE_DECLSPEC extern mca_topo_base_component_2_1_0_t 
+    mca_topo_unity_component;
 
-int mca_topo_unity_module_init (struct ompi_communicator_t *comm);
-int mca_topo_unity_module_finalize (struct ompi_communicator_t *comm);
+/* 
+ * A unique module class just so that we can have a constructor
+ */
+typedef struct {
+    mca_topo_base_module_t super;
+} mca_topo_unity_module_t;
 
-OMPI_MODULE_DECLSPEC extern mca_topo_base_component_2_0_0_t mca_topo_unity_component;
+OBJ_CLASS_DECLARATION(mca_topo_unity_module_t);
 
+
 /*
  * ******************************************************************
  * ********* functions which are implemented in this module *********
@@ -60,17 +66,17 @@
  * functions. They are ofcourse free to implement all of them too :-)
  * ******************************************************************
  */ 
-int mca_topo_unity_cart_map (struct ompi_communicator_t *comm,
-                             int ndims,
-                             int *dims,
-                             int *periods,
+int mca_topo_unity_cart_map(struct ompi_communicator_t *comm,
+                            int ndims,
+                            int *dims,
+                            int *periods,
+                            int *newrank);
+
+int mca_topo_unity_graph_map(struct ompi_communicator_t *comm,
+                             int nnodes,
+                             int *index,
+                             int *edges,
                              int *newrank);
-
-int mca_topo_unity_graph_map (struct ompi_communicator_t *comm,
-                              int nnodes,
-                              int *index,
-                              int *edges,
-                              int *newrank);
 /*
  * ******************************************************************
  * ************ functions implemented in this module end ************
Index: ompi/mca/topo/unity/topo_unity_module.c
===================================================================
--- ompi/mca/topo/unity/topo_unity_module.c	(revision 0)
+++ ompi/mca/topo/unity/topo_unity_module.c	(revision 0)
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2006 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */
+
+#include "ompi_config.h"
+
+#include <stdio.h>
+
+#include "mpi.h"
+#include "ompi/communicator/communicator.h"
+#include "ompi/mca/topo/topo.h"
+#include "ompi/mca/topo/base/base.h"
+#include "ompi/mca/topo/unity/topo_unity.h"
+
+/*
+ * Local functions
+ */
+static void unity_module_constructor(mca_topo_unity_module_t *u);
+
+
+/*
+ * Global variables
+ */
+OBJ_CLASS_INSTANCE(mca_topo_unity_module_t, mca_topo_base_module_t,
+                   unity_module_constructor, NULL);
+
+
+static void unity_module_constructor(mca_topo_unity_module_t *u)
+{
+    mca_topo_base_module_t *m = &(u->super);
+
+    /* The only functions we set at the cart_map and graph_map; all
+       the rest are set to NULL (and therefore automatically filled in
+       by the base) */
+
+    m->topom_cart_coords = NULL;
+    m->topom_cart_create = NULL;
+    m->topom_cart_get = NULL;
+    m->topom_cartdim_get = NULL;
+    m->topom_cart_map = mca_topo_unity_cart_map;
+    m->topom_cart_rank = NULL;
+    m->topom_cart_shift = NULL;
+    m->topom_cart_sub = NULL;
+    m->topom_graph_create = NULL;
+    m->topom_graph_get = NULL;
+    m->topom_graph_map = mca_topo_unity_graph_map;
+    m->topom_graphdims_get = NULL;
+    m->topom_graph_neighbors = NULL;
+    m->topom_graph_neighbors_count = NULL;
+}
Index: ompi/mca/topo/unity/Makefile.am
===================================================================
--- ompi/mca/topo/unity/Makefile.am	(revision 22197)
+++ ompi/mca/topo/unity/Makefile.am	(working copy)
@@ -9,6 +9,7 @@
 #                         University of Stuttgart.  All rights reserved.
 # Copyright (c) 2004-2005 The Regents of the University of California.
 #                         All rights reserved.
+# Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
 # $COPYRIGHT$
 # 
 # Additional copyrights may follow
@@ -22,7 +23,7 @@
     topo_unity.h \
     topo_unity_cart_map.c \
     topo_unity_graph_map.c \
-    topo_unity.c \
+    topo_unity_module.c \
     topo_unity_component.c
 
 # Make the output library in this directory, and name it either
Index: ompi/mca/topo/unity/topo_unity.c
===================================================================
--- ompi/mca/topo/unity/topo_unity.c	(revision 22197)
+++ ompi/mca/topo/unity/topo_unity.c	(working copy)
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
- *                         University Research and Technology
- *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2006 The University of Tennessee and The University
- *                         of Tennessee Research Foundation.  All rights
- *                         reserved.
- * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
- *                         University of Stuttgart.  All rights reserved.
- * Copyright (c) 2004-2005 The Regents of the University of California.
- *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
- * $COPYRIGHT$
- * 
- * Additional copyrights may follow
- * 
- * $HEADER$
- *
- * These symbols are in a file by themselves to provide nice linker
- * semantics. Since linkers generally pull in symbols by object fules,
- * keeping these symbols as the only symbols in this file prevents
- * utility programs such as "ompi_info" from having to import entire
- * modules just to query their version and parameters
- */
-#include "ompi_config.h"
-
-
-#include <stdio.h>
-
-#include "mpi.h"
-#include "ompi/communicator/communicator.h"
-#include "ompi/mca/topo/topo.h"
-#include "ompi/mca/topo/base/base.h"
-#include "ompi/mca/topo/unity/topo_unity.h"
-
-/*
- * *******************************************************************
- * ************************ actions structure ************************
- * *******************************************************************
- */
-static mca_topo_base_module_1_0_0_t unity =  {
-    mca_topo_unity_module_init, /* initalise after being selected */
-    mca_topo_unity_module_finalize, /* close a module on a communicator */
-    NULL, /* topo_cart_coords */
-    NULL, /* topo_cart_create */
-    NULL, /* topo_cart_get */
-    NULL, /* topo_cartdim_get */
-    mca_topo_unity_cart_map,
-    NULL, /* topo_cart_rank */
-    NULL, /* topo_cart_shift */
-    NULL, /* topo_cart_sub */
-    NULL, /* topo_graph_create */
-    NULL, /* topo_graph_get */
-    mca_topo_unity_graph_map,
-    NULL, /* topo_graphdims_get */
-    NULL, /* topo_graph_neighbors */
-    NULL /* topo_graph_neighbors_count */
-};
-/*
- * *******************************************************************
- * ************************* structure ends **************************
- * *******************************************************************
- */
-
-int mca_topo_unity_component_init_query(bool enable_progress_threads,
-                                        bool enable_mpi_threads)
-{
-    /* Nothing to do */
-   
-   return OMPI_SUCCESS;
-}      
-
-struct mca_topo_base_module_1_0_0_t *
-mca_topo_unity_component_comm_query (int *priority)
-{
-   /* this is the lowest module on the totem pole */
-   *priority = 0;
-
-   /* the check as to whether this is an inter communicator 
-    * or and intra communicator has to be done before reaching
-    * here. this is my solemn opinion. Therefore I am ignoring 
-    * the checks here */
-   return &unity;
-}
-
-int mca_topo_unity_component_comm_unquery (struct ompi_communicator_t *comm)
-{    
-   /* This function might be needed for some purposes later. for now it
-    * does not have anything to do since there are no steps which need 
-    * to be undone if this module is not selected */
-
-   return OMPI_SUCCESS;
-}
-
-int mca_topo_unity_module_init (struct ompi_communicator_t *comm)
-{
-    /* Nothing to do -- the setup is done in communicator/comm.c
-       (setup the comm->c_topo_comm data) */
-
-    return OMPI_SUCCESS;
-}
-
-   
-int mca_topo_unity_module_finalize (struct ompi_communicator_t *comm) 
-{
-    /* Nothing to do -- the teardown is done in
-       communicator/comm_init.c (free the comm->c_topo_comm data) */
-
-    return OMPI_SUCCESS;
-}
Index: ompi/mca/topo/unity/topo_unity_component.c
===================================================================
--- ompi/mca/topo/unity/topo_unity_component.c	(revision 22197)
+++ ompi/mca/topo/unity/topo_unity_component.c	(working copy)
@@ -9,17 +9,12 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
  * 
  * $HEADER$
- *
- * These symbols are in a file by themselves to provide nice linker
- * semantics. Since linkers generally pull in symbols by object fules,
- * keeping these symbols as the only symbols in this file prevents
- * utility programs such as "ompi_info" from having to import entire
- * modules just to query their version and parameters
  */
 
 #include "ompi_config.h"
@@ -28,38 +23,66 @@
 /*
  * Public string showing the topo unity module version number
  */
-
 const char *mca_topo_unity_component_version_string = 
     "Open MPI unity topology MCA component version" OMPI_VERSION;
 
 /*
- * *******************************************************************
- * ****** this is the structure that defines the component **************
- * *******************************************************************
- * this structure contains the component version information along with
- * some meta data and function pointers which allow a component to 
- * interact with the MCA framework. component open() and close() are 
- * called during MPI_INIT and MPI_FINALIZE respectively and query()
- * and finalize() are called during creation/destruction of a comm
- * *******************************************************************
+ * Local functions
  */
-mca_topo_base_component_2_0_0_t mca_topo_unity_component = 
+static int init_query(bool enable_progress_threads,
+                      bool enable_mpi_threads);
+static struct mca_topo_base_module_2_1_0_t *
+  comm_query(ompi_communicator_t *comm, int *priority);
+
+
+/*
+ * Public component structure
+ */
+mca_topo_base_component_2_1_0_t mca_topo_unity_component = 
 {
     {
-        MCA_TOPO_BASE_VERSION_2_0_0,
+        MCA_TOPO_BASE_VERSION_2_1_0,
 
-        "unity",                      /* component name */
-        OMPI_MAJOR_VERSION, /* major version */
-        OMPI_MINOR_VERSION, /* minor version */
-        OMPI_RELEASE_VERSION, /* release version */
-        NULL,   /* fp to open the component */
-        NULL    /* fp to close the component */
+        "unity",
+        OMPI_MAJOR_VERSION,
+        OMPI_MINOR_VERSION,
+        OMPI_RELEASE_VERSION,
+
+        /* NULLs for the rest of the function pointers */
     },
+
     {
         /* The component is checkpoint ready */
         MCA_BASE_METADATA_PARAM_CHECKPOINT
     },
-    mca_topo_unity_component_init_query,      /* get thread level */
-    mca_topo_unity_component_comm_query,      /* get priority and actions */
-    mca_topo_unity_component_comm_unquery     /* undo what was done by previous function */
+
+    /* Component functions */
+    init_query,
+    comm_query,
 };
+
+
+static int init_query(bool enable_progress_threads,
+                      bool enable_mpi_threads)
+{
+    /* This component runs in all cases */
+   
+    return OMPI_SUCCESS;
+}      
+
+
+static struct mca_topo_base_module_2_1_0_t *
+comm_query(ompi_communicator_t *comm, int *priority)
+{
+    mca_topo_unity_module_t *unity = OBJ_NEW(mca_topo_unity_module_t);
+    if (NULL == unity) {
+        return NULL;
+    }
+
+    /* Very low priority in case there's another topo that can map to
+       the underlying hardware that has a higher priority */
+    *priority = 1;
+    return &(unity->super);
+}
+
+
Index: ompi/mca/topo/base/topo_base_cart_rank.c
===================================================================
--- ompi/mca/topo/base/topo_base_cart_rank.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_cart_rank.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -53,8 +53,8 @@
     factor = 1;
     prank = 0;
 
-    i = comm->c_topo_comm->mtc_ndims_or_nnodes - 1;
-    d = comm->c_topo_comm->mtc_dims_or_index + i;
+    i = comm->c_topo_comm->mtc.cart.ndims - 1;
+    d = comm->c_topo_comm->mtc.cart.dims + i;
     c = coords + i;
 
    for (; i >= 0; --i, --c, --d) {
Index: ompi/mca/topo/base/topo_base_close.c
===================================================================
--- ompi/mca/topo/base/topo_base_close.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_close.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -34,17 +35,17 @@
        already closed */
 
     if (mca_topo_base_components_opened_valid) {
-        mca_base_components_close (mca_topo_base_output,
-                                &mca_topo_base_components_opened, NULL);
+        mca_base_components_close(mca_topo_base_output,
+                                  &mca_topo_base_components_opened, NULL);
         mca_topo_base_components_opened_valid = false;
     } else if (mca_topo_base_components_available_valid) {
-        mca_base_components_close (mca_topo_base_output,
-                                &mca_topo_base_components_available, NULL);
+        mca_base_components_close(mca_topo_base_output,
+                                  &mca_topo_base_components_available, NULL);
         mca_topo_base_components_available_valid = false;
     }
 
     /* Close the output stream for this framework */
-    opal_output_close (mca_topo_base_output);
+    opal_output_close(mca_topo_base_output);
 
     /*
      * All done
Index: ompi/mca/topo/base/topo_base_graph_neighbors_count.c
===================================================================
--- ompi/mca/topo/base/topo_base_graph_neighbors_count.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_graph_neighbors_count.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -35,9 +36,9 @@
                                      int rank,
                                      int *nneighbors){
 
-   *nneighbors = comm->c_topo_comm->mtc_dims_or_index[rank];
+   *nneighbors = comm->c_topo_comm->mtc.graph.index[rank];
    if (rank > 0) {
-      *nneighbors -= comm->c_topo_comm->mtc_dims_or_index[rank - 1];
+      *nneighbors -= comm->c_topo_comm->mtc.graph.index[rank - 1];
     }
 
     return MPI_SUCCESS;
Index: ompi/mca/topo/base/topo_base_cart_create.c
===================================================================
--- ompi/mca/topo/base/topo_base_cart_create.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_cart_create.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -54,14 +54,14 @@
    int dim;
    int i;
    int *p;
-   int *coords = topo_data->mtc_coords;
+   int *coords;
    int dummy_rank;
 
    nprocs = 1;
-   p = topo_data->mtc_dims_or_index;
+   p = topo_data->mtc.cart.dims;
 
    /* Calculate the number of processes in this grid */
-   for (i = 0; i < topo_data->mtc_ndims_or_nnodes; ++i, ++p) {
+   for (i = 0; i < topo_data->mtc.cart.ndims; ++i, ++p) {
       if(*p <= 0) {
           return OMPI_ERROR;
        }
@@ -86,13 +86,10 @@
    }
 
    /* Have to replace this with the actual function body itself */
-   p = topo_data->mtc_dims_or_index;
-   coords =  topo_data->mtc_coords;
+   p = topo_data->mtc.cart.dims;
+   coords = topo_data->mtc_coords;
    dummy_rank = *new_rank;
-
-   for (i=0; 
-        (i < topo_data->mtc_ndims_or_nnodes && i < ndims); 
-        ++i, ++p) {
+   for (i=0; i < topo_data->mtc.cart.ndims && i < ndims; ++i, ++p) {
         dim = *p;
         nprocs /= dim;
         *coords++ = dummy_rank / nprocs;
Index: ompi/mca/topo/base/topo_base_graphdims_get.c
===================================================================
--- ompi/mca/topo/base/topo_base_graphdims_get.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_graphdims_get.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -38,7 +39,7 @@
                               int *nedges){
 
     *nodes = ompi_comm_size(comm);
-    *nedges = comm->c_topo_comm->mtc_dims_or_index[*nodes -1]; 
+    *nedges = comm->c_topo_comm->mtc.graph.index[*nodes -1]; 
 
     return MPI_SUCCESS;
 }
Index: ompi/mca/topo/base/topo_base_find_available.c
===================================================================
--- ompi/mca/topo/base/topo_base_find_available.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_find_available.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -37,7 +38,7 @@
                       mca_base_component_priority_list_item_t *entry,
                       bool enable_progress_threads,
                       bool enable_mpi_threads);
-static int init_query_2_0_0(const mca_base_component_t *component,
+static int init_query_2_1_0(const mca_base_component_t *component,
                             mca_base_component_priority_list_item_t *entry,
                             bool enable_progress_threads,
                             bool enable_mpi_threads);
@@ -58,55 +59,54 @@
        in mca_topo_base_components_opened, which was established in 
        mca_topo_base_open */
 
-     for (found = false, 
-            p = opal_list_remove_first (&mca_topo_base_components_opened);
-          NULL != p;
-          p = opal_list_remove_first (&mca_topo_base_components_opened)) {
-         entry = OBJ_NEW(mca_base_component_priority_list_item_t);
-         entry->super.cli_component =
-           ((mca_base_component_list_item_t *)p)->cli_component;
+    for (found = false, 
+             p = opal_list_remove_first(&mca_topo_base_components_opened);
+         NULL != p;
+         p = opal_list_remove_first(&mca_topo_base_components_opened)) {
+        entry = OBJ_NEW(mca_base_component_priority_list_item_t);
+        entry->super.cli_component =
+            ((mca_base_component_list_item_t *) p)->cli_component;
 
-         /* Now for this entry, we have to determine the thread level. Call 
-            a subroutine to do the job for us */
+        /* Now for this entry, we have to determine the thread
+           level. Call a subroutine to do the job for us */
+        if (OMPI_SUCCESS == init_query(entry->super.cli_component, entry,
+                                       enable_progress_threads,
+                                       enable_mpi_threads)) {
+            /* Save the results in the list. The priority is not relvant at 
+               this point in time. But we save the thread arguments so that
+               the initial selection algorithm can negotiate overall thread
+               level for this process */
+            entry->cpli_priority = 0;
+            opal_list_append(&mca_topo_base_components_available,
+                             (opal_list_item_t *) entry);
+            found = true;
+        } else {
+            /* The component does not want to run, so close it. Its close()
+               has already been invoked. Close it out of the DSO repository
+               (if it is there in the repository) */
+            mca_base_component_repository_release(entry->super.cli_component);
+            OBJ_RELEASE(entry);
+        }
+        /* Free entry from the "opened" list */
+        OBJ_RELEASE(p);
+    }
 
-         if (OMPI_SUCCESS == init_query(entry->super.cli_component, entry,
-                                        enable_progress_threads,
-                                        enable_mpi_threads)) {
-             /* Save the results in the list. The priority is not relvant at 
-                this point in time. But we save the thread arguments so that
-                the initial selection algorithm can negotiate overall thread
-                level for this process */
-             entry->cpli_priority = 0;
-             opal_list_append (&mca_topo_base_components_available,
-                               (opal_list_item_t *) entry);
-             found = true;
-         } else {
-             /* The component does not want to run, so close it. Its close()
-                has already been invoked. Close it out of the DSO repository
-                (if it is there in the repository) */
-             mca_base_component_repository_release(entry->super.cli_component);
-             OBJ_RELEASE(entry);
-         }
-         /* Free entry from the "opened" list */
-         OBJ_RELEASE(p);
-     }
+    /* The opened list is no longer necessary, so we can free it */
+    OBJ_DESTRUCT(&mca_topo_base_components_opened);
+    mca_topo_base_components_opened_valid = false;
 
-     /* The opened list is no longer necessary, so we can free it */
-     OBJ_DESTRUCT (&mca_topo_base_components_opened);
-     mca_topo_base_components_opened_valid = false;
+    /* There should atleast be one topo component which was available */
+    if (!found) {
+        /* Need to free all items in the list */
+        OBJ_DESTRUCT(&mca_topo_base_components_available);
+        mca_topo_base_components_available_valid = false;
+        opal_output_verbose(10, mca_topo_base_output,
+                            "topo:find_available: no topo components available!");
+        return OMPI_ERROR;
+    }
 
-     /* There should atleast be one topo component which was available */
-     if (false == found) {
-         /* Need to free all items in the list */
-         OBJ_DESTRUCT(&mca_topo_base_components_available);
-         mca_topo_base_components_available_valid = false;
-         opal_output_verbose (10, mca_topo_base_output,
-                              "topo:find_available: no topo components available!");
-         return OMPI_ERROR;
-     }
-
-     /* All done */
-     return OMPI_SUCCESS;
+    /* All done */
+    return OMPI_SUCCESS;
 }
               
        
@@ -121,11 +121,14 @@
                         "topo:find_available: querying topo component %s",
                         m->mca_component_name);
 
-    /* This component has been successfully opened, now try to query it */
+    /* This component has been successfully opened, now try to query
+       it and see if it wants to run in this job.  Nothing interesting
+       happened in the topo framework before v2.1.0, so don't bother
+       supporting anything before then. */
     if (2 == m->mca_type_major_version &&
-        0 == m->mca_type_minor_version &&
+        1 == m->mca_type_minor_version &&
         0 == m->mca_type_release_version) {
-        ret = init_query_2_0_0(m, entry, enable_progress_threads,
+        ret = init_query_2_1_0(m, entry, enable_progress_threads,
                                enable_mpi_threads);
     } else {
         /* unrecognised API version */
@@ -151,18 +154,20 @@
                             m->mca_component_name);
 
     }
+
     /* All done */
     return ret;
 }
 
 
-static int init_query_2_0_0(const mca_base_component_t *component,
+static int init_query_2_1_0(const mca_base_component_t *component,
                             mca_base_component_priority_list_item_t *entry,
                             bool enable_progress_threads,
                             bool enable_mpi_threads) 
 {
-    mca_topo_base_component_2_0_0_t *topo = (mca_topo_base_component_2_0_0_t *) component;
+    mca_topo_base_component_2_1_0_t *topo = 
+        (mca_topo_base_component_2_1_0_t *) component;
     
-    return topo->topom_init_query(enable_progress_threads,
+    return topo->topoc_init_query(enable_progress_threads,
                                   enable_mpi_threads);
 }
Index: ompi/mca/topo/base/topo_base_cartdim_get.c
===================================================================
--- ompi/mca/topo/base/topo_base_cartdim_get.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_cartdim_get.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -30,10 +31,9 @@
  * @retval MPI_SUCCESS
  * @retval MPI_ERR_COMM
  */
-int mca_topo_base_cartdim_get (ompi_communicator_t* comm,
-                           int *ndims){
+int mca_topo_base_cartdim_get(ompi_communicator_t* comm, int *ndims){
  
-    *ndims = comm->c_topo_comm->mtc_ndims_or_nnodes;
+    *ndims = comm->c_topo_comm->mtc.cart.ndims;
     return MPI_SUCCESS;
 }
 
Index: ompi/mca/topo/base/base.h
===================================================================
--- ompi/mca/topo/base/base.h	(revision 22197)
+++ ompi/mca/topo/base/base.h	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.
  * $COPYRIGHT$
  * 
@@ -36,105 +36,100 @@
 BEGIN_C_DECLS
 
 
-OMPI_DECLSPEC    int mca_topo_base_open(void);
-    
-OMPI_DECLSPEC    int mca_topo_base_close(void);
-    
-int mca_topo_base_comm_select(ompi_communicator_t *comm,
-                              mca_base_component_t *preferred);
+/* Open the topo framework */
+OMPI_DECLSPEC int mca_topo_base_open(void);
 
-int mca_topo_base_comm_unselect(ompi_communicator_t *comm);
-    
-int mca_topo_base_find_available (bool enable_progress_threads,
-                                  bool enable_mpi_threads);
+/* Close the topo framework */
+OMPI_DECLSPEC int mca_topo_base_close(void);
 
+/* Select a topo module for a new cartesian or graph communicator */
+OMPI_DECLSPEC int mca_topo_base_comm_select(struct ompi_communicator_t *comm,
+                                            mca_base_component_t *preferred);
 
-OMPI_DECLSPEC    int mca_topo_base_init_comm (ompi_communicator_t *comm);
-    
-OMPI_DECLSPEC    int mca_topo_base_get_param (ompi_communicator_t *comm, int keyval);
+/* Find all components that want to be considered in this job */
+OMPI_DECLSPEC int mca_topo_base_find_available (bool enable_progress_threads,
+                                                bool enable_mpi_threads);
 
-    /*
-     * All the glue functions which we will provide to the users by
-     * default. The component authors need to only write back-end
-     * functions for graph_map() and cart_map() for their topology
-     * components.  But they can implement these glue functions if
-     * they want.
-     */
-OMPI_DECLSPEC    int mca_topo_base_cart_coords (ompi_communicator_t *comm, 
-                                   int rank, 
-                                   int maxdims,
-                                   int *coords);
 
-OMPI_DECLSPEC    int mca_topo_base_cart_create (mca_topo_base_comm_t *topo_data,
-                                   int *proc_count,
-                                   ompi_proc_t **proc_pointers,
-                                   int *new_rank,
-                                   int ndims, 
-                                   int *dims,
-                                   int *periods, 
-                                   bool reorder);
+/*
+ * All the glue functions which we will provide to the users by
+ * default. The component authors need to only write back-end
+ * functions for graph_map() and cart_map() for their topology
+ * components.  But they can implement these glue functions if
+ * they want.
+ */
+OMPI_DECLSPEC int mca_topo_base_cart_coords (ompi_communicator_t *comm, 
+                                             int rank, 
+                                             int maxdims,
+                                             int *coords);
 
-OMPI_DECLSPEC    int mca_topo_base_cartdim_get (ompi_communicator_t *comm, 
-                                   int *ndims);
+OMPI_DECLSPEC int mca_topo_base_cart_create (mca_topo_base_comm_t *topo_data,
+                                             int *proc_count,
+                                             ompi_proc_t **proc_pointers,
+                                             int *new_rank,
+                                             int ndims, 
+                                             int *dims,
+                                             int *periods, 
+                                             bool reorder);
 
-OMPI_DECLSPEC    int mca_topo_base_cart_get (ompi_communicator_t *comm, 
-                                int maxdims, 
-                                int *dims,
-                                int *periods, 
-                                int *coords);
+OMPI_DECLSPEC int mca_topo_base_cartdim_get (ompi_communicator_t *comm, 
+                                             int *ndims);
 
-OMPI_DECLSPEC    int mca_topo_base_cart_rank (ompi_communicator_t *comm, 
-                                 int *coords, 
-                                 int *rank);
+OMPI_DECLSPEC int mca_topo_base_cart_get (ompi_communicator_t *comm, 
+                                          int maxdims, 
+                                          int *dims,
+                                          int *periods, 
+                                          int *coords);
 
-OMPI_DECLSPEC    int mca_topo_base_cart_shift (ompi_communicator_t *comm, 
-                                  int direction, 
-                                  int disp,
-                                  int *rank_source, 
-                                  int *rank_dest);
+OMPI_DECLSPEC int mca_topo_base_cart_rank (ompi_communicator_t *comm, 
+                                           int *coords, 
+                                           int *rank);
+
+OMPI_DECLSPEC int mca_topo_base_cart_shift (ompi_communicator_t *comm, 
+                                            int direction, 
+                                            int disp,
+                                            int *rank_source, 
+                                            int *rank_dest);
   
-OMPI_DECLSPEC    int mca_topo_base_cart_sub (ompi_communicator_t *comm, 
-                                int *remain_dims,
-                                ompi_communicator_t **new_comm);
+OMPI_DECLSPEC int mca_topo_base_cart_sub (ompi_communicator_t *comm, 
+                                          int *remain_dims,
+                                          ompi_communicator_t **new_comm);
   
-OMPI_DECLSPEC    int mca_topo_base_graph_create (mca_topo_base_comm_t *topo_data,
-                                    int *proc_count,
-                                    ompi_proc_t **proc_pointers,
-                                    int *new_rank,
-                                    int nnodes,
-                                    int *index, 
-                                    int *edges,
-                                    bool reorder);
+OMPI_DECLSPEC int mca_topo_base_graph_create (mca_topo_base_comm_t *topo_data,
+                                              int *proc_count,
+                                              ompi_proc_t **proc_pointers,
+                                              int *new_rank,
+                                              int nnodes,
+                                              int *index, 
+                                              int *edges,
+                                              bool reorder);
 
-OMPI_DECLSPEC    int mca_topo_base_graphdims_get (ompi_communicator_t *comm, 
-                                     int *nodes,
-                                     int *nedges);
+OMPI_DECLSPEC int mca_topo_base_graphdims_get (ompi_communicator_t *comm, 
+                                               int *nodes,
+                                               int *nedges);
   
-OMPI_DECLSPEC    int mca_topo_base_graph_get (ompi_communicator_t *comm, 
-                                 int maxindex, 
-                                 int maxedges, 
-                                 int *index, 
-                                 int *edges);
+OMPI_DECLSPEC int mca_topo_base_graph_get (ompi_communicator_t *comm, 
+                                           int maxindex, 
+                                           int maxedges, 
+                                           int *index, 
+                                           int *edges);
 
-OMPI_DECLSPEC    int mca_topo_base_graph_neighbors (ompi_communicator_t *comm, 
-                                       int rank,
-                                       int maxneighbors, 
-                                       int *neighbors);
+OMPI_DECLSPEC int mca_topo_base_graph_neighbors (ompi_communicator_t *comm, 
+                                                 int rank,
+                                                 int maxneighbors, 
+                                                 int *neighbors);
 
-OMPI_DECLSPEC    int mca_topo_base_graph_neighbors_count (ompi_communicator_t *comm, 
-                                             int rank,
-                                             int *nneighbors);
+OMPI_DECLSPEC int mca_topo_base_graph_neighbors_count(ompi_communicator_t *comm, 
+                                                      int rank,
+                                                      int *nneighbors);
 
 
 /*
  * Globals
  */
 OMPI_DECLSPEC extern int mca_topo_base_output;
-extern int mca_topo_base_param;
-
-OMPI_DECLSPEC extern opal_list_t mca_topo_base_components_available;
+extern opal_list_t mca_topo_base_components_available;
 OMPI_DECLSPEC extern opal_list_t mca_topo_base_components_opened;
-
 extern bool mca_topo_base_components_opened_valid;
 extern bool mca_topo_base_components_available_valid;
 
Index: ompi/mca/topo/base/topo_base_graph_create.c
===================================================================
--- ompi/mca/topo/base/topo_base_graph_create.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_graph_create.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -57,11 +58,11 @@
 
     /* Create and error check the topology information */
 
-    nedges = topo_data->mtc_dims_or_index[nnodes-1];
+    nedges = topo_data->mtc.graph.index[nnodes-1];
 
     /* Check if there are any negative values on the edges */
     
-    p = topo_data->mtc_periods_or_edges;
+    p = topo_data->mtc.graph.edges;
 
     for (i = 0; i < nedges; ++i, ++p) {
          if (*p < 0 || *p >= nnodes) {
Index: ompi/mca/topo/base/topo_base_cart_shift.c
===================================================================
--- ompi/mca/topo/base/topo_base_cart_shift.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_cart_shift.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -67,9 +67,9 @@
     * Compute the rank factor and ordinate.
     */
     factor = ompi_comm_size(comm);
-    d = comm->c_topo_comm->mtc_dims_or_index;
-    q = comm->c_topo_comm->mtc_periods_or_edges;
-    for (i = 0; (i < comm->c_topo_comm->mtc_ndims_or_nnodes) && (i <= direction); ++i, ++d, ++q) {
+    d = comm->c_topo_comm->mtc.cart.dims;
+    q = comm->c_topo_comm->mtc.cart.periods;
+    for (i = 0; (i < comm->c_topo_comm->mtc.cart.ndims) && (i <= direction); ++i, ++d, ++q) {
         thisdirection = *d;
         thisperiod = *q;
 
Index: ompi/mca/topo/base/topo_base_cart_get.c
===================================================================
--- ompi/mca/topo/base/topo_base_cart_get.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_cart_get.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -47,11 +47,11 @@
                         int *periods,
                         int *coords)
 {
-    int m = (maxdims <= comm->c_topo_comm->mtc_ndims_or_nnodes) ?
-        maxdims : comm->c_topo_comm->mtc_ndims_or_nnodes;
+    int m = (maxdims <= comm->c_topo_comm->mtc.cart.ndims) ?
+        maxdims : comm->c_topo_comm->mtc.cart.ndims;
 
-    memcpy(dims, comm->c_topo_comm->mtc_dims_or_index, m * sizeof(int));
-    memcpy(periods, comm->c_topo_comm->mtc_periods_or_edges, m * sizeof(int));
+    memcpy(dims, comm->c_topo_comm->mtc.cart.dims, m * sizeof(int));
+    memcpy(periods, comm->c_topo_comm->mtc.cart.periods, m * sizeof(int));
     memcpy(coords, comm->c_topo_comm->mtc_coords, m * sizeof(int));
 
     return MPI_SUCCESS;
Index: ompi/mca/topo/base/topo_base_comm_select.c
===================================================================
--- ompi/mca/topo/base/topo_base_comm_select.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_comm_select.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -38,348 +38,150 @@
 
 
 /*
- * This structure is needed so that we can close the modules 
- * which are not selected but were opened. mca_base_modules_close
- * which does this job for us requires a opal_list_t which contains
- * these modules
- */
-struct queried_module_t {
-    opal_list_item_t super;
-    mca_topo_base_component_t *om_component;
-    mca_topo_base_module_t *om_module;
-};
-typedef struct queried_module_t queried_module_t;
-static OBJ_CLASS_INSTANCE(queried_module_t, opal_list_item_t, NULL, NULL);
-
-
-/*
  * Only one topo module can be attached to each communicator.
  *
  * This module calls the query funtion on all the components that were
  * detected by topo_base_open. This function is called on a
  * per-communicator basis. This function has the following function.
  *
- * 1. Iterate over the list of available_components
+ * 1. Iterate over the list of available_components.
  * 2. Call the query function on each of these components.
- * 3. query function returns the structure containing pointers
- *    to its module and its priority
- * 4. Select the module with the highest priority
- * 5. Call the init function on the selected module so that it does the
- *    right setup for the communicator
- * 6. Call finalize on all the other modules which returned 
- *    their module but were unfortunate to not get selected
+ * 3. The query function returns a module and its priority.
+ * 4. Select the module with the highest priority.
+ * 5. OBJ_RELEASE all the "losing" modules.
  */  
-
-int mca_topo_base_comm_select (struct ompi_communicator_t *comm,
-                               mca_base_component_t *preferred) 
+int mca_topo_base_comm_select(struct ompi_communicator_t *comm,
+                              mca_base_component_t *preferred) 
 {
-    int priority; 
-    int best_priority; 
+    int priority, best_priority; 
     char name[MPI_MAX_OBJECT_NAME+32];
     opal_list_item_t *item; 
-    opal_list_item_t *next_item; 
-    mca_base_component_priority_list_item_t *selectable_item;
-    char *names, **name_array;
-    int num_names;
     mca_base_component_priority_list_item_t *cpli;
-    mca_topo_base_component_t *component; 
-    mca_topo_base_component_t *best_component;
-    mca_topo_base_module_t *module; 
-    opal_list_t queried;
-    queried_module_t *om;
-    opal_list_t *selectable;
+    mca_topo_base_component_t *component, *best_component;
+    mca_topo_base_module_t *module, *best_module; 
     char *str;
-    int err = MPI_SUCCESS;
-    int i;
-    bool was_selectable_constructed = false;
 
     /* Announce */
-
-    /* ANJU:
-     * check for names array .... mca_base_param_ */
-  
     snprintf(name, sizeof(name), "%s (cid %d)", comm->c_name,
-               comm->c_contextid);
+             comm->c_contextid);
     name[sizeof(name) - 1] = '\0';
     opal_output_verbose(10, mca_topo_base_output,
                         "topo:base:comm_select: new communicator: %s",
                         name);
 
-
     /* Check and see if a preferred component was provided. If it was
-     provided then it should be used (if possible) */
-
+       provided then it should be used (if possible) */
     if (NULL != preferred) {
          
         /* We have a preferred component. Check if it is available
            and if so, whether it wants to run */
-         
          str = &(preferred->mca_component_name[0]);
-         
          opal_output_verbose(10, mca_topo_base_output,
                              "topo:base:comm_select: Checking preferred component: %s",
                              str);
 
          /* query the component for its priority and get its module 
             structure. This is necessary to proceed */
-
-        component = (mca_topo_base_component_t *)preferred;
-         module = component->topom_comm_query (&priority);
+         component = (mca_topo_base_component_t *) preferred;
+         module = component->topoc_comm_query(comm, &priority);
          if (NULL != module && 
-             NULL != module->topo_module_init &&
-             NULL != module->topo_graph_map &&
-             NULL != module->topo_cart_map) {
+             NULL != module->topom_graph_map &&
+             NULL != module->topom_cart_map) {
 
              /* this query seems to have returned something legitimate
               * and we can now go ahead and initialize the
               * communicator with it * but first, the functions which
               * are null need to be filled in */
 
-             fill_null_pointers (module);
-             comm->c_topo = module;
+             fill_null_pointers(module);
+             comm->c_topo_module = module;
              comm->c_topo_component = preferred;
 
-             return module->topo_module_init(comm);
+             return OMPI_SUCCESS;
          } 
-            /* His preferred component is present, but is unable to
-             * run. This is not a good sign. We should try selecting
-             * some other component We let it fall through and select
-             * from the list of available components
-             */
-     } /*end of selection for preferred component */
 
+         /* If we get here, the preferred component is present, but is
+            unable to run.  This is not a good sign.  We should try
+            selecting some other component.  We let it fall through
+            and select from the list of available components */
+    }
+
     /*
-     * We fall till here if one of the two things happened:
+     * We fall here if one of the two things happened:
      * 1. The preferred component was provided but for some reason was
-     * not able to be selected
+     *    not able to be selected
      * 2. No preferred component was provided
      *
      * All we need to do is to go through the list of available
      * components and find the one which has the highest priority and
      * use that for this communicator
      */ 
-
-    /* Check if anything was requested by means on the name parameters */
-    names = NULL;
-    mca_base_param_lookup_string (mca_topo_base_param, &names);
-
-    if (NULL != names && 0 < strlen(names)) {
-        name_array = opal_argv_split (names, ',');
-        num_names = opal_argv_count (name_array);
-
+    best_component = NULL;
+    best_module = NULL;
+    best_priority = -1;
+    for (item = opal_list_get_first(&mca_topo_base_components_available);
+         item != opal_list_get_end(&mca_topo_base_components_available);
+         item = opal_list_get_next(item)) {
+        /* Convert the opal_list_item_t returned into the proper type */
+        cpli = (mca_base_component_priority_list_item_t *) item;
+        component = (mca_topo_base_component_t *) cpli->super.cli_component;
         opal_output_verbose(10, mca_topo_base_output,
-                            "topo:base:comm_Select: Checking all available module");
-
-        /* since there are somethings which the mca requested through the 
-           if the intersection is NULL, then we barf saying that the requested
-           modules are not being available */
-
-        selectable = OBJ_NEW(opal_list_t);
-        was_selectable_constructed = true;
+                            "select: initialising %s component %s",
+                            component->topoc_version.mca_type_name,
+                            component->topoc_version.mca_component_name);
         
-        /* go through the compoents_available list and check against the names
-         * to see whether this can be added or not */
-
-        for (item = opal_list_get_first(&mca_topo_base_components_available);
-            item != opal_list_get_end(&mca_topo_base_components_available);
-            item = opal_list_get_next(item)) {
-            /* convert the opal_list_item_t returned into the proper type */
-            cpli = (mca_base_component_priority_list_item_t *) item;
-            component = (mca_topo_base_component_t *) cpli->super.cli_component;
+        /* Ensure that there is a comm_query function */
+        if (NULL == component->topoc_comm_query) {
             opal_output_verbose(10, mca_topo_base_output,
-                                "select: initialising %s component %s",
-                                component->topom_version.mca_type_name,
-                                component->topom_version.mca_component_name);
+                                "select: no comm_query, ignoring the component");
+            continue;
+        }
 
-            /* check if this name is present in the mca_base_params */
-            for (i=0; i < num_names; i++) {
-                if (0 == strcmp(name_array[i], component->topom_version.mca_component_name)) {
-                    /* this is present, and should be added o the selectable list */
-
-                    /* We need to create a seperate object to initialise this list with
-                     * since we cannot have the same item in 2 lists */
-
-                    selectable_item = OBJ_NEW (mca_base_component_priority_list_item_t);
-                    *selectable_item = *cpli;
-                    opal_list_append (selectable, (opal_list_item_t *)selectable_item);
-                    break;
-                }
+        /* Call comm_query.  If we get nothing or a bogus module back,
+           skip it. */
+        module = component->topoc_comm_query(comm, &priority);
+        if (NULL == module ||
+            NULL == module->topom_graph_map  ||
+            NULL == module->topom_cart_map) {
+            if (NULL != module) {
+                OBJ_RELEASE(module);
             }
+            opal_output_verbose(10, mca_topo_base_output,
+                                "select: query returned failure; ignoring this component");
+            continue;
         }
-        
-        /* check for a NULL intersection between the available list and the 
-         * list which was asked for */
+        opal_output_verbose(10, mca_topo_base_output,
+                            "select: query returned priority %d",
+                            priority);
 
-        if (0 == opal_list_get_size(selectable)) {
-            was_selectable_constructed = true;
-            OBJ_RELEASE (selectable);
-            opal_output_verbose (10, mca_topo_base_output,
-                                 "topo:base:comm_select: preferred modules were not available");
-            return OMPI_ERROR;
-        }
-    } else { /* if there was no name_array, then we need to simply initialize 
-                selectable to mca_topo_base_components_available */
-        selectable = &mca_topo_base_components_available;
-    }
+        /* Is this the best component we found so far? */
+        if (NULL != module && priority > best_priority) {
+            module->topom_comm = comm;
 
-    best_component = NULL;
-    best_priority = -1;
-    OBJ_CONSTRUCT(&queried, opal_list_t);
+            if (NULL != best_module) {
+                OBJ_RELEASE(best_module);
+            }
 
-    for (item = opal_list_get_first(selectable);
-         item != opal_list_get_end(selectable);
-         item = opal_list_get_next(item)) {
-       /*
-        * convert the opal_list_item_t returned into the proper type
-        */
-       cpli = (mca_base_component_priority_list_item_t *) item;
-       component = (mca_topo_base_component_t *) cpli->super.cli_component;
-       opal_output_verbose(10, mca_topo_base_output,
-                           "select: initialising %s component %s",
-                           component->topom_version.mca_type_name,
-                           component->topom_version.mca_component_name);
-
-       /*
-        * we can call the query function only if there is a function :-)
-        */
-       if (NULL == component->topom_comm_query) {
-          opal_output_verbose(10, mca_topo_base_output,
-                             "select: no query, ignoring the component");
-       } else {
-           /*
-            * call the query function and see what it returns
-            */ 
-           module = component->topom_comm_query (&priority);
-
-           if (NULL == module ||
-               NULL == module->topo_module_init ||
-               NULL == module->topo_graph_map  ||
-               NULL == module->topo_cart_map) {
-               /*
-                * query did not return any action which can be used
-                */ 
-               opal_output_verbose(10, mca_topo_base_output,
-                                  "select: query returned failure");
-           } else {
-               opal_output_verbose(10, mca_topo_base_output,
-                                  "select: query returned priority %d",
-                                  priority);
-               /* 
-                * is this the best component we have found till now?
-                */
-               if (priority > best_priority) {
-                   best_priority = priority;
-                   best_component = component;
-               }
-
-               om = OBJ_NEW(queried_module_t);
-               /*
-                * check if we have run out of space
-                */
-               if (NULL == om) {
-                   OBJ_DESTRUCT(&queried);
-                   return OMPI_ERR_OUT_OF_RESOURCE;
-               }
-               om->om_component = component;
-               om->om_module = module; 
-               opal_list_append(&queried, (opal_list_item_t *)om); 
-           } /* end else of if (NULL == module) */
-       } /* end else of if (NULL == component->topom_init) */
-    } /* end for ... end of traversal */
-
-    /* We have to remove empty out the selectable list if the selectable 
-     * list was constructed as a duplicate and not as a pointer to the
-     * mca_base_components_available list. So, check and destroy */
-
-    if (was_selectable_constructed) {
-
-        /* remove all the items first */
-        for (item = opal_list_get_first(&mca_topo_base_components_available);
-             item != opal_list_get_end(&mca_topo_base_components_available);
-             item = next_item) {
-             next_item = opal_list_get_next(item);
-             OBJ_RELEASE (item);
+            best_priority = priority;
+            best_component = component;
+            best_module = module;
         }
-                
-        /* release the list itself */
-        OBJ_RELEASE (selectable);
-        was_selectable_constructed = false;
     }
 
-    /*
-     * Now we have alist of components which successfully returned
-     * their module struct.  One of these components has the best
-     * priority. The rest have to be comm_unqueried to counter the
-     * effects of comm_query'ing them. Finalize happens only on
-     * components which should are initialized.
-     */
+    /* If we didn't find anything, error */
     if (NULL == best_component) {
-       /*
-        * This typically means that there was no component which was
-        * able to run properly this time. So, we need to abort
-        * JMS replace with show_help
-        */
-        OBJ_DESTRUCT(&queried);
-        return OMPI_ERROR;
+        return OMPI_ERR_NOT_FOUND;
     }
-
-    /*
-     * We now have a list of components which have successfully
-     * returned their priorities from the query. We now have to
-     * unquery() those components which have not been selected and
-     * init() the component which was selected
-     */ 
-    for (item = opal_list_remove_first(&queried);
-         NULL != item;
-         item = opal_list_remove_first(&queried)) {
-        om = (queried_module_t *) item;
-        if (om->om_component == best_component) {
-           /*
-            * this is the chosen component, we have to initialise the
-            * module of this component.
-            *
-            * ANJU: a component might not have all the functions
-            * defined.  Whereever a function pointer is null in the
-            * module structure we need to fill it in with the base
-            * structure function pointers. This is yet to be done
-            */ 
-
-            /*
-             * We don return here coz we still need to go through and
-             * elease the other objects
-             */
-
-            fill_null_pointers (om->om_module);
-            comm->c_topo = om->om_module;
-            err = om->om_module->topo_module_init(comm);
-            comm->c_topo_component = (mca_base_component_t *)best_component;
-
-         } else {
-            /*
-             * this is not the "choosen one", finalize
-             */
-             if (NULL != om->om_component->topom_comm_unquery) {
-                /* unquery the component only if they have some clean
-                 * up job to do. Components which are queried but do
-                 * not actually do anything typically do not have a
-                 * unquery. Hence this check is necessary
-                 */
-                 (void) om->om_component->topom_comm_unquery(comm);
-                 opal_output_verbose(10, mca_topo_base_output,
-                                     "select: component %s is not selected",
-                                     om->om_component->topom_version.mca_component_name);
-               } /* end if */
-          } /* if not best component */
-          OBJ_RELEASE(om);
-    } /* traversing through the entire list */
     
+    /* Save it on the communicator */
     opal_output_verbose(10, mca_topo_base_output,
                        "select: component %s selected",
-                        best_component->topom_version.mca_component_name);
+                        best_component->topoc_version.mca_component_name);
+    fill_null_pointers(best_module);
+    comm->c_topo_module = best_module;
+    comm->c_topo_component = &(best_component->topoc_version);
 
-    OBJ_DESTRUCT(&queried);
-
-    return err;
+    return OMPI_SUCCESS;
 }
 
 
@@ -393,8 +195,8 @@
 static void fill_null_pointers(mca_topo_base_module_t *module) 
 {
 #define CHECK_FOR_NULL_FUNCTION_POINTER(name) \
-   if (NULL == module->topo_##name) { \
-      module->topo_##name = mca_topo_base_##name; \
+   if (NULL == module->topom_##name) { \
+      module->topom_##name = mca_topo_base_##name; \
    }
 
    CHECK_FOR_NULL_FUNCTION_POINTER(cart_coords);
Index: ompi/mca/topo/base/Makefile.am
===================================================================
--- ompi/mca/topo/base/Makefile.am	(revision 22197)
+++ ompi/mca/topo/base/Makefile.am	(working copy)
@@ -9,6 +9,7 @@
 #                         University of Stuttgart.  All rights reserved.
 # Copyright (c) 2004-2005 The Regents of the University of California.
 #                         All rights reserved.
+# Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
 # $COPYRIGHT$
 # 
 # Additional copyrights may follow
@@ -35,5 +36,4 @@
         base/topo_base_graph_neighbors_count.c \
         base/topo_base_open.c \
         base/topo_base_close.c \
-        base/topo_base_comm_select.c \
-        base/topo_base_comm_unselect.c
+        base/topo_base_comm_select.c
Index: ompi/mca/topo/base/topo_base_comm_unselect.c
===================================================================
--- ompi/mca/topo/base/topo_base_comm_unselect.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_comm_unselect.c	(working copy)
@@ -1,45 +0,0 @@
-/*
- * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
- *                         University Research and Technology
- *                         Corporation.  All rights reserved.
- * Copyright (c) 2004-2005 The University of Tennessee and The University
- *                         of Tennessee Research Foundation.  All rights
- *                         reserved.
- * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
- *                         University of Stuttgart.  All rights reserved.
- * Copyright (c) 2004-2005 The Regents of the University of California.
- *                         All rights reserved.
- * $COPYRIGHT$
- * 
- * Additional copyrights may follow
- * 
- * $HEADER$
- */
-
-#include "ompi_config.h"
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include "opal/mca/mca.h"
-#include "opal/mca/base/base.h"
-#include "ompi/mca/topo/base/base.h"
-#include "ompi/communicator/communicator.h"
-
-/*
- * This function is used to shut down a topology module 
- * on a communicator. As of now, this should do nothing
- * more than just invoke the finalize on the module which
- * was selected. There is nothing fancy which we need to
- * do as is the case with collectives.
- */ 
-int mca_topo_base_comm_unselect(struct ompi_communicator_t *comm) {
-
-   if (NULL != comm->c_topo && NULL != comm->c_topo->topo_module_finalize) {
-       return comm->c_topo->topo_module_finalize(comm);
-   }
-
-   /* we fall here if there was no topolog module or the selected module 
-    * did not have anything to finalize (its func pointer was NULL) */
-   return OMPI_SUCCESS;
-}
Index: ompi/mca/topo/base/topo_base_graph_get.c
===================================================================
--- ompi/mca/topo/base/topo_base_graph_get.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_graph_get.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -45,15 +46,15 @@
     /*
      * Fill the nodes and edges arrays.
      */
-     p = comm->c_topo_comm->mtc_dims_or_index;
+     p = comm->c_topo_comm->mtc.graph.index;
      for (i = 0; (i < nprocs) && (i < maxindex); ++i, ++p) {
          *index++ = *p;
       }
 
-      p = comm->c_topo_comm->mtc_periods_or_edges;
+      p = comm->c_topo_comm->mtc.graph.edges;
 
       for (i = 0; 
-          (i < comm->c_topo_comm->mtc_dims_or_index[nprocs-1]) && (i < maxedges); 
+          (i < comm->c_topo_comm->mtc.graph.index[nprocs-1]) && (i < maxedges); 
           ++i, ++p) {
           
          *edges++ = *p;
Index: ompi/mca/topo/base/topo_base_graph_neighbors.c
===================================================================
--- ompi/mca/topo/base/topo_base_graph_neighbors.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_graph_neighbors.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -44,11 +45,11 @@
     /*
      * Fill the neighbours.
      */
-     nnbrs = comm->c_topo_comm->mtc_dims_or_index[rank];
-     p = comm->c_topo_comm->mtc_periods_or_edges;
+     nnbrs = comm->c_topo_comm->mtc.graph.index[rank];
+     p = comm->c_topo_comm->mtc.graph.edges;
 
      if (rank > 0) {
-        i = comm->c_topo_comm->mtc_dims_or_index[rank - 1];
+        i = comm->c_topo_comm->mtc.graph.index[rank - 1];
         nnbrs -= i;
         p += i;
      }
Index: ompi/mca/topo/base/topo_base_open.c
===================================================================
--- ompi/mca/topo/base/topo_base_open.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_open.c	(working copy)
@@ -9,6 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -40,17 +41,14 @@
  * Global variables
  */
 int mca_topo_base_output = -1;
-int mca_topo_base_param = -1;
 
 opal_list_t mca_topo_base_components_available;
 opal_list_t mca_topo_base_components_opened;
 
-mca_topo_base_component_t mca_topo_base_selected_component;
-mca_topo_base_module_t mca_topo;
-
 bool mca_topo_base_components_available_valid = false;
 bool mca_topo_base_components_opened_valid = false;
 
+OBJ_CLASS_INSTANCE(mca_topo_base_module_t, opal_object_t, NULL, NULL);
 
 /**
  * Function for finding and opening either all the MCA topo components, or
@@ -70,9 +68,6 @@
     }
          
     mca_topo_base_components_opened_valid = true;
-    
-    /* Find the index of the "topo" param for selection */
-    mca_topo_base_param = mca_base_param_find("topo", "base", NULL);
 
      /* All done */
 
Index: ompi/mca/topo/base/topo_base_cart_sub.c
===================================================================
--- ompi/mca/topo/base/topo_base_cart_sub.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_cart_sub.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -64,8 +64,8 @@
      colfactor = keyfactor = 1;
      ndim = 0;
 
-     i = comm->c_topo_comm->mtc_ndims_or_nnodes - 1;
-     d = comm->c_topo_comm->mtc_dims_or_index + i;
+     i = comm->c_topo_comm->mtc.cart.ndims - 1;
+     d = comm->c_topo_comm->mtc.cart.dims + i;
      c = comm->c_topo_comm->mtc_coords + i;
      r = remain_dims + i;
 
@@ -98,13 +98,13 @@
      */
      if (temp_comm != MPI_COMM_NULL) {
         
-        temp_comm->c_topo_comm->mtc_ndims_or_nnodes = ndim;
+        temp_comm->c_topo_comm->mtc.cart.ndims = ndim;
         
         if (ndim >= 1) {
-            p = temp_comm->c_topo_comm->mtc_dims_or_index;
-            d = comm->c_topo_comm->mtc_dims_or_index;
+            p = temp_comm->c_topo_comm->mtc.cart.dims;
+            d = comm->c_topo_comm->mtc.cart.dims;
             r = remain_dims;
-            for (i = 0; i < comm->c_topo_comm->mtc_ndims_or_nnodes; 
+            for (i = 0; i < comm->c_topo_comm->mtc.cart.ndims; 
                  ++i, ++d, ++r) {
                 if (*r) {
                     *p++ = *d;
@@ -119,8 +119,10 @@
                 OBJ_RELEASE(temp_comm);
                 return errcode;
             }
-            errcode = temp_comm->c_topo->topo_cart_coords (temp_comm, rank,
-                                                           ndim, temp_comm->c_topo_comm->mtc_coords);
+            errcode = temp_comm->c_topo_module->topom_cart_coords(temp_comm, 
+                                                                  rank,
+                                                                  ndim, 
+                                                                  temp_comm->c_topo_comm->mtc_coords);
             if (MPI_SUCCESS != errcode) {
                 OBJ_RELEASE(temp_comm);
                 return errcode;
Index: ompi/mca/topo/base/topo_base_cart_coords.c
===================================================================
--- ompi/mca/topo/base/topo_base_cart_coords.c	(revision 22197)
+++ ompi/mca/topo/base/topo_base_cart_coords.c	(working copy)
@@ -9,7 +9,7 @@
  *                         University of Stuttgart.  All rights reserved.
  * Copyright (c) 2004-2005 The Regents of the University of California.
  *                         All rights reserved.
- * Copyright (c) 2008      Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * $COPYRIGHT$
  * 
  * Additional copyrights may follow
@@ -51,11 +51,11 @@
     /*
      * loop computing the co-ordinates
      */ 
-    d = comm->c_topo_comm->mtc_dims_or_index;
+    d = comm->c_topo_comm->mtc.cart.dims;
     remprocs = ompi_comm_size(comm);
 
     for (i = 0; 
-        (i < comm->c_topo_comm->mtc_ndims_or_nnodes) && (i < maxdims); 
+        (i < comm->c_topo_comm->mtc.cart.ndims) && (i < maxdims); 
         ++i, ++d) {
         dim = *d;
         remprocs /= dim;

Property changes on: ompi/mca/topo/example
___________________________________________________________________
Added: svn:ignore
   + Makefile
Makefile.in
*.lo
*.la
.libs
.deps


Index: ompi/mca/topo/example/topo_example_component.c
===================================================================
--- ompi/mca/topo/example/topo_example_component.c	(revision 0)
+++ ompi/mca/topo/example/topo_example_component.c	(revision 0)
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2005 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */
+
+#include "ompi_config.h"
+#include "ompi/mca/topo/example/topo_example.h"
+
+/*
+ * Public string showing the topo example module version number
+ */
+const char *mca_topo_example_component_version_string = 
+    "Open MPI example topology MCA component version" OMPI_VERSION;
+
+/*
+ * Local funtions
+ */
+static int init_query(bool enable_progress_threads, bool enable_mpi_threads);
+static struct mca_topo_base_module_2_1_0_t *
+  comm_query(ompi_communicator_t *comm, int *priority);
+
+/*
+ * Public component structure
+ */
+mca_topo_base_component_2_1_0_t mca_topo_example_component = 
+{
+    {
+        MCA_TOPO_BASE_VERSION_2_1_0,
+
+        "example",
+        OMPI_MAJOR_VERSION,
+        OMPI_MINOR_VERSION,
+        OMPI_RELEASE_VERSION,
+
+        /* NULLs for the rest of the function pointers */
+    },
+
+    {
+        /* The component is checkpoint ready */
+        MCA_BASE_METADATA_PARAM_CHECKPOINT
+    },
+
+    init_query,
+    comm_query
+};
+
+
+static int init_query(bool enable_progress_threads, bool enable_mpi_threads)
+{
+    /* Nothing to do */
+   
+    return OMPI_SUCCESS;
+}      
+
+
+static struct mca_topo_base_module_2_1_0_t *
+comm_query(ompi_communicator_t *comm, int *priority)
+{
+    mca_topo_example_module_t *example = OBJ_NEW(mca_topo_example_module_t);
+    if (NULL == example) {
+        return NULL;
+    }
+
+    /* This component has very low priority -- it's an example, after
+       all! */
+    *priority = 0;
+    return &(example->super);
+}
+
+
Index: ompi/mca/topo/example/topo_example_module.c
===================================================================
--- ompi/mca/topo/example/topo_example_module.c	(revision 0)
+++ ompi/mca/topo/example/topo_example_module.c	(revision 0)
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2006 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */
+
+#include "ompi_config.h"
+
+#include <stdio.h>
+
+#include "mpi.h"
+#include "ompi/communicator/communicator.h"
+#include "ompi/mca/topo/topo.h"
+#include "ompi/mca/topo/base/base.h"
+#include "ompi/mca/topo/example/topo_example.h"
+
+
+/*
+ * Local functions
+ */
+static void example_module_constructor(mca_topo_example_module_t *u);
+static void example_module_destructor(mca_topo_example_module_t *u);
+
+OBJ_CLASS_INSTANCE(mca_topo_example_module_t, mca_topo_base_module_t,
+                   example_module_constructor, example_module_destructor);
+
+
+static void example_module_constructor(mca_topo_example_module_t *u)
+{
+    mca_topo_base_module_t *m = &(u->super);
+
+    m->topom_cart_coords = NULL;
+    m->topom_cart_create = NULL;
+    m->topom_cart_get = NULL;
+    m->topom_cartdim_get = NULL;
+    m->topom_cart_map = mca_topo_example_cart_map;
+    m->topom_cart_rank = NULL;
+    m->topom_cart_shift = NULL;
+    m->topom_cart_sub = NULL;
+    m->topom_graph_create = NULL;
+    m->topom_graph_get = NULL;
+    m->topom_graph_map = mca_topo_example_graph_map;
+    m->topom_graphdims_get = NULL;
+    m->topom_graph_neighbors = NULL;
+    m->topom_graph_neighbors_count = NULL;
+
+    /* Here we can fill in additional, module-specific data if
+       necessary */
+    u->example_module_specific_data = 17;
+}
+
+
+static void example_module_destructor(mca_topo_example_module_t *u)
+{
+    /* Do whatever is necessary to clean up / destroy the module */
+}
+
Index: ompi/mca/topo/example/topo_example.h
===================================================================
--- ompi/mca/topo/example/topo_example.h	(revision 0)
+++ ompi/mca/topo/example/topo_example.h	(revision 0)
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2006 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */
+
+#ifndef MCA_TOPO_UNTIY_H
+#define MCA_TOPO_UNTIY_H
+
+#include "ompi_config.h"
+#include "ompi/mca/topo/topo.h"
+
+/*
+ * ******************************************************************
+ * ******** functions which provide MCA interface comppliance *******
+ * ******************************************************************
+ * These functions are:
+ *       - mca_topo_example_module_open
+ *       - mca_topo_example_module_close
+ *       - mca_topo_example_module_query
+ *       - mca_topo_example_module_finalize
+ * These functions are always found on the mca_topo_example_module
+ * structure. They are the "meta" functions to ensure smooth op.
+ * ******************************************************************
+ */
+BEGIN_C_DECLS
+
+/*
+ * Public component instance
+ */
+OMPI_MODULE_DECLSPEC extern mca_topo_base_component_2_1_0_t 
+    mca_topo_example_component;
+
+/* 
+ * A unique module class for the module so that we can both cache
+ * module-specific information on the module and have a
+ * module-specific constructor and destructor.
+ */
+typedef struct {
+    mca_topo_base_module_t super;
+
+    /* Modules can add their own information here */
+    int example_module_specific_data;
+} mca_topo_example_module_t;
+
+OBJ_CLASS_DECLARATION(mca_topo_example_module_t);
+
+
+/*
+ * Module functions
+ */ 
+
+int mca_topo_example_cart_map(struct ompi_communicator_t *comm,
+                              int ndims,
+                              int *dims,
+                              int *periods,
+                              int *newrank);
+
+int mca_topo_example_graph_map(struct ompi_communicator_t *comm,
+                               int nnodes,
+                               int *index,
+                               int *edges,
+                               int *newrank);
+/*
+ * ******************************************************************
+ * ************ functions implemented in this module end ************
+ * ******************************************************************
+ */ 
+                                     
+END_C_DECLS
+
+#endif /* MCA_TOPO_EXAMPLE_H */
Index: ompi/mca/topo/example/topo_example_cart_map.c
===================================================================
--- ompi/mca/topo/example/topo_example_cart_map.c	(revision 0)
+++ ompi/mca/topo/example/topo_example_cart_map.c	(revision 0)
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2005 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */ 
+
+#include "ompi_config.h"
+#include "ompi/mca/topo/example/topo_example.h"
+
+#include "ompi/communicator/communicator.h"
+
+/*
+ * function - mca_topo_example_cart_map
+ *
+ *  @param comm input communicator (handle)
+ *  @param ndims number of dimensions of cartesian structure (integer)
+ *  @param dims integer array of size 'ndims' specifying the number of
+ *              processes in each coordinate direction
+ *  @param periods logical array of size 'ndims' specifying the 
+ *                 periodicity specification in each coordinate direction
+ *  @param newrank reordered rank of the calling process; 'MPI_UNDEFINED' 
+ *                 if calling process does not belong to grid (integer)
+ *
+ *  @retval MPI_SUCCESS               
+ *  @retval MPI_ERR_DIMS               
+ */
+
+int mca_topo_example_cart_map (ompi_communicator_t* comm,
+                               int ndims,
+                               int *dims,
+                               int *periods,
+                               int *newrank)
+{
+    int nprocs;
+    int rank;
+    int size;
+    int i;
+    int *p;
+
+    /*
+     * Compute the # of processes in the grid.
+     */
+    nprocs = 1;
+    for (i = 0, p = dims; i < ndims; ++i, ++p) {
+        if (*p <= 0) {
+            return MPI_ERR_DIMS;
+        }
+        nprocs *= *p;
+    }
+    /*
+     * Check that number of processes <= size of communicator.
+     */
+    size = ompi_comm_size(comm);
+    if (nprocs > size) {
+        return MPI_ERR_DIMS;
+    }
+    /*
+     * Compute my new rank.  To be slightly different than the "unity"
+     * component, start with a rank that is size-my_initial_rank.
+     */
+    rank = ompi_comm_size(comm) - 1 - ompi_comm_rank(comm);
+    *newrank = ((rank < 0) || (rank >= nprocs)) ? MPI_UNDEFINED : rank;
+
+    return MPI_SUCCESS;
+}
Index: ompi/mca/topo/example/configure.params
===================================================================
--- ompi/mca/topo/example/configure.params	(revision 0)
+++ ompi/mca/topo/example/configure.params	(revision 0)
@@ -0,0 +1,25 @@
+# -*- shell-script -*-
+#
+# Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+#                         University Research and Technology
+#                         Corporation.  All rights reserved.
+# Copyright (c) 2004-2005 The University of Tennessee and The University
+#                         of Tennessee Research Foundation.  All rights
+#                         reserved.
+# Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+#                         University of Stuttgart.  All rights reserved.
+# Copyright (c) 2004-2005 The Regents of the University of California.
+#                         All rights reserved.
+# Copyright (c) 2007      Los Alamos National Security, LLC.  All rights
+#                         reserved. 
+# $COPYRIGHT$
+# 
+# Additional copyrights may follow
+# 
+# $HEADER$
+#
+
+# Specific to this module
+
+PARAM_CONFIG_FILES="Makefile"
+
Index: ompi/mca/topo/example/.windows
===================================================================
Index: ompi/mca/topo/example/Makefile.am
===================================================================
--- ompi/mca/topo/example/Makefile.am	(revision 0)
+++ ompi/mca/topo/example/Makefile.am	(revision 0)
@@ -0,0 +1,53 @@
+#
+# Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+#                         University Research and Technology
+#                         Corporation.  All rights reserved.
+# Copyright (c) 2004-2005 The University of Tennessee and The University
+#                         of Tennessee Research Foundation.  All rights
+#                         reserved.
+# Copyright (c) 2004-2009 High Performance Computing Center Stuttgart, 
+#                         University of Stuttgart.  All rights reserved.
+# Copyright (c) 2004-2005 The Regents of the University of California.
+#                         All rights reserved.
+# Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
+# $COPYRIGHT$
+# 
+# Additional copyrights may follow
+# 
+# $HEADER$
+#
+
+EXTRA_DIST = .windows
+
+sources = \
+    topo_example.h \
+    topo_example_cart_map.c \
+    topo_example_graph_map.c \
+    topo_example_module.c \
+    topo_example_component.c
+
+# Make the output library in this directory, and name it either
+# mca_<type>_<name>.la (for DSO builds) or libmca_<type>_<name>.la
+# (for static builds).
+
+if OMPI_BUILD_topo_example_DSO
+lib =
+lib_sources = 
+component = mca_topo_example.la
+component_sources = $(sources)
+else
+lib = libmca_topo_example.la
+lib_sources = $(sources)
+component =
+component_sources =
+endif
+
+mcacomponentdir = $(pkglibdir)
+mcacomponent_LTLIBRARIES = $(component)
+mca_topo_example_la_SOURCES = $(component_sources)
+mca_topo_example_la_LDFLAGS = -module -avoid-version
+
+noinst_LTLIBRARIES = $(lib)
+libmca_topo_example_la_SOURCES = $(lib_sources)
+libmca_topo_example_la_LDFLAGS = -module -avoid-version
+
Index: ompi/mca/topo/example/topo_example_graph_map.c
===================================================================
--- ompi/mca/topo/example/topo_example_graph_map.c	(revision 0)
+++ ompi/mca/topo/example/topo_example_graph_map.c	(revision 0)
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2005 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart, 
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.
+ * $COPYRIGHT$
+ * 
+ * Additional copyrights may follow
+ * 
+ * $HEADER$
+ */ 
+
+#include "ompi_config.h"
+#include "ompi/mca/topo/example/topo_example.h"
+
+#include "ompi/communicator/communicator.h"
+
+/*
+ * function - mca_topo_example_graph_map
+ *
+ *  @param comm input communicator (handle)
+ *  @param nnodes number of graph nodes (integer)
+ *  @param index integer array specifying the graph structure
+ *  @param edges integer array specifying the graph structure
+ *  @param newrank reordered rank of the calling process; 'MPI_UNDEFINED'
+ *                  if the calling process does not belong to 
+ *                  graph (integer)
+ *
+ *  @retval MPI_SUCCESS
+ *  @retval MPI_UNDEFINED
+ */ 
+
+int mca_topo_example_graph_map (ompi_communicator_t* comm,
+                              int nnodes,
+                              int *index,
+                              int *edges,
+                              int *newrank)
+{
+    int myrank;
+
+    /*
+     * Compute my new rank.  To be slightly different than the "unity"
+     * component, start with a rank that is size-my_initial_rank.
+     */
+    myrank = ompi_comm_size(comm) - 1 - ompi_comm_rank(comm);
+    *newrank = 
+        ((0 > myrank) || (myrank >= nnodes)) ? MPI_UNDEFINED : myrank;
+    
+    return OMPI_SUCCESS;
+}
Index: ompi/debuggers/ompi_mpihandles_dll.c
===================================================================
--- ompi/debuggers/ompi_mpihandles_dll.c	(revision 22197)
+++ ompi/debuggers/ompi_mpihandles_dll.c	(working copy)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007-2008 Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
@@ -547,7 +547,7 @@
         /* Alloc space for copying arrays */
         (*info)->comm_cart_num_dims = ndims =
             ompi_fetch_int(process, 
-                           topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_ndims_or_nnodes,
+                           topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc.cart.ndims,
                            p_info);
         (*info)->comm_cart_dims = mqs_malloc(ndims * sizeof(int));
         if (NULL == (*info)->comm_cart_dims) {
@@ -563,10 +563,10 @@
         /* Retrieve the dimension and periodic description data from
            the two arrays on the image's communicator */
         dims = ompi_fetch_pointer(process, 
-                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_dims_or_index,
+                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc.cart.dims,
                                  p_info);
         periods = ompi_fetch_pointer(process, 
-                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_periods_or_edges,
+                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc.cart.periods,
                                  p_info);
 
         for (i = 0; i < ndims; ++i) {
@@ -584,7 +584,7 @@
         /* Alloc space for copying the indexes */
         (*info)->comm_graph_num_nodes = nnodes = 
             ompi_fetch_int(process, 
-                           topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_ndims_or_nnodes,
+                           topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc.graph.nnodes,
                            p_info);
         (*info)->comm_graph_index = mqs_malloc(nnodes * sizeof(int));
         if (NULL == (*info)->comm_graph_index) {
@@ -593,7 +593,7 @@
 
         /* Retrieve the index data */
         index = ompi_fetch_pointer(process, 
-                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_dims_or_index,
+                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc.graph.index,
                                  p_info);
         for (i = 0; i < nnodes; ++i) {
             (*info)->comm_graph_index[i] = 
@@ -610,7 +610,7 @@
 
         /* Retrieve the edge data */
         edges = ompi_fetch_pointer(process, 
-                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_periods_or_edges,
+                                 topo + i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc.graph.edges,
                                  p_info);
         for (i = 0; 
              i < (*info)->comm_graph_index[(*info)->comm_graph_num_nodes - 1]; 
Index: ompi/debuggers/ompi_common_dll.c
===================================================================
--- ompi/debuggers/ompi_common_dll.c	(revision 22197)
+++ ompi/debuggers/ompi_common_dll.c	(working copy)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007-2008 Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
@@ -331,21 +331,76 @@
                           qh_type, ompi_communicator_t, c_keyhash);
     }
     {
-        mqs_type* qh_type = mqs_find_type( image, "mca_topo_base_comm_1_0_0_t", mqs_lang_c );
+        mqs_type* qh_type, *cg_union_type, *cart_type, *graph_type;
+        int offset;
+
+        missing_in_action = "mca_topo_base_comm_2_1_0_t";
+        qh_type = mqs_find_type(image, missing_in_action, mqs_lang_c);
         if( !qh_type ) {
-            missing_in_action = "mca_topo_base_comm_1_0_0_t";
             goto type_missing;
         }
-        i_info->ompi_mca_topo_base_comm_1_0_0_t.type = qh_type;
-        i_info->ompi_mca_topo_base_comm_1_0_0_t.size = mqs_sizeof(qh_type);
-        ompi_field_offset(i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_ndims_or_nnodes,
-                          qh_type, mca_topo_base_comm_1_0_0_t, mtc_ndims_or_nnodes);
-        ompi_field_offset(i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_dims_or_index,
-                          qh_type, mca_topo_base_comm_1_0_0_t, mtc_dims_or_index);
-        ompi_field_offset(i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_periods_or_edges,
-                          qh_type, mca_topo_base_comm_1_0_0_t, mtc_periods_or_edges);
-        ompi_field_offset(i_info->ompi_mca_topo_base_comm_1_0_0_t.offset.mtc_reorder,
-                          qh_type, mca_topo_base_comm_1_0_0_t, mtc_reorder);
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.type = qh_type;
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.size = mqs_sizeof(qh_type);
+
+        /* There is a union of 2 structs in this struct -- get the
+           offsets for fields of both of them. */
+        /* Union type */
+        missing_in_action = "mca_topo_base_comm_cg_union_2_1_0_t";
+        cg_union_type = mqs_find_type(image, missing_in_action, mqs_lang_c);
+        if (!cg_union_type) {
+            goto type_missing;
+        }
+        ompi_field_offset(offset, cg_union_type, 
+                          mca_topo_base_comm_2_1_0_t, mtc);
+
+        /* By definition, the cart and base offsets are 0 in the
+           union.  We've got the base union offset, so now look up the
+           individual fields in the cart and graph structs and add
+           them to the base union offset.  Then we have the offset of
+           that field from the mca_topo_base_comm_2_1_0_t type. */
+
+        /* Cart type */
+        missing_in_action = "mca_topo_base_comm_cart_2_1_0_t";
+        cart_type = mqs_find_type(image, missing_in_action, mqs_lang_c);
+        if (!cart_type) {
+            goto type_missing;
+        }
+        ompi_field_offset(i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_cart.ndims,
+                          cart_type, mca_topo_base_comm_2_1_0_t, 
+                          mtc.cart.ndims);
+        ompi_field_offset(i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_cart.dims,
+                          cart_type, mca_topo_base_comm_2_1_0_t, 
+                          mtc.cart.dims);
+        ompi_field_offset(i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_cart.periods,
+                          cart_type, mca_topo_base_comm_2_1_0_t, 
+                          mtc.cart.periods);
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_cart.ndims += offset;
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_cart.dims += offset;
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_cart.periods += offset;
+
+        /* Graph type */
+        missing_in_action = "mca_topo_base_comm_graph_2_1_0_t";
+        graph_type = mqs_find_type(image, missing_in_action, mqs_lang_c);
+        if (!graph_type) {
+            goto type_missing;
+        }
+        ompi_field_offset(i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_graph.nnodes,
+                          graph_type, mca_topo_base_comm_2_1_0_t, 
+                          mtc.graph.nnodes);
+        ompi_field_offset(i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_graph.index,
+                          graph_type, mca_topo_base_comm_2_1_0_t, 
+                          mtc.graph.index);
+        ompi_field_offset(i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_graph.edges,
+                          graph_type, mca_topo_base_comm_2_1_0_t, 
+                          mtc.graph.edges);
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_graph.nnodes += offset;
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_graph.index += offset;
+        i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_graph.edges += offset;
+
+        /* These fields are outside of the union */
+
+        ompi_field_offset(i_info->ompi_mca_topo_base_comm_2_1_0_t.offset.mtc_reorder,
+                          qh_type, mca_topo_base_comm_2_1_0_t, mtc_reorder);
     }
     {
         mqs_type* qh_type = mqs_find_type( image, "ompi_group_t", mqs_lang_c );
Index: ompi/debuggers/ompi_common_dll_defs.h
===================================================================
--- ompi/debuggers/ompi_common_dll_defs.h	(revision 22197)
+++ ompi/debuggers/ompi_common_dll_defs.h	(working copy)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007-2008 Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2009 Cisco Systems, Inc.  All rights reserved.
  * Copyright (c) 2004-2007 The University of Tennessee and The University
  *                         of Tennessee Research Foundation.  All rights
  *                         reserved.
@@ -206,12 +206,19 @@
         mqs_type *type;
         int size;
         struct {
-            int mtc_ndims_or_nnodes;
-            int mtc_dims_or_index;
-            int mtc_periods_or_edges;
+            struct {
+                int ndims;
+                int dims;
+                int periods;
+            } mtc_cart;
+            struct {
+                int nnodes;
+                int index;
+                int edges;
+            } mtc_graph;
             int mtc_reorder;
         } offset;
-    } ompi_mca_topo_base_comm_1_0_0_t;
+    } ompi_mca_topo_base_comm_2_1_0_t;
     /* MPI_Status */
     struct {
         mqs_type *type;

