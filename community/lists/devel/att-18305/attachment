<div dir="ltr">This is puzzling. I cannot reproduce either, not even with a fresh clone. Let&#39;s assume by now this was a false alert.<div><br></div><div>  George.</div><div><br></div></div><div class="gmail_extra"><br><div class="gmail_quote">On Wed, Oct 28, 2015 at 2:01 AM, Gilles Gouaillardet <span dir="ltr">&lt;<a href="mailto:gilles@rist.or.jp" target="_blank">gilles@rist.or.jp</a>&gt;</span> wrote:<br><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
  
    
  
  <div bgcolor="#FFFFFF" text="#000000">
    George,<br>
    <br>
    as i wrote, i cannot reproduce the issue so i just had to guess.<br>
    my best guess is the wrong pmix_server.h is #include&#39;d so
    pmix_common.h is not even #include&#39;d at all<br>
    <br>
    i checked the include path<br>
    cd opal/mca/pmix/pmix1xx/pmix &amp;&amp; make clean &amp;&amp; make
    -n src/server/pmix_server_get.lo<br>
    if you can reproduce the issue without your patch, can you post the
    output ?<br>
    <br>
    in my environment, all paths are correct and in the right order, so
    it does not make any difference if<br>
    pmix_common.h or pmix/pmix_common.h is #include&#39;d<br>
    <br>
    Cheers,<br>
    <br>
    Gilles<div><div class="h5"><br>
    <br>
    <div>On 10/28/2015 2:22 PM, George Bosilca
      wrote:<br>
    </div>
    <blockquote type="cite">
      <div dir="ltr">Gilles,
        <div><br>
        </div>
        <div>Supposing that pmix_common.h has been already included, by
          adding it again I should have obtained nothing new. I don&#39;t
          know which one is picked up, but now there is at least one
          pmix_common.h to be included.</div>
        <div><br>
        </div>
        <div>If you look carrefully you will notice that the
          pmix_server.h includes pmix/pmix_common.h and not
          pmix_common.h. If you want to figure this one, that a good
          starting point. Btw, why do we have 3 headers with the same
          name (it&#39;s soooo confusing) ?</div>
        <div><br>
        </div>
        <div>  George.</div>
        <div><br>
          <div class="gmail_extra"><br>
            <div class="gmail_quote">On Wed, Oct 28, 2015 at 1:08 AM,
              Gilles Gouaillardet <span dir="ltr">&lt;<a href="mailto:gilles@rist.or.jp" target="_blank"></a><a href="mailto:gilles@rist.or.jp" target="_blank">gilles@rist.or.jp</a>&gt;</span>
              wrote:<br>
              <blockquote class="gmail_quote" style="margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;padding-left:1ex">
                <div bgcolor="#FFFFFF" text="#000000"> George,<br>
                  <br>
                  pmix_common.h is #include&#39;d by pmix_server.h<br>
                  <br>
                  well ...<br>
                  pmix_common.h is #include&#39;d by
                  opal/mca/pmix/pmix1xx/pmix/include/pmix_server.h<br>
                  and there are total 3 pmix_server.h<br>
                  find . -name pmix_server.h<br>
                  ./opal/mca/pmix/pmix1xx/pmix/include/pmix_server.h<br>
                  ./opal/mca/pmix/pmix_server.h<br>
                  ./orte/orted/pmix/pmix_server.h<br>
                  <br>
                  <br>
                  i am using VPATH, i will give it an other try without
                  VPATH<br>
                  <br>
                  so maybe the wrong pmix_server.h was #include&#39;d ...
                  and your fix hides the real issue,<br>
                  i will check this from now<br>
                  <br>
                  Cheers,<br>
                  <br>
                  Gilles<br>
                  <br>
                  <div>On 10/28/2015 1:52 PM, George Bosilca wrote:<br>
                  </div>
                  <blockquote type="cite">
                    <div dir="ltr">Interesting, I wonder how your
                      compiler gets to know the definition of the
                      PMIX_ERR_SILENT without the pmix_common.h. I just
                      pushed a fix.
                      <div><br>
                      </div>
                      <div>  George.</div>
                      <div><br>
                      </div>
                    </div>
                    <div class="gmail_extra"><br>
                      <div class="gmail_quote">On Wed, Oct 28, 2015 at
                        12:43 AM, Gilles Gouaillardet <span dir="ltr">&lt;<a href="mailto:gilles@rist.or.jp" target="_blank"></a><a href="mailto:gilles@rist.or.jp" target="_blank">gilles@rist.or.jp</a>&gt;</span>
                        wrote:<br>
                        <blockquote class="gmail_quote" style="margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;padding-left:1ex">
                          <div bgcolor="#FFFFFF" text="#000000"> George,<br>
                            <br>
                            i am unable to reproduce the issue.<br>
                            if build still breaks for you, could you
                            send me your configure command line ?<br>
                            <br>
                            Cheers,<br>
                            <br>
                            Gilles
                            <div>
                              <div><br>
                                <br>
                                <div>On 10/28/2015 1:04 PM, Gilles
                                  Gouaillardet wrote:<br>
                                </div>
                                <blockquote type="cite"> George,<br>
                                  <br>
                                  PMIX_ERR_SILENT is defined in
                                  opal/mca/pmix/pmix1xx/pmix/include/pmix/<a href="http://pmix_common.h.in" target="_blank">pmix_common.h.in</a><br>
                                  <br>
                                  i ll have a look at it from now<br>
                                  <br>
                                  Cheers,<br>
                                  <br>
                                  Gilles<br>
                                  <br>
                                  <div>On 10/28/2015 12:02 PM, George
                                    Bosilca wrote:<br>
                                  </div>
                                  <blockquote type="cite">
                                    <div dir="ltr">
                                      <div>We get a nice compiler
                                        complaint:</div>
                                      <div><br>
                                      </div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:



                                        In function &#39;pmix_server_get&#39;:</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:131:



                                        error: &#39;PMIX_ERR_SILENT&#39;
                                        undeclared (first use in this
                                        function)</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:131:



                                        error: (Each undeclared
                                        identifier is reported only once</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:131:



                                        error: for each function it
                                        appears in.)</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:117:



                                        warning: unused variable &#39;cd&#39;</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:



                                        In function
                                        &#39;_process_dmdx_reply&#39;:</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:478:



                                        error: &#39;PMIX_ERR_SILENT&#39;
                                        undeclared (first use in this
                                        function)</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:460:



                                        warning: unused variable &#39;xptr&#39;</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:460:



                                        warning: unused variable &#39;pbkt&#39;</div>
                                      <div>../../../../../../ompi/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c:460:



                                        warning: unused variable &#39;xfer&#39;</div>
                                      <div><br>
                                      </div>
                                      <div>And he is right:</div>
                                      <div><br>
                                      </div>
                                      <div>
                                        <div>$find . -name &quot;*.h&quot; -exec
                                          grep -Hn PMIX_ERR_SILENT {} +</div>
                                        <div>./opal/mca/pmix/pmix1xx/pmix/src/util/error.h:33:

                                                 if (PMIX_ERR_SILENT !=
                                          (r)) {                        
                                                    \</div>
                                      </div>
                                      <div><br>
                                      </div>
                                      <div>  George.</div>
                                      <div><br>
                                      </div>
                                      <div class="gmail_quote">----------
                                        Forwarded message ----------<br>
                                        From: <span dir="ltr">&lt;<a href="mailto:gitdub@crest.iu.edu" target="_blank"></a><a href="mailto:gitdub@crest.iu.edu" target="_blank">gitdub@crest.iu.edu</a>&gt;</span><br>
                                        Date: Tue, Oct 27, 2015 at 10:39
                                        PM<br>
                                        Subject: [OMPI commits] Git:
                                        open-mpi/ompi branch master
                                        updated. dev-2921-gb603307<br>
                                        To: <a href="mailto:ompi-commits@open-mpi.org" target="_blank">ompi-commits@open-mpi.org</a><br>
                                        <br>
                                        <br>
                                        This is an automated email from
                                        the git hooks/post-receive
                                        script. It was<br>
                                        generated because a ref change
                                        was pushed to the repository
                                        containing<br>
                                        the project &quot;open-mpi/ompi&quot;.<br>
                                        <br>
                                        The branch, master has been
                                        updated<br>
                                               via 
                                        b603307f7d33663ef6fe5941bb0d94bd2be017cb
                                        (commit)<br>
                                               via 
                                        267ca8fcd3a59b780491d80d29e870061d8dac56
                                        (commit)<br>
                                              from 
                                        3035e140511b082c51ad66e116dd381a083a191d
                                        (commit)<br>
                                        <br>
                                        Those revisions listed above
                                        that are new to this repository
                                        have<br>
                                        not appeared on any other
                                        notification email; so we list
                                        those<br>
                                        revisions in full, below.<br>
                                        <br>
                                        - Log
                                        -----------------------------------------------------------------<br>
                                        <a href="https://github.com/open-mpi/ompi/commit/b603307f7d33663ef6fe5941bb0d94bd2be017cb" rel="noreferrer" target="_blank">https://github.com/open-mpi/ompi/commit/b603307f7d33663ef6fe5941bb0d94bd2be017cb</a><br>
                                        <br>
                                        commit
                                        b603307f7d33663ef6fe5941bb0d94bd2be017cb<br>
                                        Merge: 3035e14 267ca8f<br>
                                        Author: rhc54 &lt;<a href="mailto:rhc@open-mpi.org" target="_blank"></a><a href="mailto:rhc@open-mpi.org" target="_blank">rhc@open-mpi.org</a>&gt;<br>
                                        Date:   Tue Oct 27 19:39:10 2015
                                        -0700<br>
                                        <br>
                                            Merge pull request #1073
                                        from rhc54/topic/pmix<br>
                                        <br>
                                            Cleanup the PMIx direct
                                        modex support.<br>
                                        <br>
                                        <br>
                                        <br>
                                        <a href="https://github.com/open-mpi/ompi/commit/267ca8fcd3a59b780491d80d29e870061d8dac56" rel="noreferrer" target="_blank">https://github.com/open-mpi/ompi/commit/267ca8fcd3a59b780491d80d29e870061d8dac56</a><br>
                                        <br>
                                        commit
                                        267ca8fcd3a59b780491d80d29e870061d8dac56<br>
                                        Author: Ralph Castain &lt;<a href="mailto:rhc@open-mpi.org" target="_blank"></a><a href="mailto:rhc@open-mpi.org" target="_blank">rhc@open-mpi.org</a>&gt;<br>
                                        Date:   Tue Oct 27 11:01:49 2015
                                        -0700<br>
                                        <br>
                                            Cleanup the PMIx direct
                                        modex support. Add an MCA
                                        parameter pmix_base_async_modex
                                        that will cause the async modex
                                        to be used when set to 1.
                                        Default it to 0 for now<br>
                                             to continue current default
                                        behavior.<br>
                                        <br>
                                            Also add an MCA param
                                        pmix_base_collect_data to direct
                                        that the blocking fence shall
                                        return all data to each process.
                                        Obviously, this param has no
                                        effect if async_<br>
                                            modex is used.<br>
                                        <br>
                                        diff --git
                                        a/ompi/runtime/ompi_mpi_init.c
                                        b/ompi/runtime/ompi_mpi_init.c<br>
                                        index 4c0391d..d0eebb2 100644<br>
                                        ---
                                        a/ompi/runtime/ompi_mpi_init.c<br>
                                        +++
                                        b/ompi/runtime/ompi_mpi_init.c<br>
                                        @@ -639,10 +639,9 @@ int
                                        ompi_mpi_init(int argc, char
                                        **argv, int requested, int
                                        *provided)<br>
                                        <br>
                                             /* exchange connection info
                                        - this function may also act as
                                        a barrier<br>
                                              * if data exchange is
                                        required. The modex occurs
                                        solely across procs<br>
                                        -     * in our job, so no proc
                                        array is passed. If a barrier is
                                        required,<br>
                                        -     * the &quot;modex&quot; function
                                        will perform it internally<br>
                                        -     */<br>
                                        -    OPAL_MODEX(NULL, 1);<br>
                                        +     * in our job. If a barrier
                                        is required, the &quot;modex&quot;
                                        function will<br>
                                        +     * perform it internally */<br>
                                        +    OPAL_MODEX();<br>
                                        <br>
                                           
                                         OPAL_TIMING_MNEXT((&amp;tm,&quot;time
                                        from modex to first barrier&quot;));<br>
                                        <br>
                                        diff --git
                                        a/opal/mca/pmix/base/pmix_base_frame.c
b/opal/mca/pmix/base/pmix_base_frame.c<br>
                                        index e1ab766..6e8a347 100644<br>
                                        ---
                                        a/opal/mca/pmix/base/pmix_base_frame.c<br>
                                        +++
                                        b/opal/mca/pmix/base/pmix_base_frame.c<br>
                                        @@ -31,12 +31,21 @@<br>
                                         /* Note that this initializer
                                        is important -- do not remove
                                        it!  See<br>
                                            <a href="https://github.com/open-mpi/ompi/issues/375" rel="noreferrer" target="_blank">https://github.com/open-mpi/ompi/issues/375</a>
                                        for details. */<br>
                                         opal_pmix_base_module_t
                                        opal_pmix = { 0 };<br>
                                        -bool opal_pmix_collect_all_data
                                        = false;<br>
                                        +bool opal_pmix_collect_all_data
                                        = true;<br>
                                         bool
                                        opal_pmix_base_allow_delayed_server
                                        = false;<br>
                                         int opal_pmix_verbose_output =
                                        -1;<br>
                                        +bool opal_pmix_base_async_modex
                                        = false;<br>
                                        <br>
                                         static int
                                        opal_pmix_base_frame_register(mca_base_register_flag_t
                                        flags)<br>
                                         {<br>
                                        +    opal_pmix_base_async_modex
                                        = false;<br>
                                        +    (void)
                                        mca_base_var_register(&quot;opal&quot;,
                                        &quot;pmix&quot;, &quot;base&quot;, &quot;async_modex&quot;,
                                        &quot;Use asynchronous modex mode&quot;,<br>
                                        +                               
                                         MCA_BASE_VAR_TYPE_BOOL, NULL,
                                        0, 0, OPAL_INFO_LVL_9,<br>
                                        +                               
                                         MCA_BASE_VAR_SCOPE_READONLY,
                                        &amp;opal_pmix_base_async_modex);<br>
                                        +    opal_pmix_collect_all_data
                                        = true;<br>
                                        +    (void)
                                        mca_base_var_register(&quot;opal&quot;,
                                        &quot;pmix&quot;, &quot;base&quot;, &quot;collect_data&quot;,
                                        &quot;Collect all data during modex&quot;,<br>
                                        +                               
                                         MCA_BASE_VAR_TYPE_BOOL, NULL,
                                        0, 0, OPAL_INFO_LVL_9,<br>
                                        +                               
                                         MCA_BASE_VAR_SCOPE_READONLY,
                                        &amp;opal_pmix_collect_all_data);<br>
                                             return OPAL_SUCCESS;<br>
                                         }<br>
                                        <br>
                                        diff --git
                                        a/opal/mca/pmix/pmix.h
                                        b/opal/mca/pmix/pmix.h<br>
                                        index f265e01..7223529 100644<br>
                                        --- a/opal/mca/pmix/pmix.h<br>
                                        +++ b/opal/mca/pmix/pmix.h<br>
                                        @@ -36,6 +36,8 @@ BEGIN_C_DECLS<br>
                                         /* provide access to the
                                        framework verbose output without<br>
                                          * exposing the entire base */<br>
                                         extern int
                                        opal_pmix_verbose_output;<br>
                                        +extern bool
                                        opal_pmix_collect_all_data;<br>
                                        +extern bool
                                        opal_pmix_base_async_modex;<br>
                                         extern int
                                        opal_pmix_base_exchange(opal_value_t
                                        *info,<br>
                                                                       
                                            opal_pmix_pdata_t *pdat,<br>
                                                                       
                                            int timeout);<br>
                                        @@ -254,10 +256,13 @@ extern int
                                        opal_pmix_base_exchange(opal_value_t
                                        *info,<br>
                                          * that takes into account
                                        directives and availability of<br>
                                          * non-blocking operations<br>
                                          */<br>
                                        -#define OPAL_MODEX(p, s)       
                                              \<br>
                                        -    do {                       
                                              \<br>
                                        -        opal_pmix.commit();   
                                               \<br>
                                        -        opal_pmix.fence((p),
                                        (s));    \<br>
                                        +#define OPAL_MODEX()           
                                                                \<br>
                                        +    do {                       
                                                                \<br>
                                        +        opal_pmix.commit();   
                                                                 \<br>
                                        +        if
                                        (!opal_pmix_base_async_modex) { 
                                                    \<br>
                                        +           
                                        opal_pmix.fence(NULL,           
                                                   \<br>
                                        +               
                                        opal_pmix_collect_all_data);   
                                                \<br>
                                        +        }                     
                                                                 \<br>
                                             } while(0);<br>
                                        <br>
                                         /**<br>
                                        diff --git
                                        a/opal/mca/pmix/pmix1xx/pmix/include/pmix/<a href="http://pmix_common.h.in" rel="noreferrer" target="_blank">pmix_common.h.in</a>
b/opal/mca/pmix/pmix1xx/pmix/include/pmix/<a href="http://pmix_common.h.in" rel="noreferrer" target="_blank">pmix_common.h.in</a><br>
                                        index 0216e34..5a111a1 100644<br>
                                        ---
                                        a/opal/mca/pmix/pmix1xx/pmix/include/pmix/<a href="http://pmix_common.h.in" rel="noreferrer" target="_blank">pmix_common.h.in</a><br>
                                        +++
                                        b/opal/mca/pmix/pmix1xx/pmix/include/pmix/<a href="http://pmix_common.h.in" rel="noreferrer" target="_blank">pmix_common.h.in</a><br>
                                        @@ -183,7 +183,7 @@
                                        BEGIN_C_DECLS<br>
                                        <br>
                                         /****    PMIX ERROR CONSTANTS 
                                          ****/<br>
                                         /* PMIx errors are always
                                        negative, with 0 reserved for
                                        success */<br>
                                        -#define PMIX_ERROR_MIN  -41  //
                                        set equal to number of non-zero
                                        entries in enum<br>
                                        +#define PMIX_ERROR_MIN  -42  //
                                        set equal to number of non-zero
                                        entries in enum<br>
                                        <br>
                                         typedef enum {<br>
                                           
                                         PMIX_ERR_UNPACK_READ_PAST_END_OF_BUFFER
                                        = PMIX_ERROR_MIN,<br>
                                        @@ -230,6 +230,7 @@ typedef enum
                                        {<br>
                                             PMIX_ERR_INVALID_CRED,<br>
                                             PMIX_EXISTS,<br>
                                        <br>
                                        +    PMIX_ERR_SILENT,<br>
                                             PMIX_ERROR,<br>
                                             PMIX_SUCCESS<br>
                                         } pmix_status_t;<br>
                                        diff --git
                                        a/opal/mca/pmix/pmix1xx/pmix/src/client/pmix_client_get.c
b/opal/mca/pmix/pmix1xx/pmix/src/client/pmix_client_get.c<br>
                                        index d41be9c..b93ca6d 100644<br>
                                        ---
                                        a/opal/mca/pmix/pmix1xx/pmix/src/client/pmix_client_get.c<br>
                                        +++
                                        b/opal/mca/pmix/pmix1xx/pmix/src/client/pmix_client_get.c<br>
                                        @@ -458,6 +458,7 @@ static void
                                        getnb_cbfunc(struct pmix_peer_t
                                        *pr, pmix_usock_hdr_t *hdr,<br>
                                                 PMIX_RELEASE(bptr);  //
                                        free&#39;s the data region<br>
                                                 if
                                        (PMIX_ERR_UNPACK_READ_PAST_END_OF_BUFFER
                                        != rc) {<br>
                                                     PMIX_ERROR_LOG(rc);<br>
                                        +            rc =
                                        PMIX_ERR_SILENT; // avoid
                                        error-logging twice<br>
                                                     break;<br>
                                                 }<br>
                                             }<br>
                                        diff --git
                                        a/opal/mca/pmix/pmix1xx/pmix/src/server/Makefile.am
b/opal/mca/pmix/pmix1xx/pmix/src/server/Makefile.am<br>
                                        index 5422b78..88b0468 100644<br>
                                        ---
                                        a/opal/mca/pmix/pmix1xx/pmix/src/server/Makefile.am<br>
                                        +++
                                        b/opal/mca/pmix/pmix1xx/pmix/src/server/Makefile.am<br>
                                        @@ -16,4 +16,5 @@ sources += \<br>
                                               
                                         src/server/pmix_server.c \<br>
                                               
                                         src/server/pmix_server_ops.c \<br>
                                               
                                         src/server/pmix_server_regex.c
                                        \<br>
                                        -       
                                        src/server/pmix_server_listener.c<br>
                                        +       
                                        src/server/pmix_server_listener.c
                                        \<br>
                                        +       
                                        src/server/pmix_server_get.c<br>
                                        diff --git
                                        a/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server.c
b/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server.c<br>
                                        index d16ae16..85f9e17 100644<br>
                                        ---
                                        a/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server.c<br>
                                        +++
                                        b/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server.c<br>
                                        @@ -141,8 +141,7 @@ static void
                                        _queue_message(int fd, short
                                        args, void *cbdata)<br>
                                             pmix_usock_queue_t *queue =
                                        (pmix_usock_queue_t*)cbdata;<br>
                                             pmix_usock_send_t *snd;<br>
                                             pmix_output_verbose(2,
                                        pmix_globals.debug_output,<br>
                                        -                       
                                        &quot;[%s:%d] queue callback called:
                                        reply to %s:%d on tag %d,&quot;<br>
                                        -                       
                                        &quot;event_is_active=%d&quot;,<br>
                                        +                       
                                        &quot;[%s:%d] queue callback called:
                                        reply to %s:%d on tag %d&quot;,<br>
                                                               
                                         __FILE__, __LINE__,<br>
                                                               
                                         (queue-&gt;peer)-&gt;info-&gt;nptr-&gt;nspace,<br>
                                                               
                                         (queue-&gt;peer)-&gt;info-&gt;rank,
                                        (queue-&gt;tag),<br>
                                        @@ -179,12 +178,10 @@ static
                                        void _queue_message(int fd,
                                        short args, void *cbdata)<br>
                                                 queue-&gt;buf  = (b); 
                                                                       
                                                    \<br>
                                                 queue-&gt;tag  = (t); 
                                                                       
                                                    \<br>
                                                 pmix_output_verbose(2,
                                        pmix_globals.debug_output,     
                                                 \<br>
                                        -                       
                                        &quot;[%s:%d] queue reply to %s:%d on
                                        tag %d,&quot;       \<br>
                                        -                       
                                        &quot;event_is_active=%d&quot;,           
                                                       \<br>
                                        +                       
                                        &quot;[%s:%d] queue reply to %s:%d on
                                        tag %d&quot;,       \<br>
                                                               
                                         __FILE__, __LINE__,           
                                                         \<br>
                                                               
                                         (queue-&gt;peer)-&gt;info-&gt;nptr-&gt;nspace, 
                                                    \<br>
                                        -                       
                                        (queue-&gt;peer)-&gt;info-&gt;rank,
                                        (queue-&gt;tag),        \<br>
                                        -                       
                                        (queue-&gt;peer)-&gt;send_ev_active); 
                                                       \<br>
                                        +                       
                                        (queue-&gt;peer)-&gt;info-&gt;rank,
                                        (queue-&gt;tag));       \<br>
                                               
                                         event_assign(&amp;queue-&gt;ev,
                                        pmix_globals.evbase, -1,       
                                               \<br>
                                                               
                                        EV_WRITE, _queue_message,
                                        queue);                \<br>
                                               
                                         event_priority_set(&amp;queue-&gt;ev,
                                        0);                             
                                        \<br>
                                        @@ -723,7 +720,7 @@ static void
                                        _register_client(int sd, short
                                        args, void *cbdata)<br>
                                                  * someone has been
                                        waiting for a request on a
                                        remote proc<br>
                                                  * in one of our
                                        nspaces, but we didn&#39;t know all
                                        the local procs<br>
                                                  * and so couldn&#39;t
                                        determine the proc was remote */<br>
                                        -       
                                        pmix_pending_nspace_fix(nptr);<br>
                                        +       
                                        pmix_pending_nspace_requests(nptr);<br>
                                             }<br>
                                             /* let the caller know we
                                        are done */<br>
                                             if (NULL !=
                                        cd-&gt;opcbfunc) {<br>
                                        diff --git
                                        a/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c
b/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c<br>
                                        new file mode 100644<br>
                                        index 0000000..2cb75cf<br>
                                        --- /dev/null<br>
                                        +++
                                        b/opal/mca/pmix/pmix1xx/pmix/src/server/pmix_server_get.c<br>
                                        @@ -0,0 +1,552 @@<br>
                                        +/* -*- Mode: C;
                                        c-basic-offset:4 ;
                                        indent-tabs-mode:nil -*- */<br>
                                        +/*<br>
                                        + * Copyright (c) 2014-2015
                                        Intel, Inc.  All rights
                                        reserved.<br>
                                        + * Copyright (c) 2014-2015
                                        Research Organization for
                                        Information Science<br>
                                        + *                         and
                                        Technology (RIST). All rights
                                        reserved.<br>
                                        + * Copyright (c) 2014-2015
                                        Artem Y. Polyakov &lt;<a href="mailto:artpol84@gmail.com" target="_blank"></a><a href="mailto:artpol84@gmail.com" target="_blank">artpol84@gmail.com</a>&gt;.<br>
                                        + *                         All
                                        rights reserved.<br>
                                        + * Copyright (c) 2015     
                                        Mellanox Technologies, Inc.<br>
                                        + *                         All
                                        rights reserved.<br>
                                        + * $COPYRIGHT$<br>
                                        + *<br>
                                        + * Additional copyrights may
                                        follow<br>
                                        + *<br>
                                        + * $HEADER$<br>
                                        + */<br>
                                        +<br>
                                        +#include
                                        &lt;private/autogen/config.h&gt;<br>
                                        +#include &lt;pmix/rename.h&gt;<br>
                                        +#include
                                        &lt;private/types.h&gt;<br>
                                        +#include
                                        &lt;private/pmix_stdint.h&gt;<br>
                                        +#include
                                        &lt;private/pmix_socket_errno.h&gt;<br>
                                        +<br>
                                        +#include &lt;pmix_server.h&gt;<br>
                                        +#include
                                        &quot;src/include/pmix_globals.h&quot;<br>
                                        +<br>
                                        +#ifdef HAVE_STRING_H<br>
                                        +#include &lt;string.h&gt;<br>
                                        +#endif<br>
                                        +#include &lt;fcntl.h&gt;<br>
                                        +#ifdef HAVE_UNISTD_H<br>
                                        +#include &lt;unistd.h&gt;<br>
                                        +#endif<br>
                                        +#ifdef HAVE_SYS_SOCKET_H<br>
                                        +#include &lt;sys/socket.h&gt;<br>
                                        +#endif<br>
                                        +#ifdef HAVE_SYS_UN_H<br>
                                        +#include &lt;sys/un.h&gt;<br>
                                        +#endif<br>
                                        +#ifdef HAVE_SYS_UIO_H<br>
                                        +#include &lt;sys/uio.h&gt;<br>
                                        +#endif<br>
                                        +#ifdef HAVE_SYS_TYPES_H<br>
                                        +#include &lt;sys/types.h&gt;<br>
                                        +#endif<br>
                                        +#include PMIX_EVENT_HEADER<br>
                                        +<br>
                                        +#include
                                        &quot;src/class/pmix_list.h&quot;<br>
                                        +#include
                                        &quot;src/buffer_ops/buffer_ops.h&quot;<br>
                                        +#include &quot;src/util/argv.h&quot;<br>
                                        +#include &quot;src/util/error.h&quot;<br>
                                        +#include &quot;src/util/output.h&quot;<br>
                                        +#include
                                        &quot;src/util/pmix_environ.h&quot;<br>
                                        +#include
                                        &quot;src/util/progress_threads.h&quot;<br>
                                        +#include &quot;src/usock/usock.h&quot;<br>
                                        +#include &quot;src/sec/pmix_sec.h&quot;<br>
                                        +<br>
                                        +#include &quot;pmix_server_ops.h&quot;<br>
                                        +<br>
                                        +extern pmix_server_module_t
                                        pmix_host_server;<br>
                                        +<br>
                                        +typedef struct {<br>
                                        +    pmix_object_t super;<br>
                                        +    pmix_event_t ev;<br>
                                        +    pmix_status_t status;<br>
                                        +    const char *data;<br>
                                        +    size_t ndata;<br>
                                        +    pmix_dmdx_local_t *lcd;<br>
                                        +    pmix_release_cbfunc_t
                                        relcbfunc;<br>
                                        +    void *cbdata;<br>
                                        +} pmix_dmdx_reply_caddy_t;<br>
                                        +static void
                                        dcd_con(pmix_dmdx_reply_caddy_t
                                        *p)<br>
                                        +{<br>
                                        +    p-&gt;status = PMIX_ERROR;<br>
                                        +    p-&gt;ndata = 0;<br>
                                        +    p-&gt;lcd = NULL;<br>
                                        +    p-&gt;relcbfunc = NULL;<br>
                                        +    p-&gt;cbdata = NULL;<br>
                                        +}<br>
+PMIX_CLASS_INSTANCE(pmix_dmdx_reply_caddy_t,<br>
                                        +                 
                                         pmix_object_t, dcd_con, NULL);<br>
                                        +<br>
                                        +<br>
                                        +static void
                                        dmdx_cbfunc(pmix_status_t
                                        status, const char *data,<br>
                                        +                        size_t
                                        ndata, void *cbdata,<br>
                                        +                       
                                        pmix_release_cbfunc_t relfn,
                                        void *relcbdata);<br>
                                        +static pmix_status_t
                                        _satisfy_request(pmix_hash_table_t
                                        *ht, int rank,<br>
                                        +                               
                                              pmix_modex_cbfunc_t
                                        cbfunc, void *cbdata);<br>
                                        +static pmix_status_t
                                        create_local_tracker(char
                                        nspace[], int rank,<br>
                                        +                               
                                                  pmix_info_t info[],
                                        size_t ninfo,<br>
                                        +                               
                                                  pmix_modex_cbfunc_t
                                        cbfunc,<br>
                                        +                               
                                                  void *cbdata,<br>
                                        +                               
                                                  pmix_dmdx_local_t
                                        **lcd);<br>
                                        +<br>
                                        +<br>
                                        +/* declare a function whose
                                        sole purpose is to<br>
                                        + * free data that we provided
                                        to our host server<br>
                                        + * when servicing dmodex
                                        requests */<br>
                                        +static void relfn(void *cbdata)<br>
                                        +{<br>
                                        +    char *data = (char*)cbdata;<br>
                                        +    free(data);<br>
                                        +}<br>
                                        +<br>
                                        +<br>
                                        +pmix_status_t
                                        pmix_server_get(pmix_buffer_t
                                        *buf,<br>
                                        +                             
                                        pmix_modex_cbfunc_t cbfunc,<br>
                                        +                             
                                        void *cbdata)<br>
                                        +{<br>
                                        +    int32_t cnt;<br>
                                        +    pmix_status_t rc;<br>
                                        +    int rank;<br>
                                        +    char *cptr;<br>
                                        +    char
                                        nspace[PMIX_MAX_NSLEN+1];<br>
                                        +    pmix_nspace_t *ns, *nptr;<br>
                                        +    pmix_info_t *info=NULL;<br>
                                        +    size_t ninfo=0;<br>
                                        +    pmix_dmdx_local_t *lcd,
                                        *cd;<br>
                                        +    pmix_rank_info_t *iptr;<br>
                                        +    pmix_hash_table_t *ht;<br>
                                        +    bool local;<br>
                                        +<br>
                                        +    pmix_output_verbose(2,
                                        pmix_globals.debug_output,<br>
                                        +                        &quot;recvd
                                        GET&quot;);<br>
                                        +<br>
                                        +    /* setup */<br>
                                        +    memset(nspace, 0,
                                        sizeof(nspace));<br>
                                        +<br>
                                        +    /* retrieve the nspace and
                                        rank of the requested proc */<br>
                                        +    cnt = 1;<br>
                                        +    if (PMIX_SUCCESS != (rc =
                                        pmix_bfrop.unpack(buf,
                                        &amp;cptr, &amp;cnt,
                                        PMIX_STRING))) {<br>
                                        +        PMIX_ERROR_LOG(rc);<br>
                                        +        return rc;<br>
                                        +    }<br>
                                        +    (void)strncpy(nspace, cptr,
                                        PMIX_MAX_NSLEN);<br>
                                        +    free(cptr);<br>
                                        +    cnt = 1;<br>
                                        +    if (PMIX_SUCCESS != (rc =
                                        pmix_bfrop.unpack(buf,
                                        &amp;rank, &amp;cnt, PMIX_INT)))
                                        {<br>
                                        +        PMIX_ERROR_LOG(rc);<br>
                                        +        return rc;<br>
                                        +    }<br>
                                        +    /* retrieve any provided
                                        info structs */<br>
                                        +    cnt = 1;<br>
                                        +    if (PMIX_SUCCESS != (rc =
                                        pmix_bfrop.unpack(buf,
                                        &amp;ninfo, &amp;cnt,
                                        PMIX_SIZE))) {<br>
                                        +        PMIX_ERROR_LOG(rc);<br>
                                        +        return rc;<br>
                                        +    }<br>
                                        +    if (0 &lt; ninfo) {<br>
                                        +        PMIX_INFO_CREATE(info,
                                        ninfo);<br>
                                        +        cnt = ninfo;<br>
                                        +        if (PMIX_SUCCESS != (rc
                                        = pmix_bfrop.unpack(buf, info,
                                        &amp;cnt, PMIX_INFO))) {<br>
                                        +            PMIX_ERROR_LOG(rc);<br>
                                        +           
                                        PMIX_INFO_FREE(info, ninfo);<br>
                                        +            return rc;<br>
                                        +        }<br>
                                        +    }<br>
                                        +<br>
                                        +    /* find the nspace object
                                        for this client */<br>
                                        +    nptr = NULL;<br>
                                        +    PMIX_LIST_FOREACH(ns,
                                        &amp;pmix_globals.nspaces,
                                        pmix_nspace_t) {<br>
                                        +        if (0 == strcmp(nspace,
                                        ns-&gt;nspace)) {<br>
                                        +            nptr = ns;<br>
                                        +            break;<br>
                                        +        }<br>
                                        +    }<br>
                                        +<br>
                                        +    pmix_output_verbose(2,
                                        pmix_globals.debug_output,<br>
                                        +                        &quot;%s:%d
                                        EXECUTE GET FOR %s:%d&quot;,<br>
                                        +                       
                                        pmix_globals.myid.nspace,<br>
                                        +                       
                                        pmix_globals.myid.rank, nspace,
                                        rank);<br>
                                        +<br>
                                        +    if (NULL == nptr || NULL ==
                                        nptr-&gt;server) {<br>
                                        +        /* this is for an
                                        nspace we don&#39;t know about yet,
                                        so<br>
                                        +         * record the request
                                        for data from this process and<br>
                                        +         * give the host server
                                        a chance to tell us about it */<br>
                                        +        rc =
                                        create_local_tracker(nspace,
                                        rank, info, ninfo,<br>
                                        +                               
                                          cbfunc, cbdata, &amp;lcd);<br>
                                        +        return rc;<br>
                                        +    }<br>
                                        +<br>
                                        +    /* We have to wait for all
                                        local clients to be registered
                                        before<br>
                                        +     * we can know whether this
                                        request is for data from a local
                                        or a<br>
                                        +     * remote client because
                                        one client might ask for data
                                        about another<br>
                                        +     * client that the host RM
                                        hasn&#39;t told us about yet.
                                        Fortunately,<br>
                                        +     * we do know how many
                                        clients to expect, so first
                                        check to see if<br>
                                        +     * all clients have been
                                        registered with us */<br>
                                        +     if
                                        (!nptr-&gt;server-&gt;all_registered)
                                        {<br>
                                        +        /* we cannot do
                                        anything further, so just track
                                        this request<br>
                                        +         * for now */<br>
                                        +        rc =
                                        create_local_tracker(nspace,
                                        rank, info, ninfo,<br>
                                        +                               
                                          cbfunc, cbdata, &amp;lcd);<br>
                                        +        return rc;<br>
                                        +    }<br>
                                        +<br>
                                        +    /* Since we know about all
                                        the local clients in this
                                        nspace,<br>
                                        +     * let&#39;s first try to
                                        satisfy the request with any
                                        available data.<br>
                                        +     * By default, we assume we
                                        are looking for data from a
                                        remote<br>
                                        +     * client, and then check
                                        to see if this is one of my
                                        local<br>
                                        +     * clients - if so, then we
                                        look in that hash table */<br>
                                        +    ht =
                                        &amp;nptr-&gt;server-&gt;remote;<br>
                                        +    local = false;<br>
                                        +    PMIX_LIST_FOREACH(iptr,
                                        &amp;nptr-&gt;server-&gt;ranks,
                                        pmix_rank_info_t) {<br>
                                        +        if (iptr-&gt;rank ==
                                        rank) {<br>
                                        +            /* it is known
                                        local client - check the local
                                        table */<br>
                                        +            ht =
                                        &amp;nptr-&gt;server-&gt;mylocal;<br>
                                        +            local = true;<br>
                                        +            break;<br>
                                        +        }<br>
                                        +    }<br>
                                        +<br>
                                        +    /* see if we already have
                                        this data */<br>
                                        +    rc = _satisfy_request(ht,
                                        rank, cbfunc, cbdata);<br>
                                        +    if( PMIX_SUCCESS == rc ){<br>
                                        +        /* request was
                                        successfully satisfied */<br>
                                        +        PMIX_INFO_FREE(info,
                                        ninfo);<br>
                                        +        return rc;<br>
                                        +    }<br>
                                        +<br>
                                        +    /* If we get here, then we
                                        don&#39;t have the data at this
                                        time. Check<br>
                                        +     * to see if we already
                                        have a pending request for the
                                        data - if<br>
                                        +     * we do, then we can just
                                        wait for it to arrive */<br>
                                        +    rc =
                                        create_local_tracker(nspace,
                                        rank, info, ninfo,<br>
                                        +                             
                                        cbfunc, cbdata, &amp;lcd);<br>
                                        +    if (PMIX_SUCCESS == rc) {<br>
                                        +       /* we are already
                                        waiting for the data - nothing
                                        more<br>
                                        +        * for us to do as the
                                        function added the new request<br>
                                        +        * to the tracker for us
                                        */<br>
                                        +       return PMIX_SUCCESS;<br>
                                        +    }<br>
                                        +    if (PMIX_ERR_NOT_FOUND !=
                                        rc || NULL == lcd) {<br>
                                        +       /* we have a problem -
                                        e.g., out of memory */<br>
                                        +       return rc;<br>
                                        +    }<br>
                                        +<br>
                                        +    /* Getting here means that
                                        we didn&#39;t already have a request
                                        for<br>
                                        +     * for data pending, and so
                                        we created a new tracker for
                                        this<br>
                                        +     * request. We know the
                                        identity of all our local
                                        clients, so<br>
                                        +     * if this is one, then we
                                        have nothing further to do - we
                                        will<br>
                                        +     * fulfill the request once
                                        the process commits its data */<br>
                                        +    if (local) {<br>
                                        +        return PMIX_SUCCESS;<br>
                                        +    }<br>
                                        +<br>
                                        +    /* this isn&#39;t a local
                                        client of ours, so we need to
                                        ask the host<br>
                                        +     * resource manager server
                                        to please get the info for us
                                        from<br>
                                        +     * whomever is hosting the
                                        target process */<br>
                                        +    if (NULL !=
                                        pmix_host_server.direct_modex) {<br>
                                        +        rc =
                                        pmix_host_server.direct_modex(&amp;lcd-&gt;proc,
                                        info, ninfo, dmdx_cbfunc, lcd);<br>
                                        +    } else {<br>
                                        +        /* if we don&#39;t have
                                        direct modex feature, just
                                        respond with &quot;not found&quot; */<br>
                                        +       
                                        cbfunc(PMIX_ERR_NOT_FOUND, NULL,
                                        0, cbdata, NULL, NULL);<br>
                                        +        PMIX_INFO_FREE(info,
                                        ninfo);<br>
                                        +       
                                        pmix_list_remove_item(&amp;pmix_server_globals.local_reqs,
                                        &amp;lcd-&gt;super);<br>
                                        +       
                                        PMIX_LIST_DESTRUCT(&amp;lcd-&gt;loc_reqs);<br>
                                        +        PMIX_RELEASE(lcd);<br>
                                        +        rc =
                                        PMIX_ERR_NOT_FOUND;<br>
                                        +    }<br>
                                        +<br>
                                        +    return rc;<br>
                                        +}<br>
                                        +<br>
                                        +static pmix_status_t
                                        create_local_tracker(char
                                        nspace[], int rank,<br>
                                        +                               
                                                  pmix_info_t info[],
                                        size_t ninfo,<br>
                                        +                               
                                                  pmix_modex_cbfunc_t
                                        cbfunc,<br>
                                        +                               
                                                  void *cbdata,<br>
                                        +                               
                                                  pmix_dmdx_local_t
                                        **ld)<br>
                                        +{<br>
                                        +    pmix_dmdx_local_t *lcd,
                                        *cd;<br>
                                        +    pmix_dmdx_request_t *req;<br>
                                        +    pmix_status_t rc;<br>
                                        +<br>
                                        +    /* define default */<br>
                                        +    *ld = NULL;<br>
                                        +<br>
                                        +    /* see if we already have
                                        an existing request for data<br>
                                        +     * from this namespace/rank
                                        */<br>
                                        +    lcd = NULL;<br>
                                        +    PMIX_LIST_FOREACH(cd,
                                        &amp;pmix_server_globals.local_reqs,
                                        pmix_dmdx_local_t) {<br>
                                        +        if (0 !=
                                        strncmp(nspace,
                                        cd-&gt;proc.nspace,
                                        PMIX_MAX_NSLEN) ||<br>
                                        +                rank !=
                                        cd-&gt;proc.rank ) {<br>
                                        +            continue;<br>
                                        +        }<br>
                                        +        lcd = cd;<br>
                                        +        break;<br>
                                        +    }<br>
                                        +    if (NULL != lcd) {<br>
                                        +        /* we already have a
                                        request, so just track that
                                        someone<br>
                                        +         * else wants data from
                                        the same target */<br>
                                        +        rc = PMIX_SUCCESS; //
                                        indicates we found an existing
                                        request<br>
                                        +        goto complete;<br>
                                        +    }<br>
                                        +    /* we do not have an
                                        existing request, so let&#39;s
                                        create<br>
                                        +     * one and add it to our
                                        list */<br>
                                        +    lcd =
                                        PMIX_NEW(pmix_dmdx_local_t);<br>
                                        +    if (NULL == lcd){<br>
                                        +        PMIX_INFO_FREE(info,
                                        ninfo);<br>
                                        +        return PMIX_ERR_NOMEM;<br>
                                        +    }<br>
                                        +   
                                        strncpy(lcd-&gt;proc.nspace,
                                        nspace, PMIX_MAX_NSLEN);<br>
                                        +    lcd-&gt;proc.rank = rank;<br>
                                        +    lcd-&gt;info = info;<br>
                                        +    lcd-&gt;ninfo = ninfo;<br>
                                        +   
                                        pmix_list_append(&amp;pmix_server_globals.local_reqs,
                                        &amp;lcd-&gt;super);<br>
                                        +    rc = PMIX_ERR_NOT_FOUND; 
                                        // indicates that we created a
                                        new request tracker<br>
                                        +<br>
                                        +  complete:<br>
                                        +    /* track this specific
                                        requestor so we return the<br>
                                        +     * data to them */<br>
                                        +    req =
                                        PMIX_NEW(pmix_dmdx_request_t);<br>
                                        +    req-&gt;cbfunc = cbfunc;<br>
                                        +    req-&gt;cbdata = cbdata;<br>
                                        +   
                                        pmix_list_append(&amp;lcd-&gt;loc_reqs,
                                        &amp;req-&gt;super);<br>
                                        +    *ld = lcd;<br>
                                        +    return rc;<br>
                                        +}<br>
                                        +<br>
                                        +void
                                        pmix_pending_nspace_requests(pmix_nspace_t
                                        *nptr)<br>
                                        +{<br>
                                        +    pmix_dmdx_local_t *cd,
                                        *cd_next;<br>
                                        +<br>
                                        +    /* Now that we know all
                                        local ranks, go along request
                                        list and ask for remote data<br>
                                        +     * for the non-local ranks,
                                        and resolve all pending requests
                                        for local procs<br>
                                        +     * that were waiting for
                                        registration to complete<br>
                                        +     */<br>
                                        +    PMIX_LIST_FOREACH_SAFE(cd,
                                        cd_next,
                                        &amp;pmix_server_globals.local_reqs,
                                        pmix_dmdx_local_t) {<br>
                                        +        pmix_rank_info_t *info;<br>
                                        +        bool found = false;<br>
                                        +<br>
                                        +        if (0 !=
                                        strncmp(nptr-&gt;nspace,
                                        cd-&gt;proc.nspace,
                                        PMIX_MAX_NSLEN) ) {<br>
                                        +            continue;<br>
                                        +        }<br>
                                        +<br>
                                        +        PMIX_LIST_FOREACH(info,
                                        &amp;nptr-&gt;server-&gt;ranks,
                                        pmix_rank_info_t) {<br>
                                        +            if (info-&gt;rank
                                        == cd-&gt;proc.rank) {<br>
                                        +                found = true; 
                                        // we will satisy this request
                                        upon commit from new proc<br>
                                        +                break;<br>
                                        +            }<br>
                                        +        }<br>
                                        +<br>
                                        +        /* if not found - this
                                        is remote process and we need to
                                        send<br>
                                        +         * corresponding direct
                                        modex request */<br>
                                        +        if( !found ){<br>
                                        +            if( NULL !=
                                        pmix_host_server.direct_modex ){<br>
                                        +               
                                        pmix_host_server.direct_modex(&amp;cd-&gt;proc,
                                        cd-&gt;info, cd-&gt;ninfo,
                                        dmdx_cbfunc, cd);<br>
                                        +            } else {<br>
                                        +               
                                        pmix_dmdx_request_t *req,
                                        *req_next;<br>
                                        +               
                                        PMIX_LIST_FOREACH_SAFE(req,
                                        req_next, &amp;cd-&gt;loc_reqs,
                                        pmix_dmdx_request_t) {<br>
                                        +                   
                                        req-&gt;cbfunc(PMIX_ERR_NOT_FOUND,
                                        NULL, 0, req-&gt;cbdata, NULL,
                                        NULL);<br>
                                        +                   
                                        pmix_list_remove_item(&amp;cd-&gt;loc_reqs,
                                        &amp;req-&gt;super);<br>
                                        +                   
                                        PMIX_RELEASE(req);<br>
                                        +                }<br>
                                        +               
                                        pmix_list_remove_item(&amp;pmix_server_globals.local_reqs,
                                        &amp;cd-&gt;super);<br>
                                        +               
                                        PMIX_RELEASE(cd);<br>
                                        +            }<br>
                                        +        }<br>
                                        +    }<br>
                                        +}<br>
                                        +<br>
                                        +static pmix_status_t
                                        _satisfy_request(pmix_hash_table_t
                                        *ht, int rank,<br>
                                        +                               
                                              pmix_modex_cbfunc_t
                                        cbfunc, void *cbdata)<br>
                                        +{<br>
                                        +    pmix_status_t rc;<br>
                                        +    pmix_value_t *val;<br>
                                        +    char *data;<br>
                                        +    size_t sz;<br>
                                        +    pmix_buffer_t xfer, pbkt,
                                        *xptr;<br>
                                        +<br>
                                        +    /* check to see if this
                                        data already has been<br>
                                        +     * obtained as a result of
                                        a prior direct modex request
                                        from<br>
                                        +     * a remote peer, or due to
                                        data from a local client<br>
                                        +     * having been committed */<br>
                                        +    rc = pmix_hash_fetch(ht,
                                        rank, &quot;modex&quot;, &amp;val);<br>
                                        +    if (PMIX_SUCCESS == rc
                                        &amp;&amp; NULL != val) {<br>
                                        +        /* the client is
                                        expecting this to arrive as a
                                        byte object<br>
                                        +         * containing a buffer,
                                        so package it accordingly */<br>
                                        +       
                                        PMIX_CONSTRUCT(&amp;pbkt,
                                        pmix_buffer_t);<br>
                                        +       
                                        PMIX_CONSTRUCT(&amp;xfer,
                                        pmix_buffer_t);<br>
                                        +        xptr = &amp;xfer;<br>
                                        +       
                                        PMIX_LOAD_BUFFER(&amp;xfer,
                                        val-&gt;data.bo.bytes,
                                        val-&gt;data.bo.size);<br>
                                        +       
                                        pmix_bfrop.pack(&amp;pbkt,
                                        &amp;xptr, 1, PMIX_BUFFER);<br>
                                        +        xfer.base_ptr = NULL;
                                        // protect the passed data<br>
                                        +        xfer.bytes_used = 0;<br>
                                        +       
                                        PMIX_DESTRUCT(&amp;xfer);<br>
                                        +       
                                        PMIX_UNLOAD_BUFFER(&amp;pbkt,
                                        data, sz);<br>
                                        +       
                                        PMIX_DESTRUCT(&amp;pbkt);<br>
                                        +       
                                        PMIX_VALUE_RELEASE(val);<br>
                                        +        /* pass it back */<br>
                                        +        cbfunc(rc, data, sz,
                                        cbdata, relfn, data);<br>
                                        +        return rc;<br>
                                        +    }<br>
                                        +    return PMIX_ERR_NOT_FOUND;<br>
                                        +}<br>
                                        +<br>
                                        +/* Resolve pending requests to
                                        this namespace/rank */<br>
                                        +pmix_status_t
                                        pmix_pending_resolve(pmix_nspace_t
                                        *nptr, int rank,<br>
                                        +                               
                                           pmix_status_t status,
                                        pmix_dmdx_local_t *lcd)<br>
                                        +{<br>
                                        +    pmix_dmdx_local_t *cd;<br>
                                        +<br>
                                        +    /* find corresponding
                                        request (if exists) */<br>
                                        +    if (NULL == lcd &amp;&amp;
                                        NULL != nptr) {<br>
                                        +        PMIX_LIST_FOREACH(cd,
                                        &amp;pmix_server_globals.local_reqs,
                                        pmix_dmdx_local_t) {<br>
                                        +            if (0 !=
                                        strncmp(nptr-&gt;nspace,
                                        cd-&gt;proc.nspace,
                                        PMIX_MAX_NSLEN) ||<br>
                                        +                    rank !=
                                        cd-&gt;proc.rank) {<br>
                                        +                continue;<br>
                                        +            }<br>
                                        +            lcd = cd;<br>
                                        +            break;<br>
                                        +        }<br>
                                        +    }<br>
                                        +<br>
                                        +    /* If somebody was
                                        interested in this rank */<br>
                                        +    if (NULL != lcd) {<br>
                                        +        pmix_dmdx_request_t
                                        *req;<br>
                                        +<br>
                                        +        if (PMIX_SUCCESS !=
                                        status){<br>
                                        +            /* if we&#39;ve got an
                                        error for this request - just
                                        forward it*/<br>
                                        +           
                                        PMIX_LIST_FOREACH(req,
                                        &amp;lcd-&gt;loc_reqs,
                                        pmix_dmdx_request_t) {<br>
                                        +                /* if we can&#39;t
                                        satisfy this request - respond
                                        with error */<br>
                                        +               
                                        req-&gt;cbfunc(status, NULL, 0,
                                        req-&gt;cbdata, NULL, NULL);<br>
                                        +            }<br>
                                        +        } else if (NULL !=
                                        nptr) {<br>
                                        +            /* if we&#39;ve got the
                                        blob - try to satisfy requests
                                        */<br>
                                        +            pmix_hash_table_t
                                        *ht;<br>
                                        +            pmix_rank_info_t
                                        *iptr;<br>
                                        +<br>
                                        +            /* by default we
                                        are looking for the remote data
                                        */<br>
                                        +            ht =
                                        &amp;nptr-&gt;server-&gt;remote;<br>
                                        +            /* check if this
                                        rank is local */<br>
                                        +           
                                        PMIX_LIST_FOREACH(iptr,
                                        &amp;nptr-&gt;server-&gt;ranks,
                                        pmix_rank_info_t) {<br>
                                        +                if
                                        (iptr-&gt;rank == rank) {<br>
                                        +                    ht =
                                        &amp;nptr-&gt;server-&gt;mylocal;<br>
                                        +                    break;<br>
                                        +                }<br>
                                        +            }<br>
                                        +<br>
                                        +            /* run through all
                                        the requests to this rank */<br>
                                        +           
                                        PMIX_LIST_FOREACH(req,
                                        &amp;lcd-&gt;loc_reqs,
                                        pmix_dmdx_request_t) {<br>
                                        +                pmix_status_t
                                        rc;<br>
                                        +                rc =
                                        _satisfy_request(ht, rank,
                                        req-&gt;cbfunc, req-&gt;cbdata);<br>
                                        +                if(
                                        PMIX_SUCCESS != rc ){<br>
                                        +                    /* if we
                                        can&#39;t satisfy this particular
                                        request (missing key?) */<br>
                                        +                   
                                        req-&gt;cbfunc(rc, NULL, 0,
                                        req-&gt;cbdata, NULL, NULL);<br>
                                        +                }<br>
                                        +            }<br>
                                        +        }<br>
                                        +        /* remove all requests
                                        to this rank and cleanup the
                                        corresponding structure */<br>
                                        +       
                                        pmix_list_remove_item(&amp;pmix_server_globals.local_reqs,
                                        (pmix_list_item_t*)lcd);<br>
                                        +        PMIX_RELEASE(lcd);<br>
                                        +    }<br>
                                        +    return PMIX_SUCCESS;<br>
                                        +}<br>
                                        +<br>
                                        +/* process the returned data
                                        from the host RM server */<br>
                                        +static void
                                        _process_dmdx_reply(int fd,
                                        short args, void *cbdata)<br>
                                        +{<br>
                                        +    pmix_dmdx_reply_caddy_t
                                        *caddy =
                                        (pmix_dmdx_reply_caddy_t
                                        *)cbdata;<br>
                                        +    pmix_kval_t *kp;<br>
                                        +    pmix_nspace_t *ns, *nptr;<br>
                                        +    pmix_status_t rc;<br>
                                        +    pmix_buffer_t xfer, pbkt,
                                        *xptr;<br>
                                        +<br>
                                        +    pmix_output_verbose(2,
                                        pmix_globals.debug_output,<br>
                                        +                    &quot;[%s:%d]
                                        process dmdx reply from %s:%d&quot;,<br>
                                        +                    __FILE__,
                                        __LINE__,<br>
                                        +                   
                                        caddy-&gt;lcd-&gt;proc.nspace,
                                        caddy-&gt;lcd-&gt;proc.rank);<br>
                                        +<br>
                                        +    /* find the nspace object
                                        for this client */<br>
                                        +    nptr = NULL;<br>
                                        +    PMIX_LIST_FOREACH(ns,
                                        &amp;pmix_globals.nspaces,
                                        pmix_nspace_t) {<br>
                                        +        if (0 ==
                                        strcmp(caddy-&gt;lcd-&gt;proc.nspace,
                                        ns-&gt;nspace)) {<br>
                                        +            nptr = ns;<br>
                                        +            break;<br>
                                        +        }<br>
                                        +    }<br>
                                        +<br>
                                        +    if (NULL == nptr) {<br>
                                        +        /* should be impossible
                                        */<br>
                                        +       
                                        PMIX_ERROR_LOG(PMIX_ERR_NOT_FOUND);<br>
                                        +        caddy-&gt;status =
                                        PMIX_ERR_NOT_FOUND;<br>
                                        +        goto cleanup;<br>
                                        +    }<br>
                                        +<br>
                                        +    /* if the request was
                                        successfully satisfied, then
                                        store the data<br>
                                        +     * in our hash table for
                                        remote procs. Although we could
                                        immediately<br>
                                        +     * resolve any outstanding
                                        requests on our tracking list,
                                        we instead<br>
                                        +     * store the data first so
                                        we can immediately satisfy any
                                        future<br>
                                        +     * requests. Then, rather
                                        than duplicate the resolve code
                                        here, we<br>
                                        +     * will let the
                                        pmix_pending_resolve function go
                                        ahead and retrieve<br>
                                        +     * it from the hash table
                                        */<br>
                                        +    if (PMIX_SUCCESS ==
                                        caddy-&gt;status) {<br>
                                        +        kp =
                                        PMIX_NEW(pmix_kval_t);<br>
                                        +        kp-&gt;key =
                                        strdup(&quot;modex&quot;);<br>
                                        +       
                                        PMIX_VALUE_CREATE(kp-&gt;value,
                                        1);<br>
                                        +        kp-&gt;value-&gt;type =
                                        PMIX_BYTE_OBJECT;<br>
                                        +        /* we don&#39;t know if the
                                        host is going to save this data<br>
                                        +         * or not, so we have
                                        to copy it - the client is
                                        expecting<br>
                                        +         * this to arrive as a
                                        byte object containing a buffer,
                                        so<br>
                                        +         * package it
                                        accordingly */<br>
                                        +       
                                        kp-&gt;value-&gt;data.bo.bytes =
                                        malloc(caddy-&gt;ndata);<br>
                                        +       
                                        memcpy(kp-&gt;value-&gt;data.bo.bytes,
                                        caddy-&gt;data,
                                        caddy-&gt;ndata);<br>
                                        +       
                                        kp-&gt;value-&gt;data.bo.size =
                                        caddy-&gt;ndata;<br>
                                        +        /* store it in the
                                        appropriate hash */<br>
                                        +        if (PMIX_SUCCESS != (rc
                                        =
                                        pmix_hash_store(&amp;nptr-&gt;server-&gt;remote,
                                        caddy-&gt;lcd-&gt;proc.rank,
                                        kp))) {<br>
                                        +            PMIX_ERROR_LOG(rc);<br>
                                        +        }<br>
                                        +        PMIX_RELEASE(kp);  //
                                        maintain acctg<br>
                                        +    }<br>
                                        +<br>
                                        +    /* always execute the
                                        callback to avoid having the
                                        client hang */<br>
                                        +    pmix_pending_resolve(nptr,
                                        caddy-&gt;lcd-&gt;proc.rank,
                                        caddy-&gt;status,
                                        caddy-&gt;lcd);<br>
                                        +<br>
                                        +cleanup:<br>
                                        +    /* now call the release
                                        function so the host server<br>
                                        +     * knows it can release the
                                        data */<br>
                                        +    if (NULL !=
                                        caddy-&gt;relcbfunc) {<br>
                                        +       
                                        caddy-&gt;relcbfunc(caddy-&gt;cbdata);<br>
                                        +    }<br>
                                        +    PMIX_RELEASE(caddy);<br>
                           </div></div></blockquote></blockquote></div></div></div></blockquote></div></div></blockquote></div></blockquote></div></div></div></div></blockquote></div></div></div>...<br><br>[Message clipped]  <br>_______________________________________________<br>
devel mailing list<br>
<a href="mailto:devel@open-mpi.org">devel@open-mpi.org</a><br>
Subscription: <a href="http://www.open-mpi.org/mailman/listinfo.cgi/devel" rel="noreferrer" target="_blank">http://www.open-mpi.org/mailman/listinfo.cgi/devel</a><br>
Link to this post: <a href="http://www.open-mpi.org/community/lists/devel/2015/10/18304.php" rel="noreferrer" target="_blank">http://www.open-mpi.org/community/lists/devel/2015/10/18304.php</a><br></blockquote></div><br></div>

