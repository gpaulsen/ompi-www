<html><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div apple-content-edited="true"><span class="Apple-style-span" style="border-collapse: separate; color: rgb(0, 0, 0); font-family: Helvetica; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; "><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div><div><div>On Jun 10, 2010, at 1:47 AM, Sylvain Jeaugey wrote:</div></div></div></div></span></div><div><br class="Apple-interchange-newline"><blockquote type="cite"><div>On Wed, 9 Jun 2010, Jeff Squyres wrote:<br><br><blockquote type="cite">On Jun 9, 2010, at 3:26 PM, Samuel K. Gutierrez wrote:<br></blockquote><blockquote type="cite"><br></blockquote><blockquote type="cite"><blockquote type="cite">System V shared memory cleanup is a concern only if a process dies in<br></blockquote></blockquote><blockquote type="cite"><blockquote type="cite">between shmat and shmctl IPC_RMID. &nbsp;Shared memory segment cleanup<br></blockquote></blockquote><blockquote type="cite"><blockquote type="cite">should happen automagically in most cases, including abnormal process<br></blockquote></blockquote><blockquote type="cite"><blockquote type="cite">termination.<br></blockquote></blockquote><blockquote type="cite"><br></blockquote><blockquote type="cite">Umm... right. &nbsp;Duh. &nbsp;I knew that.<br></blockquote><blockquote type="cite"><br></blockquote><blockquote type="cite">Really.<br></blockquote><blockquote type="cite"><br></blockquote><blockquote type="cite">So -- we're good!<br></blockquote><blockquote type="cite"><br></blockquote><blockquote type="cite">Let's open the discussion of making sysv the default on systems that support the IPC_RMID behavior (which, AFAIK, is only Linux)...<br></blockquote>I'm sorry, but I think System V has many disadvantages over mmap.<br><br>1. As discussed before, cleaning is not as easy as for a file. It is a good thing to remove the shm segment after creation, but since problems often happen during shmget/shmat, there's still a high risk of letting things behind.<br><br>2. There are limits in the kernel you need to grow (kernel.shmall, kernel.shmmax).</div></blockquote><br><div>I agree that this is a disadvantage, but changing shmall and shmmax limits is *only* as painful as having a system admin change a few settings (okay, it's painful ;-) ).</div><br><blockquote type="cite"><div>On most linux distribution, shmmax is 32MB, which does not permit the sysv mechanism to work. Mmapped files are unlimited.</div></blockquote><div><br></div><div>Not necessarily true. &nbsp;If a user *really* wanted to use sysv and their system's shmmax limit was 32MB, they could just add&nbsp;-mca mpool_sm_min_size 33550000 and everything would work properly. &nbsp;I do understand, however, that this may not be ideal and may have performance implications.</div><div><br></div><div>Based on this, I'm leaning towards the default behavior that we currently have in the trunk:</div><div><br></div><div>- sysv disabled by default</div><div>- use mmap, unless sysv is explicitly requested by the user</div><div><br></div><blockquote type="cite"><div><font class="Apple-style-span" color="#000000"><br></font>3. Each shm segment is identified by a 32 bit integer. This namespace is small (and non-intuitive, as opposed to a file name), and the probability for a collision is not null, especially when you start creating multiple shared memory segments (for collectives, one-sided operations, ...).<br></div></blockquote><div><br></div><div>I'm not sure if collisions are a problem. &nbsp;I'm using&nbsp;shmget(IPC_PRIVATE), so I'm guessing once I've asked for more than ~ 2^16 keys, things will fail.</div><div><br></div><blockquote type="cite"><div><font class="Apple-style-span" color="#000000"><br></font>So, I'm a bit reluctant to work with System V mechanisms again. I don't think there is a *real* reason for System V to be faster than mmap, since it should just be memory. I'd rather find out why mmap is slower.</div></blockquote><div><br></div><div>Jeff and I talked, and we are going to hack something together that uses&nbsp;shm_open and friends and incorporates more sophisticated fallback mechanisms if a particular component fails initialization. &nbsp;Once we are done with that work, would you be willing to conduct another similar performance study that incorporates all sm mechanisms?</div><div><br></div><div>Thanks,</div><div><br></div><div><div>--</div><div><div><div>Samuel K. Gutierrez</div><div>Los Alamos National Laboratory</div></div></div></div><br><blockquote type="cite"><div><br>Sylvain<br>_______________________________________________<br>devel mailing list<br><a href="mailto:devel@open-mpi.org">devel@open-mpi.org</a><br>http://www.open-mpi.org/mailman/listinfo.cgi/devel<br></div></blockquote></div><br></body></html>
