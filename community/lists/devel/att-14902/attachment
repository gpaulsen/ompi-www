<div dir="ltr">Ralph,<br><div><div class="gmail_extra"><br><br><div class="gmail_quote">On Wed, May 28, 2014 at 9:53 PM, Ralph Castain <span dir="ltr">&lt;<a href="mailto:rhc@open-mpi.org" target="_blank">rhc@open-mpi.org</a>&gt;</span> wrote:<br>
<blockquote class="gmail_quote" style="margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex"><div style="word-wrap:break-word"><div style="margin:0px;font-size:11px;font-family:Menlo;background-color:rgb(254,244,156)">
gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-4)</div><div><div style="margin:0px;font-size:11px;font-family:Menlo;background-color:rgb(254,244,156)"> ./configure --prefix=/home/common/openmpi/build/svn-trunk --enable-mpi-java --enable-orterun-prefix-by-default</div>
</div><div style="margin:0px;font-size:11px;font-family:Menlo;background-color:rgb(254,244,156)"><br></div><div style="margin:0px;font-size:11px;font-family:Menlo;background-color:rgb(254,244,156)">More inline below</div>
<div style="margin:0px;font-size:11px;font-family:Menlo;background-color:rgb(254,244,156)"><br></div><div><div class=""><div></div></div></div></div></blockquote><div><br></div><div>this looks like an up-to-date CentOS box.<br>
</div><div>i am unable to reproduce the warnings (may be uninitialized in this function) with a similar box :-(<br><br></div><div></div><div> </div><blockquote class="gmail_quote" style="margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex">
<div style="word-wrap:break-word"><div><div><div>On May 27, 2014, at 9:29 PM, Gilles Gouaillardet &lt;<a href="mailto:gilles.gouaillardet@gmail.com" target="_blank">gilles.gouaillardet@gmail.com</a>&gt; wrote:</div>so far, it seems this is a false positive/compiler bug that could be triggered by inlining<br>
</div></div><div><div class=""><blockquote type="cite"><div dir="ltr"><div>/* i could not find any path in which the variable is used unitialized */<br></div></div></blockquote><div><br></div></div>I just glanced at the first one (line 221 of osc_rdma_data_move.c), and I can see what the compiler is complaining about - have gotten this in other places as well. The problem is that you pass the address of ptr into a function without first initializing the value of ptr itself. There is no guarantee (so far as the compiler can see) that this function will in fact set the value of ptr - you are relying solely on the fact that (a) you checked that function at one point in time and saw that it always gets set to something if ret == OMPI_SUCCESS, and (b) nobody changed that function since you checked.</div>
<div><br></div><div>Newer compilers seem to be getting more defensive about such things and starting to &quot;bark&quot; when they see it. I think you are correct that inlining also impacts that situation, though I&#39;ve also been seeing it when the functions aren&#39;t inlined.</div>
<div><br></div></div></blockquote><div><br></div><div>i wrote the simple test program :<br><br>#include &lt;string.h&gt;<br><br>char * mystring = &quot;hello&quot;;<br>static inline int setif(int mustset, char **ptr) {<br>
        if (!mustset) {<br>                return 1;<br>        }<br>        *ptr = mystring;<br>        return 0;<br>}<br><br>void good(int mustset) {<br>        char * ptr;<br>        char buf[256];<br>        if (setif(mustset, &amp;ptr) == 0) {<br>
                memcpy(buf, ptr, 6);<br>        }<br>}<br><br>void bad(int mustset) {<br>        char * ptr;<br>        char buf[256];<br>        if (setif(mustset, &amp;ptr) != 0) {<br>                memcpy(buf, ptr, 6);<br>
        }<br>}<br><br></div><div>please note that :<br></div><div>- the setif function is declared &#39;inline&#39;<br></div><div>- the setif will set *ptr only if the &#39;mustset&#39; parameter is nonzero and then return 0<br>
</div><div>- the setif will leave *ptr unmodified if the &#39;mustset&#39; parameter is zero and then return 1<br></div><div><br></div><div>it is trivial that the &#39;good&#39; function is ok whereas the &#39;bad&#39; function has an issue :<br>
</div><div>the compiler has a way to figure out that ptr will be uninitialized when invoking memcpy<br></div><div>(since setif returned a non zero status)<br><br></div><div>gcc -Wall -O0 test.c<br></div><div>does not complain<br>
</div><div><br></div><div>gcc -Wall -O1 test.c *does* complain<br></div><div>test.c:24: warning: ‘ptr’ may be used uninitialized in this function<br><br></div><div>if the &#39;inline&#39; keyword is omitted, -O2 is needed to get a compiler warning.<br>
<br></div><div>bottom line, an optimized build (-O3 -finline-functions) correctly issues a warning.<br></div><div>i checked osc_rdma_data_move.c and osc_rdma_frag.h again and again and i could not find how ptr can be uninitialized in ompi_osc_rdma_control_send if<br>
</div><div>ompi_osc_rdma_frag_alloc returned OMPI_SUCCESS<br></div><div>/* not to mention i am unable to reproduce the warning */<br><br></div><div>about the compiler getting more defensive :<br></div><div><br>{ int rank;<br>
</div><div>  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br></div><div>  rank++;<br>}<br></div><div><br></div><div>i never saw a compiler issue a warning about rank that could be used uninitialized<br><br> <br></div><blockquote class="gmail_quote" style="margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex">
<div style="word-wrap:break-word"><div></div><div>Not sure what to suggest here - hate to add initialization steps in that sequence....</div><div><br></div></div></blockquote><div>me too, and i do not see any warnings from the compiler<br>
<br></div><div>can you please confirm you can reproduce the issue on the most up to date trunk revision , on a x86_64 box (never knows ...) ?<br></div><div>then can you send the output of<br></div><div><br>cd ompi/mca/osc/rdma<br>
</div><div>touch osc_rdma_data_move.c<br>make -n osc_rdma_data_move.lo<br></div><div><br><br></div><div>Cheers,<br><br>Gilles </div></div><br></div></div></div>

