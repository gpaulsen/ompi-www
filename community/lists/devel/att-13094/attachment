<html><head><meta http-equiv="Content-Type" content="text/html charset=windows-1252"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><br><div><div>On Oct 11, 2013, at 17:09 , Ralph Castain &lt;<a href="mailto:rhc@open-mpi.org">rhc@open-mpi.org</a>&gt; wrote:</div><br class="Apple-interchange-newline"><blockquote type="cite"><meta http-equiv="Content-Type" content="text/html charset=windows-1252"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><br><div><div>On Oct 11, 2013, at 4:07 AM, George Bosilca &lt;<a href="mailto:bosilca@icl.utk.edu">bosilca@icl.utk.edu</a>&gt; wrote:</div><br class="Apple-interchange-newline"><blockquote type="cite"><meta http-equiv="Content-Type" content="text/html charset=windows-1252"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><br><div><div>On Oct 9, 2013, at 15:29 , Ralph Castain &lt;<a href="mailto:rhc@open-mpi.org">rhc@open-mpi.org</a>&gt; wrote:</div><br class="Apple-interchange-newline"><blockquote type="cite"><meta http-equiv="Content-Type" content="text/html charset=windows-1252"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">IIRC, the concern was with where the thread safety should reside. Some classes (e.g., opal_list) were littered with thread locks for every operation. So if someone implemented thread protection at a higher level (e.g., protecting the list while cycling thru it), then all these lower-level lock/unlock operations were just a waste of cycles.</div></blockquote><div><br></div><div>I tried to find these protections in the basic objects (pal_list_t as you named it) but I failed. I don't see this being the case in any of the versions out there (1.6, 1.7 nor trunk). There are some atomic operations to keep track of the ref counts, but this is a completely different topic.</div><div><br></div><div>In the OMPI layer we tried to follow the rule that all calls without capitals are not thread safe (and are functions), while all calls with capitals at macros and are protected. This was a best effort applied where it made sense.</div></div></div></blockquote><div><br></div>Only one I could find that has been renamed is ompi_free_list_resize, which has been renamed to ompi_free_list_resize_mt as it includes a lock/unlock in it. However, there are many places in the opal and ompi classes where thread locks are being called - this is what we seek to remove.</div><div><br></div><div><div>opal/class/opal_pointer_array.c:45: &nbsp; &nbsp;OBJ_CONSTRUCT(&amp;array-&gt;lock, opal_mutex_t);</div><div>opal/class/opal_pointer_array.c:67: &nbsp; &nbsp;OBJ_DESTRUCT(&amp;array-&gt;lock);</div><div>opal/class/opal_pointer_array.c:113: &nbsp; &nbsp;OPAL_THREAD_LOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:120: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:149: &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:171: &nbsp; &nbsp;OPAL_THREAD_LOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:175: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:215: &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:248: &nbsp; &nbsp;OPAL_THREAD_LOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:251: &nbsp; &nbsp; &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:260: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:291: &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(table-&gt;lock));</div><div>opal/class/opal_pointer_array.c:297: &nbsp; &nbsp;OPAL_THREAD_LOCK(&amp;(array-&gt;lock));</div><div>opal/class/opal_pointer_array.c:300: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(array-&gt;lock));</div><div>opal/class/opal_pointer_array.c:304: &nbsp; &nbsp;OPAL_THREAD_UNLOCK(&amp;(array-&gt;lock));</div></div></div></blockquote><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><br><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">However, some people felt that there were places where it helped to have the locking down below. So this was the compromise - use the version that fits your situation.</div></blockquote><div><br></div><div>In most of the cases there is nothing better we can do down than protecting the call itself.&nbsp;</div></div></blockquote><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><br><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">Personally, I'm not wild about it, but I can live with it. I'd prefer to see no lock/unlock calls in the classes themselves as they are too atomistic, and would have opted for providing a macro version of the function that included the appropriate lock/unlocks around the function.</div></blockquote><div><br></div><div>I'm 100% with you here, I also prefer to see the locks, as this makes errors easier to spot. This is why I'm concerned about moving them outside the view, buried under several levels of macro indirections. I could understand the push if there was an obvious performance or safety benefit, but as I fail to see I was wondering if I was missing something from the "bigger" picture.</div></div></blockquote><div><br></div>Here's how I recollect the discussion. There are thread locks down in many of the opal classes</div></div></blockquote><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div>- the opal_pointer_array and opal_list functions have embedded lock/unlock in their operations, and I believe others do too. </div></div></blockquote><div><br></div>There are only 3 classes that have locks: pointer array, freelist and ring buffer. The opal_list has nothing to do with threads, there are no protections.</div><div><br></div><div><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div>We talked about our desired threading model and agreed that this was too low down in the stack. For example, looping over an opal_list shouldn't invoke a thread lock/unlock for every opal_list_get_next call - we can just lock the loop and avoid all the performance hit. So we agreed on a higher-level thread protection model where we lock up above where the calls are being made.</div></div></blockquote><div><br></div><div>Thing that can be reached for all existing classes by calling the version without capitals. There is one exception, the pointer array which was one of these classes with a double history (one in ORTE and one in OMPI). The OMPI version needed protection as we use it to make the translation between C and Fortran …</div><br><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div>However, someone pointed out that there might be times when locking at the lower level made sense. So we agreed that&nbsp;any function that actually might benefit from internal thread protection would have two variants: _mt that had the locks, and _st that did not. I think the rationale against the macro definition is that the lock might occur inside the function - e.g., there might be a conditional branch in the function that required the lock, but not the entire function. Putting the lock around the function would force it to always occur, which letting the lock be inside the function would avoid it unless necessary.</div></div></blockquote><div><br></div><div>Taking a non contentious lock on today's architectures does not bear the cost it once had. So the few cases where the internal lock might be in the path, can hardly justify such an invasive change.</div><br><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div>Hence the work plan in the meeting minutes. Someone would go into those classes and make two copies of each class. The _st version would have all its lock/unlock calls removed, while the _mt version would retain them. We would then go into the places where those classes are called and either replace the existing call with _mt (since that was the prior functionality), or introduce a lock around the code and use the _st version (the preferred solution).</div><div><br></div><div>The plan eventually is to eliminate the _mt versions except where they specifically are required. Personally, I would expect that to be pretty rare, and so I would prefer an approach that doesn't add _st all over the place - our function names are long enough already!</div></div></blockquote><div><br></div><div>I wasn't trying to stir a long discussion about this, but to understand why such an invasive approach was taken.</div><div><br></div><div>Why don't we take the other path around. We use the described way as a template on how things should be done in case there is a need to have a single and a multi-threaded version of one of the basic classes. The first developer who needs the _mt version is a winner and his legacy of bringing the _mt version to life (following the above specifications) will live forever and even in the Internet history.</div><div><br></div><div>&nbsp; George.</div><br><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div><br></div><div>HTH</div><div>Ralph</div><div><br></div><div><br><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div><div><br></div><div>&nbsp; George.</div><br><blockquote type="cite"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><div><br></div><div>Anyway, that was the thinking at the meeting last June.</div><div><br></div><div><br><div><div>On Oct 9, 2013, at 1:40 AM, George Bosilca &lt;<a href="mailto:bosilca@icl.utk.edu">bosilca@icl.utk.edu</a>&gt; wrote:</div><br class="Apple-interchange-newline"><blockquote type="cite"><meta http-equiv="Content-Type" content="text/html charset=windows-1252"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">My concern is that increasing the number of interfaces will not make the code thread safe, as in most cases thread safety is not only a matter of using a _mt version of the basic class object but a matter of a careful manipulation of higher level concepts.<div><br></div><div>We can hardly use the lack of the _MT function as a reason for not having thread safety in the code. We did have the thread safety a while back without the support of _MT version of all the basic classes.&nbsp;</div><div><br></div><div>So I really wonder what is the rationale behind such an intrusive change of the codebase?</div><div><br></div><div>&nbsp; George.</div><div><br><div><div>On Oct 8, 2013, at 18:14 , Ralph Castain &lt;<a href="mailto:rhc@open-mpi.org">rhc@open-mpi.org</a>&gt; wrote:</div><br class="Apple-interchange-newline"><blockquote type="cite"><meta http-equiv="Content-Type" content="text/html charset=windows-1252"><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">Hi folks<div><br></div><div>This was one item from the last devel meeting that can be done independent of other things:</div><div><br></div><div><span class="Apple-tab-span" style="white-space:pre">		</span>• resolution: all opal and orte (and possibly ompi) classes need to&nbsp;have a thread safe and thread-free interface<br><div><span class="Apple-tab-span" style="white-space:pre">			</span>• _st&nbsp;suffix: single thread (i.e., not thread safe variant)<br></div><div><span class="Apple-tab-span" style="white-space:pre">			</span>• _mt&nbsp;suffix: multi thread (i.e., thread safe variant)<br><div><span class="Apple-tab-span" style="white-space:pre">				</span>• for functions that have both st/mt, they will *both* have suffixes<br></div><div><span class="Apple-tab-span" style="white-space:pre">				</span>• other functions (that do not have st/mt versions) will be naked names<br></div></div><div><span class="Apple-tab-span" style="white-space:pre">			</span>• need to rename all classes that have locking enabled already&nbsp;(e.g., opal_free_list)<br></div><div><span class="Apple-tab-span" style="white-space:pre">			</span>• so today, we go rename all the functions (e.g., opal_free_list&nbsp;functions get&nbsp;_mt&nbsp;suffix) throughout the code base<br></div><div><span class="Apple-tab-span" style="white-space:pre">			</span>• as someone needs the&nbsp;_st&nbsp;version, they go create it and&nbsp;use it as they want to<br></div><div><span class="Apple-tab-span" style="white-space:pre">			</span>• Ralph will do the orte classes<br></div><div><span class="Apple-tab-span" style="white-space:pre">			</span>• Aurelien will do this for the ompi classes<br></div></div><div><h3 id="Sidenotes"></h3><div><br></div></div><div>I believe some of these have been done - I will take care of the ORTE classes this week, so consider this a "heads up" for that change.</div><div>Ralph</div><div><br></div></div>_______________________________________________<br>devel mailing list<br><a href="mailto:devel@open-mpi.org">devel@open-mpi.org</a><br><a href="http://www.open-mpi.org/mailman/listinfo.cgi/devel">http://www.open-mpi.org/mailman/listinfo.cgi/devel</a></blockquote></div><br></div></div>_______________________________________________<br>devel mailing list<br><a href="mailto:devel@open-mpi.org">devel@open-mpi.org</a><br><a href="http://www.open-mpi.org/mailman/listinfo.cgi/devel">http://www.open-mpi.org/mailman/listinfo.cgi/devel</a></blockquote></div><br></div></div>_______________________________________________<br>devel mailing list<br><a href="mailto:devel@open-mpi.org">devel@open-mpi.org</a><br><a href="http://www.open-mpi.org/mailman/listinfo.cgi/devel">http://www.open-mpi.org/mailman/listinfo.cgi/devel</a></blockquote></div><br></div>_______________________________________________<br>devel mailing list<br><a href="mailto:devel@open-mpi.org">devel@open-mpi.org</a><br><a href="http://www.open-mpi.org/mailman/listinfo.cgi/devel">http://www.open-mpi.org/mailman/listinfo.cgi/devel</a></blockquote></div><br></div>_______________________________________________<br>devel mailing list<br><a href="mailto:devel@open-mpi.org">devel@open-mpi.org</a><br>http://www.open-mpi.org/mailman/listinfo.cgi/devel</blockquote></div><br></body></html>
