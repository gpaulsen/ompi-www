<div dir="ltr"><div class="gmail_extra"><div class="gmail_quote"><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div style="word-wrap:break-word"><div>It would make sense, though I guess I always thought that was part of what happened in OBJ_CLASS_INSTANCE - guess I was wrong. My thinking was that DEREGISTER would be the counter to INSTANCE, and I do want to keep this from getting even more clunky - so maybe renaming INSTANCE to be REGISTER and completing the initialization inside it would be the way to go. Or renaming DEREGISTER to something more obviously the counter to INSTANCE?</div>
<div><br></div></div></blockquote><div><br></div><div>just so we are clear :</div><div><br></div><div>on one hand OBJ_CLASS_INSTANCE is a macro that must be invoked &quot;outside&quot; of a function :</div><div>It *statically* initializes a struct.</div>
<div><br></div><div>on the other hand, OBJ_CLASS_DEREGISTER is a macro that must be invoked inside a function.</div><div><br></div><div>using OBJ_CLASS_REGISTER is not only about renaming, it also requires to move all these invokations into functions.</div>
<div><br></div><div>my idea of having both OBJ_CLASS_INSTANCE and OBJ_CLASS_REGISTER is :</div><div>- we do not need to move OBJ_CLASS_INSTANCE into functions</div><div>- we can have two behaviours depending on OPAL_ENABLE_DEBUG :</div>
<div>OBJ_CLASS_REGISTER would simply do nothing if OPAL_ENABLE_DEBUG is zero (and opal_class_initialize would still be invoked in opal_obj_new). that could also be a bit faster than having only one OBJ_CLASS_REGISTER macro in optimized mode.</div>
<div><br></div><div>that being said, i am also fine with simplifying this, remove OBJ_CLASS_INSTANCE and use OBJ_CLASS_REGISTER and OBJ_CLASS_DEREGISTER</div><div><br></div><div><br></div><div>about the bug you hit, did you already solve it and how ?</div>
<div>a trivial workaround is not to dlclose the dynamic library (ok, that&#39;s cheating ...)</div><div>a simple workaround (if it is even doable) is to declare the class &quot;somewhere else&quot; so the (library containing the) class struct is not dlclose&#39;d before it is invoked (ok, that&#39;s ugly ...).</div>
<div><br></div><div>what i wrote earlier was misleading :</div><div>OBJ_CLASS_INSTANCE(class);</div><div>foo = OBJ_NEW(class);</div><div>then</div><div>opal_class_t class_class = {...};</div><div>foo-&gt;super.obj_class = &amp;class_class;</div>
<div><br></div><div>class_class is no more accessible when the OBJ_RELEASE is called since the library was dlclose&#39;d, so you do not even get a change to invoke the destructor ...</div><div>Â </div><div>a possible workaround could be to malloc a copy of class_class, have foo-&gt;super.obj_class point to it after each OBJ_NEW, and finally have its cls_destruct_array point to NULL when closing the framework/component.</div>
<div>(of course that causes a leak ...)</div><div><br></div><div>Cheers,</div><div><br></div><div>Gilles</div></div></div></div>

