<html><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; "><br><div><div>On 2-apr-10, at 13:14, Brice Goglin wrote:</div><br class="Apple-interchange-newline"><blockquote type="cite"><div>Fawzi Mohamed wrote:<br><blockquote type="cite">Building tools<br></blockquote><blockquote type="cite">rather new autoconf/automake/libtool are requested<br></blockquote><blockquote type="cite">I had to install them even on new clusters, nothing terrible, but I<br></blockquote><blockquote type="cite">just noted it...<br></blockquote><br>Yes, but there are nightly snapshots in<br><a href="http://www.open-mpi.org/software/hwloc/nightly/trunk/">http://www.open-mpi.org/software/hwloc/nightly/trunk/</a><br>You don't need autotools there.<br></div></blockquote><div><br></div>ok good to know, but I like svn... especially before the release...</div><div><br><blockquote type="cite"><div><blockquote type="cite">pages info, before there were free pages, now I suppose that the<br></blockquote><blockquote type="cite">page_types array might contain several pages, and so also the free<br></blockquote><blockquote type="cite">pages, any place to get information about the meaning of the various<br></blockquote><blockquote type="cite">page types? or is it still possible to get the free pages?<br></blockquote><br>We only had the number of free pages for huge pages if I remember<br>correctly. Now we're supposed to have only the total number of pages,<br>huge or not, not the number of free ones. But Linux only reports the<br>number of free huge pages so that's what we actually show there.<br><br>The different page types are just (one page size + how many such pages<br>are available at boot). There's nothing specific about each page type<br>except its page size. So when you have hugepages, you have a page type<br>for 4kB pages, and another one for 2MB pages for instance. This was<br>designed to better cope with multiple page size since most modern<br>architectures support multiple huge page sizes. And some OS are already<br>able to use them. So in the end some machine may show 4 page type slots,<br>one for 4kB, one for 64kB, one for 2MB, one for 1GB, ...<br></div></blockquote><div><br></div>ok makes sense, so that one-off scan is enough, a pity I liked having free huge_pages (not that I really used that), and yes I realize that even then it was not updated.</div><div><br><blockquote type="cite"><div><font class="Apple-style-span" color="#006312">[...]<br></font><blockquote type="cite">C bitfields are used, normally they are avoided because they are slow<br></blockquote><blockquote type="cite">(a compiler can bit or at compile time the constants and check/set<br></blockquote><blockquote type="cite">several at once.<br></blockquote><blockquote type="cite">Speed is not a concern here, but in any case I am wrapping to D that<br></blockquote><blockquote type="cite">does not support bitfields directly, so I used flags, I was just<br></blockquote><blockquote type="cite">wondering why bitfields were used...<br></blockquote><br>Which bitfields are you concerned about?<br></div></blockquote><div><br></div>well not really concerned, but I was talking about</div><div>hw_topology_support where instead of enum with flags a C bitfield struct is used...</div><div><br></div><div><br><blockquote type="cite"><div>Topology flags shouldn't be performance critical. Binding could be a bit<br>more performance critical, but I suspect that even a slow compiler will<br>generate code that's faster at parsing binding bitfields than the actual<br>binding system call.<br><br><blockquote type="cite">HWLOC_OBJ_SYSTEM seems on the way out<br></blockquote><blockquote type="cite">I treated it just as a MACHINE anyway, but I wonder, as the constant<br></blockquote><blockquote type="cite">is still there, does it have special attributes?, has it machine<br></blockquote><blockquote type="cite">attributes? the documentation could be clearer...<br></blockquote><br>This behavior changes completely in 1.0. SYSTEM will only be used when<br>assembling multiple independent machines, for instance with kerrighed,<br>or maybe for network topologies. MACHINE is always used now, and SYSTEM<br>should be very rare.<br><br>SYSTEM doesn't have any specific attribute, but it may have the<br>obj-&gt;name field set to != NULL so as to tell you what kind of<br>multiple-machine-assembly we're talking about.<br></div></blockquote><div><br></div>ok now it is clear</div><div><br><blockquote type="cite"><div>We're slowly trying to move out of the type-specific attributes as much<br>as possible. In 1.1, we'll probably have an array of strings to contain<br>custom attributes such as machine name, model, system, ...<br></div></blockquote><div><br></div><div>good, yes one has always to strike a balance between uniformity/speed, and flexibility, for things like names,... a generic attribute system is probably the best choice</div><br><blockquote type="cite"><div><blockquote type="cite">I am looking forward to 1.0 ...<br></blockquote><br>Me too, it's been way too long already :) We moved some features out of<br>1.0 back to 1.1 (memory binding for instance) because we wanted 1.0<br>early. We would probably have had time top implement them twice in the<br>meantime ;)<br></div></blockquote><div><br></div>still it is the best lib that I found to detect the structure of a machine and then bind to it in a cross platform way.</div><div><br></div><div>I would take advantage more info about the possible numa node connectivity (to know where to steal tasks), but I don't have access to machines that would really take advantage of that, and probably even then using the HW structure as topology would not bad.</div><div><br><blockquote type="cite"><div>Could you point me at some precise documentation that is unclear or<br>missing so that I try to improve them before the 1.0 final release arrives?<br></div></blockquote><div><br></div>I will try to look at what can be improved later...</div><div><br><blockquote type="cite"><div>thanks,<br></div></blockquote><div><br></div>no thank you for the quick and extensive answers...</div><div><br></div><div>ciao</div><div>Fawzi</div></body></html>
