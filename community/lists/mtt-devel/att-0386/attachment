<div dir="ltr"><br><br>
<div class="gmail_quote">On Tue, Apr 14, 2009 at 11:50 PM, Ethan Mallove <span dir="ltr">&lt;<a href="mailto:ethan.mallove@sun.com">ethan.mallove@sun.com</a>&gt;</span> wrote:<br>
<blockquote class="gmail_quote" style="PADDING-LEFT: 1ex; MARGIN: 0px 0px 0px 0.8ex; BORDER-LEFT: #ccc 1px solid">
<div>
<div></div>
<div class="h5">On Tue, Apr/14/2009 09:27:14PM, Mike Dubman wrote:<br>&gt;    On Tue, Apr 14, 2009 at 5:04 PM, Jeff Squyres &lt;<a href="mailto:jsquyres@cisco.com">jsquyres@cisco.com</a>&gt; wrote:<br>&gt;<br>&gt;      On Apr 13, 2009, at 2:08 PM, Mike Dubman wrote:<br>
&gt;<br>&gt;        Hello Ethan,<br>&gt;<br>&gt;      Sorry for joining the discussion late... I was on travel last week and<br>&gt;      that always makes me waaay behind on my INBOX. *:-(<br>&gt;<br>&gt;        On Mon, Apr 13, 2009 at 5:44 PM, Ethan Mallove &lt;<a href="mailto:ethan.mallove@sun.com">ethan.mallove@sun.com</a>&gt;<br>
&gt;        wrote:<br>&gt;<br>&gt;        Will this translate to something like<br>&gt;        lib/MTT/Reporter/GoogleDatabase.pm? *If we are to move away from the<br>&gt;        current MTT Postgres database, we want to be able to submit results to<br>
&gt;        both the current MTT database and the new Google database during the<br>&gt;        transition period. Having a GoogleDatabase.pm would make this easier.<br>&gt;<br>&gt;        I think we should keep both storage options: current postgress and<br>
&gt;        datastore. The mtt changes will be minor to support datastore.<br>&gt;        Due that fact that google appengine API (as well as datastore API) can<br>&gt;        be python or java only, we will create external scripts to manipulate<br>
&gt;        datastore objects:<br>&gt;<br>&gt;      Ah, good point (python/java not perl). *But I think that<br>&gt;      lib/MTT/Reporter/GoogleDataStore.pm could still be a good thing -- we<br>&gt;      have invested a lot of time/effort into getting our particular mtt<br>
&gt;      clients setup just the way we want them, setting up INI files,<br>&gt;      submitting to batch schedulers, etc.<br>&gt;<br>&gt;      A GoogleDataStore.pm reporter could well fork/exec a python/java<br>&gt;      executable to do the actual communication/storing of the data, right...?<br>
&gt;      *More below.<br>&gt;<br>&gt;    completely agree, once we have external python/java/cobol scripts to<br>&gt;    manipulate GDS objects, we should wrap it by perl and call from MTT in<br>&gt;    same way like it works today for submitting to the postgress.<br>
&gt;<br>&gt;    *<br>&gt;<br>&gt;        The mtt will dump test results in xml format. Then, we provide two<br>&gt;        python (or java?) scripts:<br>&gt;<br>&gt;        mtt-results-submit-to-datastore.py - script will be called at the end<br>
&gt;        of mtt run and will read xml files, create objects and save to<br>&gt;        datastore<br>&gt;<br>&gt;      Could be pretty easy to have a Reporter/GDS.pm (I keep making that<br>&gt;      filename shorter, don&#39;t I? :-) ) that simply invokes the<br>
&gt;      <a href="http://mtt-result-submit-to-datastore.pt/" target="_blank">mtt-result-submit-to-datastore.pt</a> script on the xml that it dumped for<br>&gt;      that particular test.<br>&gt;<br>&gt;      Specifically: I do like having partial results submitted while my MTT<br>
&gt;      tests are running. *Cisco&#39;s testing cycle is about 24 hours, but groups<br>&gt;      of tests are finishing all the time, so it&#39;s good to see those results<br>&gt;      without having to wait the full 24 hours before anything shows up. *I<br>
&gt;      guess that&#39;s my only comment on the idea of having a script that<br>&gt;      traverses the MTT scratch to find / submit everything -- I&#39;d prefer if<br>&gt;      we kept the same Reporter idea and used an underlying .py script to<br>
&gt;      submit results as they become ready.<br>&gt;<br>&gt;      Is this do-able?<br>&gt;<br>&gt;    sounds good, we should introduce some guid (like pid) for mtt session,<br>&gt;    where all mtt results generated by this session will be referring to this<br>
&gt;    guid.* Later we use this guid to submit partial results as they become<br>&gt;    ready and connect it to the appropriate mtt session object (see models.py)<br>&gt;<br>&gt;        mtt-results-query.py - sample script to query datastore and generate<br>
&gt;        some simple visual/tabular reports. It will serve as tutorial for<br>&gt;        howto access mtt data from scripts for reporting.<br>&gt;<br>&gt;        Later, we add another script to replace php web frontend. It will be<br>
&gt;        hosted on google appengine machines and will provide web viewer for<br>&gt;        mtt results. (same way like index.php does today)<br>&gt;<br>&gt;      Sounds good.<br>&gt;<br>&gt;        &gt; * * *b. mtt_save_to_db.py - script which will go over mtt scratch<br>
&gt;        dir, find<br>&gt;        &gt; * * *all xml files generated for every mtt phase, parse it and save<br>&gt;        to<br>&gt;        &gt; * * *datastore, preserving test results relations,i.e. all test<br>&gt;        results will<br>
&gt;        &gt; * * *be grouped by mtt general info: mpi version, name, date, ....<br>&gt;        &gt;<br>&gt;        &gt; * * *c. same script can scan, parse and save from xml files<br>&gt;        generated by<br>&gt;        &gt; * * *wrapper scripts for non mtt based executions (fluent, ..)<br>
&gt;<br>&gt;        I&#39;m confused here. *Can&#39;t MTT be outfitted to report results of a<br>&gt;        Fluent run?<br>&gt;<br>&gt;        I think we can enhance mtt to be not only mpi testing platform, but<br>&gt;        also to serve as mpi benchmarking platform. We can use datastore to<br>
&gt;        keep mpi-based benchmarking results in the same manner like mtt does<br>&gt;        for testing results. (no changes to mtt required for that, it is just<br>&gt;        a side effect of using datastore to keep data of any type)<br>
&gt;<br>&gt;      I think that Ethan was asking was: can&#39;t MTT run Fluent and then use the<br>&gt;      normal Reporter mechanism to report the results into whatever back-end<br>&gt;      data store we have? *(postgres or GDS)<br>
&gt;<br>&gt;    ahhh, okie, i see.<br>&gt;<br>&gt;    Correct me if Im wrong, the current mtt implementation allows following<br>&gt;    way of executing mpi test:<br>&gt;    /path/to/mpirun &lt;mpirun options&gt; &lt;test&gt;<br>
&gt;<br>&gt;    Many mpi based applications have embedded MPI libraries and non-standard<br>&gt;    way to start it, one should set env variable to point to desired mpi<br>&gt;    installation or pass it as cmd line argument, for example:<br>
&gt;<br>&gt;    for fluent:<br>&gt;<br>&gt;    export OPENMPI_ROOT=/path/to/openmpi<br>&gt;    fluent &lt;cmd line args&gt;<br>&gt;<br><br></div></div>We&#39;d probably want a special &quot;MPI details&quot; INI section to run Fluent,<br>
e.g.,<br><br> [MPI Details: Fluent]<br> exec = fluent @fluent_args@<br>
<div class="im"> ...<br><br>&gt;    for pamcrash:<br>&gt;    pamworld -np 2 -mpidir=/path/to/openmpi/dir ....<br><br></div>Ditto for pamcrash.<br>
<div class="im"><br>&gt;<br>&gt;    Im not sure if it is possible to express that execution semantic in mtt<br>&gt;    ini file. Please suggest.<br>&gt;    So far, it seems that such executions can be handled externally from mtt<br>
&gt;    but using same object model.<br><br></div>MTT supports the following INI parameters:<br><br>  * setenv<br>  * prepend_path<br>  * env_module<br>  * env_importer<br>
<div>
<div></div>
<div class="h5"></div></div></blockquote>
<div> </div>
<div> </div>
<div>aha, great</div>
<div> </div>
<div> </div>
<blockquote class="gmail_quote" style="PADDING-LEFT: 1ex; MARGIN: 0px 0px 0px 0.8ex; BORDER-LEFT: #ccc 1px solid">
<div>
<div class="h5"><span id=""></span><br>&gt;<br>&gt;    *<br>&gt;<br>&gt;      I can see the value of both sides -- a) using the MTT client as the<br>&gt;      gateway to *all* data storage, or b) making MTT but one (possibly of<br>
&gt;      many) tools that can write into the GDS. *a) certainly is more<br>&gt;      attractive towards having a common data format back in GDS such that a<br>&gt;      single web tool is capable of reporting from the data and being able to<br>
&gt;      make conherent sense out of the data (vs. 3rd party tools that put data<br>&gt;      back in GDS that may not be in exactly the same format / layout and<br>&gt;      therefore our web reporter may not be able to make sense out of the data<br>
&gt;      and report on it).<br>&gt;<br>&gt;      I think that having a Reporter/GDS.pm that system()&#39;s the back-end<br>&gt;      python script gives the best of both worlds -- the MTT client can<br>&gt;      [continue to] submit results in the normal way, but there&#39;s also a<br>
&gt;      standalone script that can submit results from external tool runs (e.g.,<br>&gt;      manually running Fluent, parsing the results, and submitting to our<br>&gt;      GDS). *And hopefully the back-end python script will enforce a specific<br>
&gt;      structure to the data that is submitted so that all tools -- MTT and any<br>&gt;      3rd party tools -- adhere to the same format and the reporter can<br>&gt;      therefore report on it coherently.<br>&gt;<br>
&gt;    agree. (a) is a preferred form. (b) can be used for tools that cannot be<br>&gt;    called from mtt.<br>&gt;    *<br>&gt;<br>&gt;      For the attachment...<br>&gt;<br>&gt;      I can &quot;sorta read&quot; python, but I&#39;m not familiar with its intricacies and<br>
&gt;      its internal APIs.<br>&gt;<br>&gt;      - models.py: looks good. *I don&#39;t know if *all* the fields we have are<br>&gt;      listed here; it looks fairly short to me. *Did you attempt to include<br>&gt;      all of the fields we submit through the various phases in Reporter are<br>
&gt;      there, or did you intentionally leave some out? *(I honestly haven&#39;t<br>&gt;      checked; it just &quot;feels short&quot; to me compared to our SQL schema).<br>&gt;<br>&gt;    I listed only some of the fields in every object representing specific<br>
&gt;    test result source (called phase in mtt language). This is because every<br>&gt;    test result source object is derived from python provided db.Expando<br>&gt;    class. This gives us great flexibility, like adding dynamic attributes for<br>
&gt;    every objects, for example:<br>&gt;<br>&gt;    obj = new MttBuildPhaseResult()<br>&gt;    obj.my_favorite_dynamic_key = &quot;hello&quot;<br>&gt;    obj.my_another_dynamic_key = 7<br>&gt;<br>&gt;    So, we can have all phase attributes in the phase object without defining<br>
&gt;    it in the *sql schema way*. Also we can query object model by these<br>&gt;    dynamic keys.<br>&gt;<br></div></div>&gt;    *<br><br>It looks like model.py doesn&#39;t have the daisy chain of inheritance<br>that the SQL schema requires.<br>
<br>   <a href="http://svn.open-mpi.org/trac/mtt/browser/trunk/docs/sql-schema-v3.pdf" target="_blank">http://svn.open-mpi.org/trac/mtt/browser/trunk/docs/sql-schema-v3.pdf</a><br><br>Shouldn&#39;t RunTestPhase back-reference the MPIInstallPhase,<br>
TestBuildPhase, and TestSession phase? E.g., we might need to look at<br>the configure arguments that are keyed to a given test run.<br><br>-Ethan<br>
<div>
<div></div>
<div class="h5"></div></div></blockquote>
<div> </div>
<div> </div>
<blockquote class="gmail_quote" style="PADDING-LEFT: 1ex; MARGIN: 0px 0px 0px 0.8ex; BORDER-LEFT: #ccc 1px solid">
<div>
<div class="h5"><span id=""></span>you are right, will add it to the model. Every phase object will have a reference to other relevant phase objects, i.e.</div></div></blockquote>
<div> </div>
<div>RunTestPhase -&gt; MPIInstallPhase</div>
<div>RunTestPhase -&gt; TestBuildPhase</div>
<div>*Phase -&gt; TestSession</div>
<div> </div>
<div> </div>
<div>sounds good? Will go over sql schema and try to track additional relations.</div>
<div> </div>
<blockquote class="gmail_quote" style="PADDING-LEFT: 1ex; MARGIN: 0px 0px 0px 0.8ex; BORDER-LEFT: #ccc 1px solid">
<div>
<div class="h5"><span id=""></span><br><br>&gt;<br>&gt;      --&gt; meta question: is it in the zen of GDS to not have too many index<br>&gt;      fields like you would in SQL? *I.e., if you want to do an operation on<br>
&gt;      GDS that you<br>&gt;<br>&gt;    as far as it seems now, gds creates indexes automatically and also<br>&gt;    provides API to define indexes manually.<br>&gt;<br>&gt;      would typically use an SQL index field for, is the idea that you would<br>
&gt;      do a map/reduce to select the data instead of an index field?<br>&gt;<br>&gt;    yep. seems correct.<br>&gt;<br>&gt;    *<br>&gt;<br>&gt;      - start_datastore.sh: hmm. *This script seems to imply that the<br>&gt;      datastore is *local*! *Don&#39;t we have to HTTP submit the results to<br>
&gt;      Google? *More specifically: what is dev_appserver.py? *Is that,<br>&gt;      perchance, just a local proxy agent that will end up submitting our data<br>&gt;      to $datastore_path, which actually resides at Google? *Do we have to use<br>
&gt;      a specific google username/URL to submit (and query) results?<br>&gt;<br>&gt;    You need to download google`s sdk (dev_appserver.py is a part of it). In<br>&gt;    order to develop for gds you* run your code inside sdk locally, and when<br>
&gt;    feel comfortable with it - you upload it to the google cluster. In order<br>&gt;    to run attached example, you need to download sdk, put it in the following<br>&gt;    dir hierarchy:<br>&gt;<br>&gt;    somedir/sdk<br>
&gt;    somedir/vbench-dev<br>&gt;<br>&gt;    and run start_datastore.sh, which will run local instance of GDS on your<br>&gt;    machine.Then in another shell you need to run vbech-dev.py, which<br>&gt;    simulates mtt client accessing GDS, storing some objects in according to<br>
&gt;    proposed models and then running some sql-like quires to fetch and<br>&gt;    manipulate results.<br>&gt;<br>&gt;    see<br>&gt;    <a href="http://code.google.com/appengine/docs/python/gettingstarted/devenvironment.html" target="_blank">http://code.google.com/appengine/docs/python/gettingstarted/devenvironment.html</a><br>
&gt;<br>&gt;      - there&#39;s no comments in vbench-dev.py -- can you explain what&#39;s going<br>&gt;      on in there? *Can you explain how we would use these scripts?<br>&gt;<br>&gt;    This is a mtt simulator, it implements google appengine API to receive<br>
&gt;    HTTP requests and call appropriate callbacks. (there is a map of specific<br>&gt;    urls to callbacks).<br>&gt;<br>&gt;    The main callback (which intercepts http GET requests to specific URL)<br>&gt;    runs the test code which creates objects defined in models.py, groups many<br>
&gt;    test results into MTTSession and they run some queries to access<br>&gt;    previously created objects.<br>&gt;<br>&gt;    The real mtt client will use URL pointing to MTT python code running at<br>&gt;    google`s cluster, and use near same code to create/query/manipulate<br>
&gt;    objects defined in models.py.<br>&gt;<br>&gt;    *<br>&gt;<br>&gt;      - it *looks* like these scripts are for storing data out in the GDS.<br>&gt;      *Have you looked at the querying side? *Do we know that storing data in<br>
&gt;      the form you listed in models.py are easily retrievable in the ways that<br>&gt;      we want? *E.g., can you mock up queries that resemble the queries we<br>&gt;      currently have in our web-based query system today, just to show that<br>
&gt;      storing the data in this way will actually allow us to do the kinds of<br>&gt;      queries that we want to do?<br>&gt;<br>&gt;    I think vbench-dev.py shows some querying capabilities for stored objects,<br>&gt;    there are many ways to query objects by object CLASS and Attributes.<br>
&gt;    see many examples here:<br>&gt;<br>&gt;    see<br>&gt;    <a href="http://code.google.com/appengine/docs/python/gettingstarted/usingdatastore.html" target="_blank">http://code.google.com/appengine/docs/python/gettingstarted/usingdatastore.html</a><br>
&gt;    for more querying examples we can use.<br>&gt;<br>&gt;    *<br>&gt;<br>&gt;      In short: I think I&#39;m missing much of the back-story / rationale of how<br>&gt;      the scripts in your tarball work / are to be used.<br>
&gt;<br>&gt;      BTW -- if it&#39;s useful to have a teleconference about this kind of stuff,<br>&gt;      I can host a WebEx meeting. *WebEx has local dialins around the world,<br>&gt;      including Israel...<br>&gt;<br>
&gt;    sure, what about next week?<br>&gt;    *<br>&gt;<br>&gt;    regards<br>&gt;<br>&gt;    Mike<br>&gt;<br>&gt;      --<br>&gt;      Jeff Squyres<br>&gt;      Cisco Systems<br>&gt;<br></div></div>&gt; References<br>&gt;<br>
&gt;    Visible links<br>&gt;    . mailto:<a href="mailto:jsquyres@cisco.com">jsquyres@cisco.com</a><br>&gt;    . mailto:<a href="mailto:ethan.mallove@sun.com">ethan.mallove@sun.com</a><br>&gt;    . <a href="http://submit-to-datastore.pt/" target="_blank">http://submit-to-datastore.pt/</a><br>

<div class="im">&gt;    . <a href="http://code.google.com/appengine/docs/python/gettingstarted/devenvironment.html" target="_blank">http://code.google.com/appengine/docs/python/gettingstarted/devenvironment.html</a><br></div>

<div class="im">&gt;    . <a href="http://code.google.com/appengine/docs/python/gettingstarted/usingdatastore.html" target="_blank">http://code.google.com/appengine/docs/python/gettingstarted/usingdatastore.html</a><br><br>
</div>
<div>
<div></div>
<div class="h5">&gt; _______________________________________________<br>&gt; mtt-devel mailing list<br>&gt; <a href="mailto:mtt-devel@open-mpi.org">mtt-devel@open-mpi.org</a><br>&gt; <a href="http://www.open-mpi.org/mailman/listinfo.cgi/mtt-devel" target="_blank">http://www.open-mpi.org/mailman/listinfo.cgi/mtt-devel</a><br>
<br>_______________________________________________<br>mtt-devel mailing list<br><a href="mailto:mtt-devel@open-mpi.org">mtt-devel@open-mpi.org</a><br><a href="http://www.open-mpi.org/mailman/listinfo.cgi/mtt-devel" target="_blank">http://www.open-mpi.org/mailman/listinfo.cgi/mtt-devel</a><br>
</div></div></blockquote></div><br></div>

