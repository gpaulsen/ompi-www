<div dir="ltr"><br><br><div class="gmail_quote">On Mon, Feb 25, 2013 at 6:24 PM, Jeff Squyres (jsquyres) <span dir="ltr">&lt;<a href="mailto:jsquyres@cisco.com" target="_blank">jsquyres@cisco.com</a>&gt;</span> wrote:<br><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
&gt;Looking at the code, you&#39;re checking for zombie status before MTT kills the proc.  Am I reading that right?<br></blockquote><div>I don`t think the order matters, if process is not Zombie yet and about to be killed by MTT later - it is a good flow.</div>
<div>If process is already Zombie - mtt will not be able to kill it anyway and and can stop waiting and switch to the new task.</div><div> </div><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
&gt;If so, then it could well be that the process has exited but not yet been reaped (because _kill_proc() hasn&#39;t been invoked yet).  If this is the case, is the real cause of the problem that &gt;the OUTread and ERRread aren&#39;t being closed when the child process exits, and therefore we keep looping looking for new output from them?<br>
</blockquote><div>yep, sounds like it can be the cause, need to look into this code.</div><div><br></div><div><br></div></div></div>

