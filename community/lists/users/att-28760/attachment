<div dir="ltr"><div><div><div><div><div><div><div><div>Hello all<br><br></div>I downloaded some code samples from here:<br><br><a href="https://github.com/parallel-forall/code-samples/">https://github.com/parallel-forall/code-samples/</a><br><br></div>and tried to build the subdirectory<br><br>posts/cuda-aware-mpi-example/src<br><br></div>in my CentOS 7 machine.<br><br></div>I had to make several changes to the Makefile before it would build. The modified Makefile is attached (the make targets I am talking about are the 3rd and 4th from the bottom). Most of the modifications can be explained as possible platform specific variations (such as path differences betwen Ubuntu and CentOS), except the following:<br><br></div>I had to use a C++ linker (mpic++) to link in the object files that were produced with C host compiler (mpicc) and CUDA compiler (nvcc). If I did not do this, (i.e. I stuck to mpicc for linking), I got the following link error:<br><br>mpicc -L/usr/local/cuda/lib64 -lcudart -lm -o ../bin/jacobi_cuda_normal_mpi jacobi.o input.o host.o device.o  cuda_normal_mpi.o  <br>device.o: In function `__static_initialization_and_destruction_0(int, int)&#39;:<br>tmpxft_00004651_00000000-4_Device.cudafe1.cpp:(.text+0xd1e): undefined reference to `std::ios_base::Init::Init()&#39;<br>tmpxft_00004651_00000000-4_Device.cudafe1.cpp:(.text+0xd2d): undefined reference to `std::ios_base::Init::~Init()&#39;<br>collect2: error: ld returned 1 exit status<br><br></div>Can someone please explain why would I need a C++ linker for object files that were generated using C compiler? Note that if I use mpic++ both for compiling and linking, there are no errors either.<br><br></div>Thanks in advance<br></div>Durga<br><div><div><div><div><div><div><div><div><div><br clear="all"><div><div class="gmail_signature">Life is complex. It has real and imaginary parts.</div></div>
</div></div></div></div></div></div></div></div></div></div>

