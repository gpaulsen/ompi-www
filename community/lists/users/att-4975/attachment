Hi,<br><br>I&#39;ve been working on MPI piggyback technique as a part of my PhD work.<br><p class="MsoNormal" style=""><span style="font-family: arial,sans-serif;" lang="EN-GB">Although
MPI does not provide a native support, t</span><span lang="EN-US"><span style="font-family: arial,sans-serif;">here are
several different solutions to transmit piggyback data over every MPI
communication</span><span style="font-family: arial,sans-serif;">.
You may find a brief overview in papers [1, 2]. This includes copying the original
message and the extra data to a bigger buffer, sending additional
message or </span>changing the sendtype to a dynamically created wrapper datatype that
contains a pointer to the original data and the piggyback data. I have tried all mechanisms and they work, but considering the overhead, there is no &quot;the best&quot; technique that outperforms
the others in all scenarios. Jeff Squyres had interesting comments on this subject before (in this mailing list).<br></span></p><p class="MsoNormal" style=""><span lang="EN-US">Finally after some benchmarking, I have implemented <i style="">a
</i>hybrid technique that combines existing mechanisms. </span><span lang="EN-US">For small,
point-to-point messages datatype wrapping seems to be the less intrusive, at least considering OpenMPI implementation of derived datatypes. For large, point-to-point
messages, experiments confirmed that sending an additional message is
much cheaper than wrapping (and besides the intrusion is small as we are already sending a large message). Moreover, the implementation may interleave the original send with an asynchronous send of piggyback data. This
optimization partially hides the latency of additional send and lowers overall
intrusion. The&nbsp; same criteria can be applied for collective operations, except barrier
and reduce operations. As the former does not transmit any data and the latter
transforms the data, the only solution is to send additional
messages. <br></span></p><p class="MsoNormal" style="">There is a penalty of course. Especially for collective operations with very small messages the intrusion may reach 15% and that&#39;s a lot. It than decreases down to 0.1% for bigger messages, but anyway it&#39;s still there. I don&#39;t know what are your requirements/expectations for that issue. The only work that reported lower overheads is [3] but they added native piggyback support by changing underlying MPI implementation. <br>
</p><p class="MsoNormal" style="">I think the best possible option is to add piggyback support for MPI as a part of the standard. A growing number of runtime tools use this functionality for multiple reasons and certainly PMPI  itself is not enough.<br>
</p>References of interest:<br><ul><li>

<p class="reference" style="margin-left: 18pt; text-indent: -18pt;"><span style="font-family: &quot;Times New Roman&quot;;" lang="EN-US"><span style=""></span></span><span style="font-family: &quot;Times New Roman&quot;;" lang="EN-US">[1] Shende, S., Malony, A., Morris, A., Wolf, F. <span style="">"Performance Profiling Overhead Compensation
for MPI Programs"</span>. <span style="">12th
EuroPVM-MPI Conference</span>, LNCS, </span><span lang="EN-US">vol. 3666, pp.
359-367,</span><span style="font-family: &quot;Times New Roman&quot;;" lang="EN-US"> 2005.&nbsp; They review various techniques and&nbsp; come up with datatype wrapping.</span></p>

<p class="reference" style="margin-left: 18pt; text-indent: -18pt;"><span style="font-family: &quot;Times New Roman&quot;;" lang="EN-US"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"> 
</span></span></span><span style="font-family: &quot;Times New Roman&quot;;" lang="EN-US"></span></p></li><li><p class="reference" style="margin-left: 18pt; text-indent: -18pt;"><span style="font-family: &quot;Times New Roman&quot;;" lang="EN-US">[2] Schulz, M., "Extracting Critical Path Graphs
from MPI Applications". Cluster Computing 2005, IEEE International, pp. 1-10,
September 2005. They use datatype wrapping.<br></span></p></li><li><span style="font-family: &quot;Times New Roman&quot;;" lang="EN-US">[3] Jeffrey Vetter, &quot;Dynamic Statistical Profiling of Communication Activity in Distributed Applications&quot;. They add support for piggyback at MPI implementation level and report very low overheads (no surprise).&nbsp; <br>
</span></li></ul>Regards,<br>Oleg Morajko<br><br><br><div class="gmail_quote">On Feb 1, 2008 5:08 PM, Aurélien Bouteiller &lt;<a href="mailto:bouteill@eecs.utk.edu">bouteill@eecs.utk.edu</a>&gt; wrote:<br><blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;">
I don&#39;t know of any work in that direction for now. Indeed, we plan to<br>eventually integrate at least causal message logging in the pml-v,<br>which also includes piggybacking. Therefore we are open for<br>collaboration with you on this matter. Please let us know :)<br>
<br>Aurelien<br><br><br><br>Le 1 févr. 08 à 09:51, Thomas Ropars a écrit :<br><div><div></div><div class="Wj3C7c"><br>&gt; Hi,<br>&gt;<br>&gt; I&#39;m currently working on optimistic message logging and I would like<br>&gt; to<br>
&gt; implement an optimistic message logging protocol in OpenMPI.<br>&gt; Optimistic<br>&gt; message logging protocols piggyback information about dependencies<br>&gt; between processes on the application messages to be able to find a<br>
&gt; consistent global state after a failure. That&#39;s why I&#39;m interested in<br>&gt; the problem of piggybacking information on MPI messages.<br>&gt;<br>&gt; Is there some works on this problem at the moment ?<br>&gt; Has anyone already implemented some mechanisms in OpenMPI to piggyback<br>
&gt; data on MPI messages?<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Thomas<br>&gt;<br>&gt; Oleg Morajko wrote:<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I&#39;m developing a causality chain tracking library and need a<br>&gt;&gt; mechanism<br>
&gt;&gt; to attach an extra data to every MPI message, so called piggyback<br>&gt;&gt; mechanism.<br>&gt;&gt;<br>&gt;&gt; As far as I know there are a few solutions to this problem from which<br>&gt;&gt; the two fundamental ones are the following:<br>
&gt;&gt;<br>&gt;&gt; &nbsp; &nbsp;* Dynamic datatype wrapping - if a user MPI_Send, let&#39;s say 1024<br>&gt;&gt; &nbsp; &nbsp; &nbsp;doubles, the wrapped send call implementation dynamically<br>&gt;&gt; &nbsp; &nbsp; &nbsp;creates a derived datatype that is a structure composed of a<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;pointer to 1024 doubles and extra fields to be piggybacked. The<br>&gt;&gt; &nbsp; &nbsp; &nbsp;datatype is constructed with absolute addresses to avoid copying<br>&gt;&gt; &nbsp; &nbsp; &nbsp;the original buffer. The receivers side creates the equivalent<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;datatype to receive the original data and extra data. The<br>&gt;&gt; &nbsp; &nbsp; &nbsp;performance of this solution depends on the how good is derived<br>&gt;&gt; &nbsp; &nbsp; &nbsp;data type handling, but seems to be lightweight.<br>
&gt;&gt;<br>&gt;&gt; &nbsp; &nbsp;* Sending extra data in a separate message -- seems this can have<br>&gt;&gt; &nbsp; &nbsp; &nbsp;much more significant overhead<br>&gt;&gt;<br>&gt;&gt; Do you know any other portable solution?<br>&gt;&gt;<br>&gt;&gt; I have implemented the first solution for P2P operations and it works<br>
&gt;&gt; pretty well. However there are problems with collective operations.<br>&gt;&gt; There are 2 classes of collective calls that are problematic:<br>&gt;&gt;<br>&gt;&gt; &nbsp; 1. Single receiver calls, like MPI_Gather. The sender tasks in<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;gather can be handled in the same way as a normal send, a data<br>&gt;&gt; &nbsp; &nbsp; &nbsp;item is wrapped and extra data is piggybacked with the message.<br>&gt;&gt; &nbsp; &nbsp; &nbsp;The problem is at the receiver side when a root gathers N data<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;items that must be received in an array big enough to receive<br>&gt;&gt; &nbsp; &nbsp; &nbsp;all items strided by datatype extent.<br>&gt;&gt;<br>&gt;&gt; &nbsp; &nbsp; &nbsp;In particular, it seems impossible to construct a datatype that<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;contains data item and extra data (i.e. structure type with<br>&gt;&gt; &nbsp; &nbsp; &nbsp;absolute addresses) AND make an array of these datatypes<br>&gt;&gt; &nbsp; &nbsp; &nbsp;separated by a fixed extent. For example: data item to receive<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;from every process is a vector of 1024 doubles. Extra data is a<br>&gt;&gt; &nbsp; &nbsp; &nbsp;single integer. User provides a receive buffer with place for N<br>&gt;&gt; &nbsp; &nbsp; &nbsp;* 1024 * double. The library allocates an array of N integers to<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;receive piggybacked data. How to construct a datatype that can<br>&gt;&gt; &nbsp; &nbsp; &nbsp;be used to receive data in MPI_Gather?<br>&gt;&gt;<br>&gt;&gt; &nbsp; 2. MPI_Reduce calls. There is no problem with datatypes as the<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;receiver gets the single data item and not an array as in<br>&gt;&gt; &nbsp; &nbsp; &nbsp;previous case. The problem is the reduction operator itself<br>&gt;&gt; &nbsp; &nbsp; &nbsp;(MPI_Op) because these operators do not work with wrapped data<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;types. So I can create a new operator to recognize the wrapped<br>&gt;&gt; &nbsp; &nbsp; &nbsp;data type that extracts the original data (skipping extra data)<br>&gt;&gt; &nbsp; &nbsp; &nbsp;and performs the original reduction. The point is how to invoke<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;the original reduction on an existing datatype. I have found<br>&gt;&gt; &nbsp; &nbsp; &nbsp;that Open MPI calls internally ompi_op_reduce(op, inbuf, rbuf,<br>&gt;&gt; &nbsp; &nbsp; &nbsp;count, dtype) this solves a problem. However this makes the code<br>
&gt;&gt; &nbsp; &nbsp; &nbsp;MPI-implementation dependent. Any idea on more portable options?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thank you in advance for any comment.<br>&gt;&gt;<br>&gt;&gt; --Oleg<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ------------------------------------------------------------------------<br>
&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; users mailing list<br>&gt;&gt; <a href="mailto:users@open-mpi.org">users@open-mpi.org</a><br>&gt;&gt; <a href="http://www.open-mpi.org/mailman/listinfo.cgi/users" target="_blank">http://www.open-mpi.org/mailman/listinfo.cgi/users</a><br>
&gt; _______________________________________________<br>&gt; users mailing list<br>&gt; <a href="mailto:users@open-mpi.org">users@open-mpi.org</a><br>&gt; <a href="http://www.open-mpi.org/mailman/listinfo.cgi/users" target="_blank">http://www.open-mpi.org/mailman/listinfo.cgi/users</a><br>
<br><br></div></div><font color="#888888">--<br>Dr. Aurélien Bouteiller<br>Sr. Research Associate - Innovative Computing Laboratory<br>Suite 350, 1122 Volunteer Boulevard<br>Knoxville, TN 37996<br>865 974 6321<br></font><div>
<div></div><div class="Wj3C7c"><br><br><br><br><br>_______________________________________________<br>users mailing list<br><a href="mailto:users@open-mpi.org">users@open-mpi.org</a><br><a href="http://www.open-mpi.org/mailman/listinfo.cgi/users" target="_blank">http://www.open-mpi.org/mailman/listinfo.cgi/users</a><br>
</div></div></blockquote></div><br>

