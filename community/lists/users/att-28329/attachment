<div dir="ltr"><br><br>On Thu, Jan 21, 2016 at 4:07 AM, Dave Love &lt;<a href="mailto:d.love@liverpool.ac.uk">d.love@liverpool.ac.uk</a>&gt; wrote:<br>&gt;<br>&gt; Jeff Hammond &lt;<a href="mailto:jeff.science@gmail.com">jeff.science@gmail.com</a>&gt; writes:<br>&gt;<br>&gt; &gt; Just using Intel compilers, OpenMP and MPI.  Problem solved :-)<br>&gt; &gt;<br>&gt; &gt; (I work for Intel and the previous statement should be interpreted as a<br>&gt; &gt; joke,<br>&gt;<br>&gt; Good!<br>&gt;<br>&gt; &gt; although Intel OpenMP and MPI interoperate as well as any<br>&gt; &gt; implementations of which I am aware.)<br>&gt;<br>&gt; Better than MPC (not that I&#39;ve used it)?<br>&gt;<br><br>MPC is a great idea, although it poses some challenges w.r.t. globals and such (however, see below).  Unfortunately, &quot;MPC conforms to the POSIX Threads, OpenMP 3.1 and MPI 1.3 standards&quot; (<a href="http://mpc.hpcframework.paratools.com/">http://mpc.hpcframework.paratools.com/</a>), it does not do me much good (I&#39;m a heavy-duty RMA user).<div><br></div><div>For those that are interested in MPC, the Intel compilers (on Linux) support an option to change how TLS works so that MPC works.<br><br>-f[no-]mpc_privatize<br>          Enables privatization of all static data for the MPC<br>          unified parallel runtime.  This will cause calls to<br>          extended thread local storage resolution run-time routines<br>          which are not supported on standard linux distributions.<br>          This option is only usable in conjunction with the MPC<br>          unified parallel runtime.  The default is -fno-mpc-privatize.<br><br>&gt;<br>&gt; For what it&#39;s worth, you have to worry about the batch resource manager<br>&gt; as well as the MPI, and you may need to ensure you&#39;re allocated complete<br>&gt; nodes.  There are known problems with IMPI and SGE specifically, and<br>&gt; several times I&#39;ve made users a lot happier with OMPI/GCC.<br>&gt;</div><div><br></div><div>This is likely because GCC uses one OpenMP thread when the user does not set OMP_NUM_THREADS, whereas Intel will use one per virtual processor (divided by MPI processes, but only if it can figure out how many).  Both behaviors are compliant with the OpenMP standard.  GCC is doing the conservative thing, whereas Intel is trying to maximize performance in the case of OpenMP-only applications (more common than you think) and MPI+OpenMP applications where Intel MPI is used.  As experienced HPC users always set OMP_NUM_THREADS (and OMP_PROC_BIND, OMP_WAIT_POLICY or implementation-specific equivalents) explicitly anyways, this should not be a problem.</div><div><br>As for not getting complete nodes, one is either in the cloud or the shared debug queue and performance is secondary.  But as always, one should be able to set OMP_NUM_THREADS, OMP_PROC_BIND, OMP_WAIT_POLICY to get the right behavior.</div><div><br></div><div>My limited experience with SGE has caused me to conclude that any problems associated with SGE + $X are almost certainly the fault of SGE and not $X.</div><div><br></div><div>&gt; &gt;&gt; Or pray the MPI Forum and OpenMP combine and I can just look in a<br>&gt; &gt;&gt; Standard. :D<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; echo &quot;&quot; &gt; $OPENMP_STANDARD # critical step<br>&gt; &gt; cat $MPI_STANDARD $OPENMP_STANDARD &gt; $HPC_STANDARD<br>&gt; &gt;<br>&gt; &gt; More seriously, hybrid programming sucks.  Just use MPI-3 and exploit your<br>&gt; &gt; coherence domain via MPI_Win_allocate_shared.  That way, you won&#39;t have to<br>&gt; &gt; mix runtimes, suffer mercilessly because of opaque race conditions in<br>&gt; &gt; thread-unsafe libraries, or reason about a bolt-on pseudo-language that<br>&gt; &gt; replicates features found in ISO languages without a well-defined<br>&gt; &gt; interoperability model.<br>&gt;<br>&gt; Sure, but the trouble is that &quot;everyone knows&quot;&quot; you need the hybrid<br>&gt; stuff.  Are there good examples of using MPI-3 instead/in comparison?<br>&gt; I&#39;d be particularly interested in convincing chemists, though as they<br>&gt; don&#39;t believe in deadlock and won&#39;t measure things, that&#39;s probably a<br>&gt; lost cause.  Not all chemists, of course.<br><br>PETSc (<a href="http://www.orau.gov/hpcor2015/whitepapers/Exascale_Computing_without_Threads-Barry_Smith.pdf">http://www.orau.gov/hpcor2015/whitepapers/Exascale_Computing_without_Threads-Barry_Smith.pdf</a>)</div><div><br></div><div>Quantum chemistry or molecular dynamics?  Parts of quantum chemistry are so flop heavy that stupid fork-join MPI+OpenMP is just fine.  I&#39;m doing this in NWChem coupled cluster codes.  I fork-join in every kernel even though this is shameful, because my kernels do somewhere between 4 and 40 billion FMAs and touch between 0.5 and 5 GB of memory.  For methods that aren&#39;t coupled-cluster, OpenMP is not always a good solution, and certainly not for legacy codes that aren&#39;t thread-safe.  OpenMP may be useful within a core to exploit &gt;1 thread per core (if necessary) and certainly &quot;#pragma omp simd&quot; should be exploited when appropriate, but scaling OpenMP beyond ~4 threads in most quantum chemistry codes requires an intensive rewrite.  Because of load-balancing issues in atomic integral computations, TBB or OpenMP tasking may be more appropriate.</div><div><br></div><div>If you want to have a more detailed discussion of programming models for computational chemistry, I&#39;d be happy to take that discussion offline.</div><div><br></div><div>Best,</div><div><br></div><div>Jeff<br><br><br><br>--<br>Jeff Hammond<br><a href="mailto:jeff.science@gmail.com">jeff.science@gmail.com</a><br><a href="http://jeffhammond.github.io/">http://jeffhammond.github.io/</a></div><div><br></div></div>

