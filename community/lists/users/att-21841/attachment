<div dir="ltr">Hi,<div><br></div><div style>I have a program where each MPI rank hosts a set of data blocks. After doing computation over *some of* its local data blocks, each MPI rank needs to exchange data with other ranks. Note that the computation may involve only a subset of the data blocks on a MPI rank. The data exchange is achieved at each MPI rank through Isend and Irecv and then Waitall to complete the requests. Each pair of Isend and Irecv exchanges a corresponding pair of data blocks at different ranks. Right now, we do Isend/Irecv for EVERY block!</div>
<div style><br></div><div style>The idea is that because the computation at a rank may only involves a subset of blocks, we could mark those blocks as dirty during the computation. And to reduce data exchange bandwidth, we could only exchanges those *dirty* pairs across ranks. </div>
<div style><br></div><div style>The problem is: if a rank does not compute on a block &#39;m&#39;, and if it does not call Isend for &#39;m&#39;, then the receiving rank must somehow know this and either a) does not call Irecv for &#39;m&#39; as well, or b) let Irecv for &#39;m&#39; fail gracefully. </div>
<div style><br></div><div style>My questions are: </div><div style>1. how Irecv will behave (actually how MPI_Waitall will behave) if the corresponding Isend is missing?</div><div style><br></div><div style>2. If we still post Isend for &#39;m&#39;, but because we really do not need to send any data for &#39;m&#39;, can I just set a &quot;flag&quot; in Isend so that MPI_Waitall on the receiving side will &quot;cancel&quot; the corresponding Irecv immediately? For example, I can set the count in Isend to 0, and on the receiving side, when MPI_Waitall see a message with empty payload, it reclaims the corresponding Irecv? In my code, the correspondence between a pair of Isend and Irecv is established by a matching TAG.</div>
<div style><br></div><div style>Thanks!</div><div style><br></div><div style>Jacky</div></div>

