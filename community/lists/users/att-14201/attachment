
<br><font size=2 face="sans-serif">I was pointing out that most programs
have some degree of elastic synchronization built in. Tasks (or groups
or components in a coupled model) seldom only produce data.they also consume
what other tasks produce and that limits the potential skew. &nbsp; </font>
<br>
<br><font size=2 face="sans-serif">If step n for a task (or group or coupled
component) depends on data produced by step n-1 in another task &nbsp;(or
group or coupled component) &nbsp;then no task can be farther ahead of
the task it depends on than one step. &nbsp; If there are 2 tasks that
each need the others step n-1 result to compute step n then they can never
get farther than one step out of synch. &nbsp;If there were a rank ordered
loop of &nbsp;8 tasks so each one needs the output of the prior step on
task ((me-1) &nbsp;mod tasks) to compute then you can get more skew because
if </font>
<br><font size=2 face="sans-serif">task 5 gets stalled in step 3,</font>
<br><font size=2 face="sans-serif">task 6 will finish step 3 and send results
to 7 but stall on recv for step 4 (lacking the end of step 3 send by task
5)</font>
<br><font size=2 face="sans-serif">task 7 will finish step 4 and send results
to 0 &nbsp;but stall on recv for step 5</font>
<br><font size=2 face="sans-serif">task 0 will finish step 5 and send results
to 1 &nbsp;but stall on recv for step 6</font>
<br><font size=2 face="sans-serif">etc</font>
<br>
<br><font size=2 face="sans-serif">In a 2D or 3D grid, the dependency is
tighter so the possible skew is less. but it is still significant on a
huge grid &nbsp; In a program with frequent calls to MPI_Allreduce on COMM_WORLD,
the skew is very limited. The available skew gets harder to predict as
the interdependencies grow more complex.</font>
<br>
<br><font size=2 face="sans-serif">I call this &quot;elasticity&quot; because
the amount of stretch varies but, like a bungee cord or an waist band,
only goes so far. Every parallel program has some degree of elasticity
built into the way its parts interact.</font>
<br>
<br><font size=2 face="sans-serif">I assume a coupler has some elasticity
too. That is, ocean and atmosphere each model Monday and report in to coupler
but neither can model Tuesday until they get some of the Monday results
generated by the other. (I am pretending granularity is day by day) &nbsp;Wouldn't
the right level of synchronization among component result automatically
form the data dependencies among them?</font>
<br>
<br><font size=2 face="sans-serif">&nbsp;</font>
<br>
<br><font size=2 face="sans-serif">Dick Treumann &nbsp;- &nbsp;MPI Team
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
IBM Systems &amp; Technology Group<br>
Dept X2ZA / MS P963 -- 2455 South Road -- Poughkeepsie, NY 12601<br>
Tele (845) 433-7846 &nbsp; &nbsp; &nbsp; &nbsp; Fax (845) 433-8363<br>
</font>
<br>
<br>
<br>
<table width=100%>
<tr valign=top>
<td><font size=1 color=#5f5f5f face="sans-serif">From:</font>
<td><font size=1 face="sans-serif">Eugene Loh &lt;eugene.loh@oracle.com&gt;</font>
<tr valign=top>
<td><font size=1 color=#5f5f5f face="sans-serif">To:</font>
<td><font size=1 face="sans-serif">Open MPI Users &lt;users@open-mpi.org&gt;</font>
<tr valign=top>
<td><font size=1 color=#5f5f5f face="sans-serif">Date:</font>
<td><font size=1 face="sans-serif">09/09/2010 12:40 PM</font>
<tr valign=top>
<td><font size=1 color=#5f5f5f face="sans-serif">Subject:</font>
<td><font size=1 face="sans-serif">Re: [OMPI users] MPI_Reduce performance</font>
<tr valign=top>
<td><font size=1 color=#5f5f5f face="sans-serif">Sent by:</font>
<td><font size=1 face="sans-serif">users-bounces@open-mpi.org</font></table>
<br>
<hr noshade>
<br>
<br>
<br><tt><font size=2>Gus Correa wrote:<br>
<br>
&gt; More often than not some components lag behind (regardless of how<br>
&gt; much you tune the number of processors assigned to each component),<br>
&gt; slowing down the whole scheme.<br>
&gt; The coupler must sit and wait for that late component,<br>
&gt; the other components must sit and wait for the coupler,<br>
&gt; and the (vicious) &quot;positive feedback&quot; cycle that<br>
&gt; Ashley mentioned goes on and on.<br>
<br>
I think &quot;sit and wait&quot; is the &quot;typical&quot; scenario that
Dick mentions. &nbsp;<br>
Someone lags, so someone else has to wait.<br>
<br>
In contrast, the &quot;feedback&quot; cycle Ashley mentions is where someone
lags <br>
and someone else keeps racing ahead, pumping even more data at the <br>
laggard, forcing the laggard ever further behind.<br>
_______________________________________________<br>
users mailing list<br>
users@open-mpi.org<br>
</font></tt><a href="http://www.open-mpi.org/mailman/listinfo.cgi/users"><tt><font size=2>http://www.open-mpi.org/mailman/listinfo.cgi/users</font></tt></a><tt><font size=2><br>
</font></tt>
<br>
<br>
