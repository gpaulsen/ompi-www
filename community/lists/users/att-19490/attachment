<html><body><div style="color:#000; background-color:#fff; font-family:times new roman, new york, times, serif;font-size:10pt"><div><span>Dear MPI people, <br></span></div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I am working on a graph partitioning problem, where we have an undirected graph of p MPI processes. The edges have weights that show how much communication processes do among themselves. The cluster has multiple nodes (each node with 8 cores) and nodes are connected through Infiniband fast network. The task is the partition the graph in k partitions where k is the number of nodes such that the edge cut is minimized (across partitions/nodes edges or communication). I wrote a distributed algorithm for that. I will compare its quality with the algorithms from graph community, but right now I am
 writing the algorithm for MPI applications. I have seen that with 10% sparse undirected graph, I got upto 80% reduction in edge cut (for k=2). <br></span></div><div><br><span></span></div><div><span>I checked the algorithm very deeply and I have seen that the optimal partitions are residing on different nodes (I saw the IPs). Based on the NetPipe benchmark, I wrote a test application where I randomly generate undirected graphs. I run that application before doing the reduction of edge cut and after reduction of edge cut. The processes that communicate more come to the same nodes. In the algorithm, each process gets a new rank based on communication requirement. The problem I am getting is that the overall execution time of the test application should be less than the application that runs without performing edge cut reduction but it does not happen. Here is the code for test application (self explanatory) and the output of the program. Please help me
 diagnosing the logical bug. We can discuss more.</span></div><div><br><span></span></div><div><span>MPI_Barrier(comm);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; t0 = MPI_Wtime();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for(int j=0;j&lt;10;j++)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for(int i=0; i&lt;comm_size; i++)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; int target = comminfo[i].rank;<br>&nbsp;&nbsp;&nbsp; int comm_amount = comminfo[i].comm;<br>&nbsp;&nbsp;&nbsp; if(comm_amount &gt; 0)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; buff = new Node[MAX_COMM*NTRIALS];<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MPI_Irecv (buff, MAX_COMM * NTRIALS * sizeof(Node)/sizeof(char), MPI_CHAR, MPI_ANY_SOURCE, 4600, comm, &amp;recv_requests[i]);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; recv_buffers.insert(recv_buffers.end(), buff); <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;
 }<br><br>&nbsp;&nbsp;&nbsp; for(int i=0; i&lt;comm_size; i++)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; int target = comminfo[i].rank;<br>&nbsp;&nbsp;&nbsp; int comm_amount = comminfo[i].comm;<br>&nbsp;&nbsp;&nbsp; if(comm_amount &gt; 0)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; buff = new Node[comm_amount/2*NTRIALS];<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MPI_Isend((void*)buff, comm_amount/2 * NTRIALS * sizeof(Node)/sizeof(char), MPI_CHAR, target, 4600, comm, &amp;send_requests[i]);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; send_buffers.insert(send_buffers.end(), buff);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MPI_Waitall(comm_size, send_requests, send_status);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MPI_Waitall(comm_size, recv_requests, recv_status);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; t1 =
 MPI_Wtime();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MPI_Allreduce(&amp;t0, &amp;min_t0, 1, MPI_DOUBLE, MPI_MIN, comm);<br>&nbsp;&nbsp;&nbsp; MPI_Allreduce(&amp;t1, &amp;max_t1, 1, MPI_DOUBLE, MPI_MAX, comm);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; diff = (max_t1 - min_t0) / NTRIALS;<br></span></div><br>&nbsp; retirm diff; // this value will be printed in main function....<br><br><br>.................. the output of the program is <br><br><br><br>mpprun INFO: Starting openmpi run on 2 nodes (16 ranks)...<br><br>P0 &gt;&gt; Without balancing: Execution took: 0.0081014822 secs<br><br>Edge_Cut_Before: 46864<br><br>Edge_Cut_After: 20097<br><br>Balancing took: 1.0993268490 secs<br><br>P0 &gt;&gt; After balancing: Execution took: 0.0095374639 secs<br><br><br><br>Please help me.<br><br>best regards,<br><br>Mudassar<br><br><br><br><br></div></body></html>
