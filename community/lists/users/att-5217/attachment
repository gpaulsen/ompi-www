Hi there!<br><br>I'm learning MPI,&nbsp; and got really puzzled... Please take a look at this very short code:<br><br>#include &lt;iostream&gt;<br>#include "mpicxx.h"<br>using namespace std;<br>int main(int argc, char *argv[])<br>{<br>&nbsp;&nbsp;&nbsp; MPI::Init();&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; for (unsigned long t = 0; t &lt; 10000000; t++)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //If we are process 0:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ( MPI::COMM_WORLD.Get_rank() == 0 )<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MPI::Status mpi_status;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned long d = 0;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned long d2 = 0;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MPI::COMM_WORLD.Recv(&amp;d, 1, MPI::UNSIGNED_LONG, MPI::ANY_SOURCE, MPI::ANY_TAG,
 mpi_status );<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MPI::COMM_WORLD.Recv(&amp;d2, 1, MPI::UNSIGNED_LONG, MPI::ANY_SOURCE, MPI::ANY_TAG, mpi_status );<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cout &lt;&lt; "Time = " &lt;&lt; t &lt;&lt; "; Node 0 received: " &lt;&lt; d &lt;&lt; " and " &lt;&lt; d2 &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //Else:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned long&nbsp; d = MPI::COMM_WORLD.Get_rank();<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MPI::COMM_WORLD.Send( &amp;d, 1, MPI::UNSIGNED_LONG, 0, 0);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; MPI::Finalize();<br>}<br><br>Ok, so what I'm trying to do is to make a gather operation using point to point communication. In my
 real application instead of sending an unsigned long I'd be calling an object's send and receive methods, which in turn would call their inner object's similar methods and so on until all data is syncronized. I'm using this loop because the number of objects to be sent to process rank 0 varies depending on the sender.<br><br>When running this test with 3 processes on a dual core, oversubscribed node, I get this output:<br>(skipped previous output)<br>Time = 5873; Node 0 received: 1 and 2<br>Time = 5874; Node 0 received: 1 and 2<br>Time = 5875; Node 0 received: 1 and 2<br>Time = 5876; Node 0 received: 1 and 2<br><br>and then the application hangs, with processor usage at 100%. The exact time when this condition occurs varies on each run, but it usually happens quite fast.<br><br>What would I have to modify, in this simple example, so that the application works as expected? Must I always use Gather, instead of point to point, to make a syncronization like this?<br><br>Thank
 you very much!<br><br>Giovani<br><br><br><br><br><br><br><p>&#32;__________________________________________________<br>Fale com seus amigos  de graça com o novo Yahoo! Messenger <br>http://br.messenger.yahoo.com/ 
