Does the behavior only occur with Java applications, as your subject implies? I thought this was a more general behavior based on prior notes?<br><br>As I said back then, I have no earthly idea why your local machine is being ignored, and I cannot replicate that behavior on any system available to me.<br>
<br>What you might try is adding --display-allocation --display-devel-map to your cmd line and see what the system thinks it is doing. The first option will display what nodes and slots it thinks are available to it, and the second will report where it thinks it placed everything.<br>
<br><br><br><div class="gmail_quote">On Wed, Sep 26, 2012 at 4:53 AM, Siegmar Gross <span dir="ltr">&lt;<a href="mailto:Siegmar.Gross@informatik.hs-fulda.de" target="_blank">Siegmar.Gross@informatik.hs-fulda.de</a>&gt;</span> wrote:<br>
<blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">Hi,<br>
<br>
yesterday I have installed openmpi-1.9a1r27362 and I still have a<br>
problem with &quot;-host&quot;. My local machine will not be used, if I try<br>
to start processes on three hosts.<br>
<br>
tyr:    Solaris 10, Sparc<br>
sunpc4: Solaris 10 , x86_64<br>
linpc4: openSUSE-Linux 12.1, x86_64<br>
<br>
<br>
tyr mpi_classfiles 175 javac HelloMainWithoutMPI.java<br>
tyr mpi_classfiles 176 mpiexec -np 3 -host tyr,sunpc4,linpc4 \<br>
  java -cp $HOME/mpi_classfiles HelloMainWithoutMPI<br>
Hello from <a href="http://linpc4.informatik.hs-fulda.de/193.174.26.225" target="_blank">linpc4.informatik.hs-fulda.de/193.174.26.225</a><br>
Hello from <a href="http://sunpc4.informatik.hs-fulda.de/193.174.26.224" target="_blank">sunpc4.informatik.hs-fulda.de/193.174.26.224</a><br>
Hello from <a href="http://sunpc4.informatik.hs-fulda.de/193.174.26.224" target="_blank">sunpc4.informatik.hs-fulda.de/193.174.26.224</a><br>
tyr mpi_classfiles 177 which mpiexec<br>
/usr/local/openmpi-1.9_64_cc/bin/mpiexec<br>
<br>
<br>
Everything works fine with openmpi-1.6.2rc5r27346.<br>
<br>
tyr mpi_classfiles 108 javac HelloMainWithoutMPI.java<br>
tyr mpi_classfiles 109 mpiexec -np 3 -host tyr,sunpc4,linpc4 \<br>
  java -cp $HOME/mpi_classfiles HelloMainWithoutMPI<br>
Hello from <a href="http://linpc4.informatik.hs-fulda.de/193.174.26.225" target="_blank">linpc4.informatik.hs-fulda.de/193.174.26.225</a><br>
Hello from <a href="http://sunpc4.informatik.hs-fulda.de/193.174.26.224" target="_blank">sunpc4.informatik.hs-fulda.de/193.174.26.224</a><br>
Hello from <a href="http://tyr.informatik.hs-fulda.de/193.174.24.39" target="_blank">tyr.informatik.hs-fulda.de/193.174.24.39</a><br>
tyr mpi_classfiles 110 which mpiexec<br>
/usr/local/openmpi-1.6.2_64_cc/bin/mpiexec<br>
<br>
<br>
In my opinion it is a problem with openmpi-1.9. I used the following<br>
configure command for Sparc. The commands for the other platforms are<br>
similar.<br>
<br>
../openmpi-1.9a1r27362/configure --prefix=/usr/local/openmpi-1.9_64_cc \<br>
  --libdir=/usr/local/openmpi-1.9_64_cc/lib64 \<br>
  --with-jdk-bindir=/usr/local/jdk1.7.0_07/bin/sparcv9 \<br>
  --with-jdk-headers=/usr/local/jdk1.7.0_07/include \<br>
  JAVA_HOME=/usr/local/jdk1.7.0_07 \<br>
  LDFLAGS=&quot;-m64&quot; \<br>
  CC=&quot;cc&quot; CXX=&quot;CC&quot; FC=&quot;f95&quot; \<br>
  CFLAGS=&quot;-m64&quot; CXXFLAGS=&quot;-m64 -library=stlport4&quot; FCFLAGS=&quot;-m64&quot; \<br>
  CPP=&quot;cpp&quot; CXXCPP=&quot;cpp&quot; \<br>
  CPPFLAGS=&quot;&quot; CXXCPPFLAGS=&quot;&quot; \<br>
  C_INCL_PATH=&quot;&quot; C_INCLUDE_PATH=&quot;&quot; CPLUS_INCLUDE_PATH=&quot;&quot; \<br>
  OBJC_INCLUDE_PATH=&quot;&quot; OPENMPI_HOME=&quot;&quot; \<br>
  --enable-cxx-exceptions \<br>
  --enable-mpi-java \<br>
  --enable-heterogeneous \<br>
  --enable-opal-multi-threads \<br>
  --enable-mpi-thread-multiple \<br>
  --with-threads=posix \<br>
  --with-hwloc=internal \<br>
  --without-verbs \<br>
  --without-udapl \<br>
  --with-wrapper-cflags=-m64 \<br>
  --enable-debug \<br>
  |&amp; tee log.configure.$SYSTEM_ENV.$MACHINE_ENV.64_cc<br>
<br>
Can I provide anything to track the problem? Thank you very much for<br>
<div class="HOEnZb"><div class="h5">any help in advance.<br>
<br>
<br>
Kind regards<br>
<br>
Siegmar<br>
<br>
<br>
<br>
&gt; &gt;&gt;&gt; I tried mpiJava on a 32-bit installation of openmpi-1.9a1r27361.<br>
&gt; &gt;&gt;&gt; Why doesn&#39;t &quot;mpiexec&quot; start a process on my local machine (it<br>
&gt; &gt;&gt;&gt; is not a matter of Java, because I have the same behaviour when<br>
&gt; &gt;&gt;&gt; I use &quot;hostname&quot;)?<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; tyr java 133 mpiexec -np 3 -host tyr,sunpc4,sunpc1 \<br>
&gt; &gt;&gt;&gt; java -cp $HOME/mpi_classfiles HelloMainWithBarrier<br>
&gt; &gt;&gt;&gt; Process 0 of 3 running on <a href="http://sunpc4.informatik.hs-fulda.de" target="_blank">sunpc4.informatik.hs-fulda.de</a><br>
&gt; &gt;&gt;&gt; Process 1 of 3 running on <a href="http://sunpc4.informatik.hs-fulda.de" target="_blank">sunpc4.informatik.hs-fulda.de</a><br>
&gt; &gt;&gt;&gt; Process 2 of 3 running on sunpc1<br>
&gt; &gt;&gt;&gt; ...<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; tyr small_prog 142 mpiexec -np 3 -host tyr,sunpc4,sunpc1 hostname<br>
&gt; &gt;&gt;&gt; sunpc1<br>
&gt; &gt;&gt;&gt; <a href="http://sunpc4.informatik.hs-fulda.de" target="_blank">sunpc4.informatik.hs-fulda.de</a><br>
&gt; &gt;&gt;&gt; <a href="http://sunpc4.informatik.hs-fulda.de" target="_blank">sunpc4.informatik.hs-fulda.de</a><br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;<br>
&gt; &gt;&gt; No idea - it works fine for me. Do you have an environmental<br>
&gt; &gt;&gt; variable, or something in your default MCA param file, that<br>
&gt; &gt;&gt; indicates &quot;no_use_local&quot;?<br>
&gt; &gt;<br>
&gt; &gt; I have only built and installed Open MPI and I have no param file.<br>
&gt; &gt; I don&#39;t have a mca environment variable.<br>
&gt; &gt;<br>
&gt; &gt; tyr hello_1 136 grep local \<br>
&gt; &gt;  /usr/local/openmpi-1.9_64_cc/etc/openmpi-mca-params.conf<br>
&gt; &gt; # $sysconf is a directory on a local disk, it is likely that changes<br>
&gt; &gt; #   component_path = /usr/local/lib/openmpi:~/my_openmpi_components<br>
&gt; &gt;<br>
&gt; &gt; tyr hello_1 143 env | grep -i mca<br>
&gt; &gt; tyr hello_1 144<br>
&gt;<br>
&gt; No ideas - I can&#39;t make it behave that way  :-(<br>
&gt;<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt;&gt;&gt; The command breaks if I add a Linux machine.<br>
&gt; &gt;&gt;<br>
&gt; &gt;&gt; Check to ensure that the path and ld_library_path on your linux box<br>
&gt; &gt;&gt; is being correctly set to point to the corresponding Linux OMPI libs.<br>
&gt; &gt;&gt; It looks like that isn&#39;t the case. Remember, the Java bindings are<br>
&gt; &gt;&gt; just that - they are bindings that wrap on top of the regular C<br>
&gt; &gt;&gt; code. Thus, the underlying OMPI system remains system-dependent,<br>
&gt; &gt;&gt; and you must have the appropriate native libraries installed on<br>
&gt; &gt;&gt; each machine.<br>
&gt; &gt;<br>
&gt; &gt; I implemented a small program, which shows these values and they<br>
&gt; &gt; are wrong for MPI, but I have no idea why. The two entries at the<br>
&gt; &gt; beginning from PATH and LD_LIBRARY_PATH are not from our normal<br>
&gt; &gt; environment, because I add these values at the end of the environment<br>
&gt; &gt; variables PATH, LD_LIBRARY_PATH_32, and LD_LIBRARY_PATH_64. Afterwards<br>
&gt; &gt; I set LD_LIBRARY_PATH to LD_LIBRARY_PATH_64 on a 64-bit Solaris<br>
&gt; &gt; machine, to LD_LIBRARY_PATH_32 followed by LD_LIBRARY_PATH_64 on a<br>
&gt; &gt; 64-bit Linux machine, and to LD_LIBRARY_PATH_32 on every 32-bit<br>
&gt; &gt; machine.<br>
&gt; &gt;<br>
&gt;<br>
&gt; I see the problem - our heterogeneous support could use some improvement, but<br>
it&#39;ll be awhile before I can get to it.<br>
&gt;<br>
&gt; What&#39;s happening is that we are picking up and propagating the prefix you<br>
specified, prepending it to your path and ld_library_path. Did you by chance<br>
configure with --enable-orterun-prefix-by-default? Or specify --prefix on your<br>
cmd line? Otherwise, it shouldn&#39;t be doing this. For this purpose, you cannot<br>
use either of those options.<br>
&gt;<br>
&gt; Also, you&#39;ll need to add --enable-heterogeneous to your configure so the MPI<br>
layer builds the right support, and add --hetero-nodes to your cmd line.<br>
&gt;<br>
&gt;<br>
&gt; &gt;<br>
&gt; &gt; Now 1 slave tasks are sending their environment.<br>
&gt; &gt;<br>
&gt; &gt; Environment from task 1:<br>
&gt; &gt;  message type:        3<br>
&gt; &gt;  msg length:          4622 characters<br>
&gt; &gt;  message:<br>
&gt; &gt;    hostname:          <a href="http://tyr.informatik.hs-fulda.de" target="_blank">tyr.informatik.hs-fulda.de</a><br>
&gt; &gt;    operating system:  SunOS<br>
&gt; &gt;    release:           5.10<br>
&gt; &gt;    processor:         sun4u<br>
&gt; &gt;    PATH<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/bin  (!!!)<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/bin  (!!!)<br>
&gt; &gt;                       /usr/local/eclipse-3.6.1<br>
&gt; &gt;                       ...<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/bin  (&lt;- from our<br>
environment)<br>
&gt; &gt;    LD_LIBRARY_PATH_32<br>
&gt; &gt;                       /usr/lib<br>
&gt; &gt;                       /usr/local/jdk1.7.0_07/jre/lib/sparc<br>
&gt; &gt;                       ...<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/lib  (&lt;- from our<br>
environment)<br>
&gt; &gt;    LD_LIBRARY_PATH_64<br>
&gt; &gt;                       /usr/lib/sparcv9<br>
&gt; &gt;                       /usr/local/jdk1.7.0_07/jre/lib/sparcv9<br>
&gt; &gt;                       ...<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/lib64  (&lt;- from our<br>
environment)<br>
&gt; &gt;    LD_LIBRARY_PATH<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/lib     (!!!)<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/lib64   (!!!)<br>
&gt; &gt;                       /usr/lib/sparcv9<br>
&gt; &gt;                       /usr/local/jdk1.7.0_07/jre/lib/sparcv9<br>
&gt; &gt;                       ...<br>
&gt; &gt;                       /usr/local/openmpi-1.9_64_cc/lib64  (&lt;- from our<br>
environment)<br>
&gt; &gt;    CLASSPATH<br>
&gt; &gt;                       /usr/local/junit4.10<br>
&gt; &gt;                       /usr/local/junit4.10/junit-4.10.jar<br>
&gt; &gt;                       //usr/local/jdk1.7.0_07/j3d/lib/ext/j3dcore.jar<br>
&gt; &gt;                       //usr/local/jdk1.7.0_07/j3d/lib/ext/j3dutils.jar<br>
&gt; &gt;                       //usr/local/jdk1.7.0_07/j3d/lib/ext/vecmath.jar<br>
&gt; &gt;                       /usr/local/javacc-5.0/javacc.jar<br>
&gt; &gt;                       .<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt; Without MPI the program uses our environment.<br>
&gt; &gt;<br>
&gt; &gt; tyr hello_1 147 diff env_with*<br>
&gt; &gt; 1,7c1<br>
&gt; &gt; &lt;<br>
&gt; &gt; &lt;<br>
&gt; &gt; &lt; Now 1 slave tasks are sending their environment.<br>
&gt; &gt; &lt;<br>
&gt; &gt; &lt; Environment from task 1:<br>
&gt; &gt; &lt;   message type:        3<br>
&gt; &gt; &lt;   msg length:          4622 characters<br>
&gt; &gt; ---<br>
&gt; &gt;&gt; Environment:<br>
&gt; &gt; 14,15d7<br>
&gt; &gt; &lt;                        /usr/local/openmpi-1.9_64_cc/bin<br>
&gt; &gt; &lt;                        /usr/local/openmpi-1.9_64_cc/bin<br>
&gt; &gt; 81,82d72<br>
&gt; &gt; &lt;                        /usr/local/openmpi-1.9_64_cc/lib<br>
&gt; &gt; &lt;                        /usr/local/openmpi-1.9_64_cc/lib64<br>
&gt; &gt; tyr hello_1 148<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt; I have attached the programs so that you can check yourself and<br>
&gt; &gt; hopefully get the same results. Do you modify PATH and LD_LIBRARY_PATH?<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt; Kind regards<br>
&gt; &gt;<br>
&gt; &gt; Siegmar<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt;&gt;&gt; tyr java 110 mpiexec -np 3 -host tyr,sunpc4,linpc4 \<br>
&gt; &gt;&gt;&gt; java -cp $HOME/mpi_classfiles HelloMainWithBarrier<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; It looks like opal_init failed for some reason; your parallel process is<br>
&gt; &gt;&gt;&gt; likely to abort.  There are many reasons that a parallel process can<br>
&gt; &gt;&gt;&gt; fail during opal_init; some of which are due to configuration or<br>
&gt; &gt;&gt;&gt; environment problems.  This failure appears to be an internal failure;<br>
&gt; &gt;&gt;&gt; here&#39;s some additional information (which may only be relevant to an<br>
&gt; &gt;&gt;&gt; Open MPI developer):<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; mca_base_open failed<br>
&gt; &gt;&gt;&gt; --&gt; Returned value -2 instead of OPAL_SUCCESS<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; It looks like orte_init failed for some reason; your parallel process is<br>
&gt; &gt;&gt;&gt; likely to abort.  There are many reasons that a parallel process can<br>
&gt; &gt;&gt;&gt; fail during orte_init; some of which are due to configuration or<br>
&gt; &gt;&gt;&gt; environment problems.  This failure appears to be an internal failure;<br>
&gt; &gt;&gt;&gt; here&#39;s some additional information (which may only be relevant to an<br>
&gt; &gt;&gt;&gt; Open MPI developer):<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; opal_init failed<br>
&gt; &gt;&gt;&gt; --&gt; Returned value Out of resource (-2) instead of ORTE_SUCCESS<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; It looks like MPI_INIT failed for some reason; your parallel process is<br>
&gt; &gt;&gt;&gt; likely to abort.  There are many reasons that a parallel process can<br>
&gt; &gt;&gt;&gt; fail during MPI_INIT; some of which are due to configuration or<br>
environment<br>
&gt; &gt;&gt;&gt; problems.  This failure appears to be an internal failure; here&#39;s some<br>
&gt; &gt;&gt;&gt; additional information (which may only be relevant to an Open MPI<br>
&gt; &gt;&gt;&gt; developer):<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; ompi_mpi_init: orte_init failed<br>
&gt; &gt;&gt;&gt; --&gt; Returned &quot;Out of resource&quot; (-2) instead of &quot;Success&quot; (0)<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; *** An error occurred in MPI_Init<br>
&gt; &gt;&gt;&gt; *** on a NULL communicator<br>
&gt; &gt;&gt;&gt; *** MPI_ERRORS_ARE_FATAL (processes in this communicator will now abort,<br>
&gt; &gt;&gt;&gt; ***    and potentially your MPI job)<br>
&gt; &gt;&gt;&gt; [linpc4:27369] Local abort before MPI_INIT completed successfully;<br>
&gt; &gt;&gt;&gt; not able to aggregate error messages, and not able to guarantee<br>
&gt; &gt;&gt;&gt; that all other processes were killed!<br>
&gt; &gt;&gt;&gt; -------------------------------------------------------<br>
&gt; &gt;&gt;&gt; Primary job  terminated normally, but 1 process returned<br>
&gt; &gt;&gt;&gt; a non-zero exit code.. Per user-direction, the job has been aborted.<br>
&gt; &gt;&gt;&gt; -------------------------------------------------------<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; mpiexec detected that one or more processes exited with non-zero status,<br>
&gt; &gt;&gt;&gt; thus causing<br>
&gt; &gt;&gt;&gt; the job to be terminated. The first process to do so was:<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; Process name: [[21095,1],2]<br>
&gt; &gt;&gt;&gt; Exit code:    1<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; tyr java 111 which mpijavac<br>
&gt; &gt;&gt;&gt; /usr/local/openmpi-1.9_32_cc/bin/mpijavac<br>
&gt; &gt;&gt;&gt; tyr java 112 more /usr/local/openmpi-1.9_32_cc/bin/mpijavac<br>
&gt; &gt;&gt;&gt; #!/usr/bin/env perl<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; # WARNING: DO NOT EDIT THE <a href="http://mpijava.pl" target="_blank">mpijava.pl</a> FILE AS IT IS GENERATED!<br>
&gt; &gt;&gt;&gt; #          MAKE ALL CHANGES IN <a href="http://mpijava.pl.in" target="_blank">mpijava.pl.in</a><br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; # Copyright (c) 2011      Cisco Systems, Inc.  All rights reserved.<br>
&gt; &gt;&gt;&gt; # Copyright (c) 2012      Oracle and/or its affiliates.  All rights<br>
reserved.<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; use strict;<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; # The main purpose of this wrapper compiler is to check for<br>
&gt; &gt;&gt;&gt; # and adjust the Java class path to include the OMPI classes<br>
&gt; &gt;&gt;&gt; # in mpi.jar. The user may have specified a class path on<br>
&gt; &gt;&gt;&gt; # our cmd line, or it may be in the environment, so we have<br>
&gt; &gt;&gt;&gt; # to check for both. We also need to be careful not to<br>
&gt; &gt;&gt;&gt; # just override the class path as it probably includes classes<br>
&gt; &gt;&gt;&gt; # they need for their application! It also may already include<br>
&gt; &gt;&gt;&gt; # the path to mpi.jar, and while it doesn&#39;t hurt anything, we<br>
&gt; &gt;&gt;&gt; # don&#39;t want to include our class path more than once to avoid<br>
&gt; &gt;&gt;&gt; # user astonishment<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; # Let the build system provide us with some critical values<br>
&gt; &gt;&gt;&gt; my $my_compiler = &quot;/usr/local/jdk1.7.0_07/bin/javac&quot;;<br>
&gt; &gt;&gt;&gt; my $ompi_classpath = &quot;/usr/local/openmpi-1.9_32_cc/lib/mpi.jar&quot;;<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; # globals<br>
&gt; &gt;&gt;&gt; my $showme_arg = 0;<br>
&gt; &gt;&gt;&gt; my $verbose = 0;<br>
&gt; &gt;&gt;&gt; my $my_arg;<br>
&gt; &gt;&gt;&gt; ...<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; All libraries are available.<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; tyr java 113 ldd /usr/local/jdk1.7.0_07/bin/javac<br>
&gt; &gt;&gt;&gt;       libthread.so.1 =&gt;        /usr/lib/libthread.so.1<br>
&gt; &gt;&gt;&gt;       libjli.so =&gt;<br>
&gt; &gt;&gt;&gt; /export2/prog/SunOS_sparc/jdk1.7.0_07/bin/../jre/lib/sparc/jli/libjli.so<br>
&gt; &gt;&gt;&gt;       libdl.so.1 =&gt;    /usr/lib/libdl.so.1<br>
&gt; &gt;&gt;&gt;       libc.so.1 =&gt;     /usr/lib/libc.so.1<br>
&gt; &gt;&gt;&gt;       libm.so.2 =&gt;     /usr/lib/libm.so.2<br>
&gt; &gt;&gt;&gt;       /platform/SUNW,A70/lib/libc_psr.so.1<br>
&gt; &gt;&gt;&gt; tyr java 114 ssh sunpc4 ldd /usr/local/jdk1.7.0_07/bin/javac<br>
&gt; &gt;&gt;&gt;       libthread.so.1 =&gt;        /usr/lib/libthread.so.1<br>
&gt; &gt;&gt;&gt;       libjli.so =&gt;<br>
&gt; &gt;&gt;&gt; /usr/local/jdk1.7.0_07/bin/../jre/lib/i386/jli/libjli.so<br>
&gt; &gt;&gt;&gt;       libdl.so.1 =&gt;    /usr/lib/libdl.so.1<br>
&gt; &gt;&gt;&gt;       libc.so.1 =&gt;     /usr/lib/libc.so.1<br>
&gt; &gt;&gt;&gt;       libm.so.2 =&gt;     /usr/lib/libm.so.2<br>
&gt; &gt;&gt;&gt; tyr java 115 ssh linpc4 ldd /usr/local/jdk1.7.0_07/bin/javac<br>
&gt; &gt;&gt;&gt;       linux-gate.so.1 =&gt;  (0xffffe000)<br>
&gt; &gt;&gt;&gt;       libpthread.so.0 =&gt; /lib/libpthread.so.0 (0xf77b2000)<br>
&gt; &gt;&gt;&gt;       libjli.so =&gt;<br>
/usr/local/jdk1.7.0_07/bin/../jre/lib/i386/jli/libjli.so<br>
&gt; &gt;&gt;&gt; (0xf779d000)<br>
&gt; &gt;&gt;&gt;       libdl.so.2 =&gt; /lib/libdl.so.2 (0xf7798000)<br>
&gt; &gt;&gt;&gt;       libc.so.6 =&gt; /lib/libc.so.6 (0xf762b000)<br>
&gt; &gt;&gt;&gt;       /lib/ld-linux.so.2 (0xf77ce000)<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; I don&#39;t have any errors in the log files except the error for nfs.<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; tyr openmpi-1.9-Linux.x86_64.32_cc 136 ls log.*<br>
&gt; &gt;&gt;&gt; log.configure.Linux.x86_64.32_cc   log.make-install.Linux.x86_64.32_cc<br>
&gt; &gt;&gt;&gt; log.make-check.Linux.x86_64.32_cc  log.make.Linux.x86_64.32_cc<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; tyr openmpi-1.9-Linux.x86_64.32_cc 137 grep &quot;Error 1&quot; log.*<br>
&gt; &gt;&gt;&gt; log.make-check.Linux.x86_64.32_cc:make[3]: *** [check-TESTS] Error 1<br>
&gt; &gt;&gt;&gt; log.make-check.Linux.x86_64.32_cc:make[1]: *** [check-recursive] Error 1<br>
&gt; &gt;&gt;&gt; log.make-check.Linux.x86_64.32_cc:make: *** [check-recursive] Error 1<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; ...<br>
&gt; &gt;&gt;&gt; SUPPORT: OMPI Test failed: opal_path_nfs() (1 of 32 failed)<br>
&gt; &gt;&gt;&gt; FAIL: opal_path_nfs<br>
&gt; &gt;&gt;&gt; ========================================================<br>
&gt; &gt;&gt;&gt; 1 of 2 tests failed<br>
&gt; &gt;&gt;&gt; Please report to <a href="http://www.open-mpi.org/community/help/" target="_blank">http://www.open-mpi.org/community/help/</a><br>
&gt; &gt;&gt;&gt; ========================================================<br>
&gt; &gt;&gt;&gt; make[3]: *** [check-TESTS] Error 1<br>
&gt; &gt;&gt;&gt; ...<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; It doesn&#39;t help to build the class files on Linux (which should be<br>
&gt; &gt;&gt;&gt; independent of the architecture anyway).<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; tyr java 131 ssh linpc4<br>
&gt; &gt;&gt;&gt; linpc4 fd1026 98 cd .../prog/mpi/java<br>
&gt; &gt;&gt;&gt; linpc4 java 99 make clean<br>
&gt; &gt;&gt;&gt; rm -f /home/fd1026/mpi_classfiles/HelloMainWithBarrier.class \<br>
&gt; &gt;&gt;&gt; /home/fd1026/mpi_classfiles/HelloMainWithoutBarrier.class<br>
&gt; &gt;&gt;&gt; linpc4 java 100 make<br>
&gt; &gt;&gt;&gt; mpijavac -d /home/fd1026/mpi_classfiles HelloMainWithBarrier.java<br>
&gt; &gt;&gt;&gt; mpijavac -d /home/fd1026/mpi_classfiles HelloMainWithoutBarrier.java<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; linpc4 java 101  mpiexec -np 3 -host linpc4 \<br>
&gt; &gt;&gt;&gt; java -cp $HOME/mpi_classfiles HelloMainWithBarrier<br>
&gt; &gt;&gt;&gt; --------------------------------------------------------------------------<br>
&gt; &gt;&gt;&gt; It looks like opal_init failed for some reason; your parallel process is<br>
&gt; &gt;&gt;&gt; likely to abort.  There are many reasons that a parallel process can<br>
&gt; &gt;&gt;&gt; fail during opal_init; some of which are due to configuration or<br>
&gt; &gt;&gt;&gt; environment problems.  This failure appears to be an internal failure;<br>
&gt; &gt;&gt;&gt; here&#39;s some additional information (which may only be relevant to an<br>
&gt; &gt;&gt;&gt; Open MPI developer):<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; mca_base_open failed<br>
&gt; &gt;&gt;&gt; --&gt; Returned value -2 instead of OPAL_SUCCESS<br>
&gt; &gt;&gt;&gt; ...<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; Has anybody else this problem as well? Do you know a solution?<br>
&gt; &gt;&gt;&gt; Thank you very much for any help in advance.<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; Kind regards<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; Siegmar<br>
&gt; &gt;&gt;&gt;<br>
&gt; &gt;&gt;&gt; _______________________________________________<br>
&gt; &gt;&gt;&gt; users mailing list<br>
&gt; &gt;&gt;&gt; <a href="mailto:users@open-mpi.org">users@open-mpi.org</a><br>
&gt; &gt;&gt;&gt; <a href="http://www.open-mpi.org/mailman/listinfo.cgi/users" target="_blank">http://www.open-mpi.org/mailman/listinfo.cgi/users</a><br>
&gt; &gt;&gt;<br>
&gt; &gt;&gt;<br>
&gt; &gt; /* A small MPI program, which delivers some information about its<br>
&gt; &gt; * machine, operating system, and some environment variables.<br>
&gt; &gt; *<br>
&gt; &gt; *<br>
&gt; &gt; * Compiling:<br>
&gt; &gt; *   Store executable(s) into local directory.<br>
&gt; &gt; *     mpicc -o &lt;program name&gt; &lt;source code file name&gt;<br>
&gt; &gt; *<br>
&gt; &gt; *   Store executable(s) into predefined directories.<br>
&gt; &gt; *     make<br>
&gt; &gt; *<br>
&gt; &gt; *   Make program(s) automatically on all specified hosts. You must<br>
&gt; &gt; *   edit the file &quot;make_compile&quot; and specify your host names before<br>
&gt; &gt; *   you execute it.<br>
&gt; &gt; *     make_compile<br>
&gt; &gt; *<br>
&gt; &gt; * Running:<br>
&gt; &gt; *   LAM-MPI:<br>
&gt; &gt; *     mpiexec -boot -np &lt;number of processes&gt; &lt;program name&gt;<br>
&gt; &gt; *     or<br>
&gt; &gt; *     mpiexec -boot \<br>
&gt; &gt; *    -host &lt;hostname&gt; -np &lt;number of processes&gt; &lt;program name&gt; : \<br>
&gt; &gt; *    -host &lt;hostname&gt; -np &lt;number of processes&gt; &lt;program name&gt;<br>
&gt; &gt; *     or<br>
&gt; &gt; *     mpiexec -boot [-v] -configfile &lt;application file&gt;<br>
&gt; &gt; *     or<br>
&gt; &gt; *     lamboot [-v] [&lt;host file&gt;]<br>
&gt; &gt; *       mpiexec -np &lt;number of processes&gt; &lt;program name&gt;<br>
&gt; &gt; *    or<br>
&gt; &gt; *    mpiexec [-v] -configfile &lt;application file&gt;<br>
&gt; &gt; *     lamhalt<br>
&gt; &gt; *<br>
&gt; &gt; *   OpenMPI:<br>
&gt; &gt; *     &quot;host1&quot;, &quot;host2&quot;, and so on can all have the same name,<br>
&gt; &gt; *     if you want to start a virtual computer with some virtual<br>
&gt; &gt; *     cpu&#39;s on the local host. The name &quot;localhost&quot; is allowed<br>
&gt; &gt; *     as well.<br>
&gt; &gt; *<br>
&gt; &gt; *     mpiexec -np &lt;number of processes&gt; &lt;program name&gt;<br>
&gt; &gt; *     or<br>
&gt; &gt; *     mpiexec --host &lt;host1,host2,...&gt; \<br>
&gt; &gt; *    -np &lt;number of processes&gt; &lt;program name&gt;<br>
&gt; &gt; *     or<br>
&gt; &gt; *     mpiexec -hostfile &lt;hostfile name&gt; \<br>
&gt; &gt; *    -np &lt;number of processes&gt; &lt;program name&gt;<br>
&gt; &gt; *     or<br>
&gt; &gt; *     mpiexec -app &lt;application file&gt;<br>
&gt; &gt; *<br>
&gt; &gt; * Cleaning:<br>
&gt; &gt; *   local computer:<br>
&gt; &gt; *     rm &lt;program name&gt;<br>
&gt; &gt; *     or<br>
&gt; &gt; *     make clean_all<br>
&gt; &gt; *   on all specified computers (you must edit the file &quot;make_clean_all&quot;<br>
&gt; &gt; *   and specify your host names before you execute it.<br>
&gt; &gt; *     make_clean_all<br>
&gt; &gt; *<br>
&gt; &gt; *<br>
&gt; &gt; * File: environ_mpi.c                       Author: S. Gross<br>
&gt; &gt; * Date: 25.09.2012<br>
&gt; &gt; *<br>
&gt; &gt; */<br>
&gt; &gt;<br>
&gt; &gt; #include &lt;stdio.h&gt;<br>
&gt; &gt; #include &lt;stdlib.h&gt;<br>
&gt; &gt; #include &lt;string.h&gt;<br>
&gt; &gt; #include &lt;unistd.h&gt;<br>
&gt; &gt; #include &lt;sys/utsname.h&gt;<br>
&gt; &gt; #include &quot;mpi.h&quot;<br>
&gt; &gt;<br>
&gt; &gt; #define     BUF_SIZE        8192            /* message buffer size<br>
*/<br>
&gt; &gt; #define     MAX_TASKS       12              /* max. number of tasks<br>
*/<br>
&gt; &gt; #define     SENDTAG         1               /* send message command<br>
*/<br>
&gt; &gt; #define     EXITTAG         2               /* termination command<br>
*/<br>
&gt; &gt; #define     MSGTAG          3               /* normal message token<br>
*/<br>
&gt; &gt;<br>
&gt; &gt; #define ENTASKS             -1              /* error: too many tasks<br>
*/<br>
&gt; &gt;<br>
&gt; &gt; static void master (void);<br>
&gt; &gt; static void slave (void);<br>
&gt; &gt;<br>
&gt; &gt; int main (int argc, char *argv[])<br>
&gt; &gt; {<br>
&gt; &gt;  int  mytid,                                /* my task id<br>
*/<br>
&gt; &gt;       ntasks;                               /* number of parallel tasks<br>
*/<br>
&gt; &gt;<br>
&gt; &gt;  MPI_Init (&amp;argc, &amp;argv);<br>
&gt; &gt;  MPI_Comm_rank (MPI_COMM_WORLD, &amp;mytid);<br>
&gt; &gt;  MPI_Comm_size (MPI_COMM_WORLD, &amp;ntasks);<br>
&gt; &gt;<br>
&gt; &gt;  if (mytid == 0)<br>
&gt; &gt;  {<br>
&gt; &gt;    master ();<br>
&gt; &gt;  }<br>
&gt; &gt;  else<br>
&gt; &gt;  {<br>
&gt; &gt;    slave ();<br>
&gt; &gt;  }<br>
&gt; &gt;  MPI_Finalize ();<br>
&gt; &gt;  return EXIT_SUCCESS;<br>
&gt; &gt; }<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt; /* Function for the &quot;master task&quot;. The master sends a request to all<br>
&gt; &gt; * slaves asking for a message. After receiving and printing the<br>
&gt; &gt; * messages he sends all slaves a termination command.<br>
&gt; &gt; *<br>
&gt; &gt; * input parameters: not necessary<br>
&gt; &gt; * output parameters:        not available<br>
&gt; &gt; * return value:     nothing<br>
&gt; &gt; * side effects:     no side effects<br>
&gt; &gt; *<br>
&gt; &gt; */<br>
&gt; &gt; void master (void)<br>
&gt; &gt; {<br>
&gt; &gt;  int                ntasks,                 /* number of parallel tasks<br>
*/<br>
&gt; &gt;             mytid,                  /* my task id                   */<br>
&gt; &gt;             num,                    /* number of entries            */<br>
&gt; &gt;             i;                      /* loop variable                */<br>
&gt; &gt;  char               buf[BUF_SIZE + 1];      /* message buffer (+1 for &#39;\0&#39;)<br>
*/<br>
&gt; &gt;  MPI_Status stat;                   /* message details              */<br>
&gt; &gt;<br>
&gt; &gt;  MPI_Comm_rank (MPI_COMM_WORLD, &amp;mytid);<br>
&gt; &gt;  MPI_Comm_size (MPI_COMM_WORLD, &amp;ntasks);<br>
&gt; &gt;  if (ntasks &gt; MAX_TASKS)<br>
&gt; &gt;  {<br>
&gt; &gt;    fprintf (stderr, &quot;Error: Too many tasks. Try again with at most &quot;<br>
&gt; &gt;          &quot;%d tasks.\n&quot;, MAX_TASKS);<br>
&gt; &gt;    /* terminate all slave tasks                                     */<br>
&gt; &gt;    for (i = 1; i &lt; ntasks; ++i)<br>
&gt; &gt;    {<br>
&gt; &gt;      MPI_Send ((char *) NULL, 0, MPI_CHAR, i, EXITTAG, MPI_COMM_WORLD);<br>
&gt; &gt;    }<br>
&gt; &gt;    MPI_Finalize ();<br>
&gt; &gt;    exit (ENTASKS);<br>
&gt; &gt;  }<br>
&gt; &gt;  printf (&quot;\n\nNow %d slave tasks are sending their environment.\n\n&quot;,<br>
&gt; &gt;       ntasks - 1);<br>
&gt; &gt;  /* request messages from slave tasks<br>
*/<br>
&gt; &gt;  for (i = 1; i &lt; ntasks; ++i)<br>
&gt; &gt;  {<br>
&gt; &gt;    MPI_Send ((char *) NULL, 0, MPI_CHAR, i, SENDTAG, MPI_COMM_WORLD);<br>
&gt; &gt;  }<br>
&gt; &gt;  /* wait for messages and print greetings<br>
*/<br>
&gt; &gt;  for (i = 1; i &lt; ntasks; ++i)<br>
&gt; &gt;  {<br>
&gt; &gt;    MPI_Recv (buf, BUF_SIZE, MPI_CHAR, MPI_ANY_SOURCE,<br>
&gt; &gt;           MPI_ANY_TAG, MPI_COMM_WORLD, &amp;stat);<br>
&gt; &gt;    MPI_Get_count (&amp;stat, MPI_CHAR, &amp;num);<br>
&gt; &gt;    buf[num] = &#39;\0&#39;;                 /* add missing end-of-string    */<br>
&gt; &gt;    printf (&quot;Environment from task %d:\n&quot;<br>
&gt; &gt;         &quot;  message type:        %d\n&quot;<br>
&gt; &gt;         &quot;  msg length:          %d characters\n&quot;<br>
&gt; &gt;         &quot;  message:             %s\n\n&quot;,<br>
&gt; &gt;         stat.MPI_SOURCE, stat.MPI_TAG, num, buf);<br>
&gt; &gt;  }<br>
&gt; &gt;  /* terminate all slave tasks<br>
*/<br>
&gt; &gt;  for (i = 1; i &lt; ntasks; ++i)<br>
&gt; &gt;  {<br>
&gt; &gt;    MPI_Send ((char *) NULL, 0, MPI_CHAR, i, EXITTAG, MPI_COMM_WORLD);<br>
&gt; &gt;  }<br>
&gt; &gt; }<br>
&gt; &gt;<br>
&gt; &gt;<br>
&gt; &gt; /* Function for &quot;slave tasks&quot;. The slave task sends its hostname,<br>
&gt; &gt; * operating system name and release, and processor architecture<br>
&gt; &gt; * as a message to the master.<br>
&gt; &gt; *<br>
&gt; &gt; * input parameters: not necessary<br>
&gt; &gt; * output parameters:        not available<br>
&gt; &gt; * return value:     nothing<br>
&gt; &gt; * side effects:     no side effects<br>
&gt; &gt; *<br>
&gt; &gt; */<br>
&gt; &gt; void slave (void)<br>
&gt; &gt; {<br>
&gt; &gt;  struct utsname sys_info;           /* system information           */<br>
&gt; &gt;  int                 mytid,                 /* my task id<br>
*/<br>
&gt; &gt;              num_env_vars,          /* # of environment variables   */<br>
&gt; &gt;              i,                     /* loop variable                */<br>
&gt; &gt;              more_to_do;<br>
&gt; &gt;  char                buf[BUF_SIZE],         /* message buffer<br>
*/<br>
&gt; &gt;              *env_vars[] = {&quot;PATH&quot;,<br>
&gt; &gt;                             &quot;LD_LIBRARY_PATH_32&quot;,<br>
&gt; &gt;                             &quot;LD_LIBRARY_PATH_64&quot;,<br>
&gt; &gt;                             &quot;LD_LIBRARY_PATH&quot;,<br>
&gt; &gt;                             &quot;CLASSPATH&quot;};<br>
&gt; &gt;  MPI_Status  stat;                  /* message details              */<br>
&gt; &gt;<br>
&gt; &gt;  MPI_Comm_rank (MPI_COMM_WORLD, &amp;mytid);<br>
&gt; &gt;  num_env_vars = sizeof (env_vars) / sizeof (env_vars[0]);<br>
&gt; &gt;  more_to_do = 1;<br>
&gt; &gt;  while (more_to_do == 1)<br>
&gt; &gt;  {<br>
&gt; &gt;    /* wait for a message from the master task<br>
*/<br>
&gt; &gt;    MPI_Recv (buf, BUF_SIZE, MPI_CHAR, 0, MPI_ANY_TAG,<br>
&gt; &gt;           MPI_COMM_WORLD, &amp;stat);<br>
&gt; &gt;    if (stat.MPI_TAG != EXITTAG)<br>
&gt; &gt;    {<br>
&gt; &gt;      uname (&amp;sys_info);<br>
&gt; &gt;      strcpy (buf, &quot;\n    hostname:          &quot;);<br>
&gt; &gt;      strncpy (buf + strlen (buf), sys_info.nodename,<br>
&gt; &gt;            BUF_SIZE - strlen (buf));<br>
&gt; &gt;      strncpy (buf + strlen (buf), &quot;\n    operating system:  &quot;,<br>
&gt; &gt;            BUF_SIZE - strlen (buf));<br>
&gt; &gt;      strncpy (buf + strlen (buf), sys_info.sysname,<br>
&gt; &gt;            BUF_SIZE - strlen (buf));<br>
&gt; &gt;      strncpy (buf + strlen (buf), &quot;\n    release:           &quot;,<br>
&gt; &gt;            BUF_SIZE - strlen (buf));<br>
&gt; &gt;      strncpy (buf + strlen (buf), sys_info.release,<br>
&gt; &gt;            BUF_SIZE - strlen (buf));<br>
&gt; &gt;      strncpy (buf + strlen (buf), &quot;\n    processor:         &quot;,<br>
&gt; &gt;            BUF_SIZE - strlen (buf));<br>
&gt; &gt;      strncpy (buf + strlen (buf), sys_info.machine,<br>
&gt; &gt;            BUF_SIZE - strlen (buf));<br>
&gt; &gt;      for (i = 0; i &lt; num_env_vars; ++i)<br>
&gt; &gt;      {<br>
&gt; &gt;     char *env_val,                  /* pointer to environment value */<br>
&gt; &gt;          *delimiter = &quot;:&quot;   ,       /* field delimiter for &quot;strtok&quot; */<br>
&gt; &gt;          *next_tok;                 /* next token                   */<br>
&gt; &gt;<br>
&gt; &gt;     env_val = getenv (env_vars[i]);<br>
&gt; &gt;     if (env_val != NULL)<br>
&gt; &gt;     {<br>
&gt; &gt;       if ((strlen (buf) + strlen (env_vars[i]) + 6) &lt; BUF_SIZE)<br>
&gt; &gt;       {<br>
&gt; &gt;         strncpy (buf + strlen (buf), &quot;\n    &quot;,<br>
&gt; &gt;                  BUF_SIZE - strlen (buf));<br>
&gt; &gt;         strncpy (buf + strlen (buf), env_vars[i],<br>
&gt; &gt;                  BUF_SIZE - strlen (buf));<br>
&gt; &gt;       }<br>
&gt; &gt;       else<br>
&gt; &gt;       {<br>
&gt; &gt;         fprintf (stderr, &quot;Buffer too small. Couldn&#39;t add \&quot;%s\&quot;.&quot;<br>
&gt; &gt;                  &quot;\n\n&quot;, env_vars[i]);<br>
&gt; &gt;       }<br>
&gt; &gt;       /* Get first token in &quot;env_val&quot;. &quot;strtok&quot; skips all<br>
&gt; &gt;        * characters that are contained in the current delimiter<br>
&gt; &gt;        * string. If it finds a character which is not contained<br>
&gt; &gt;        * in the delimiter string, it is the start of the first<br>
&gt; &gt;        * token. Now it searches for the next character which is<br>
&gt; &gt;        * part of the delimiter string. If it finds one it will<br>
&gt; &gt;        * overwrite it by a &#39;\0&#39; to terminate the first token.<br>
&gt; &gt;        * Otherwise the token extends to the end of the string.<br>
&gt; &gt;        * Subsequent calls of &quot;strtok&quot; use a NULL pointer as first<br>
&gt; &gt;        * argument and start searching from the saved position<br>
&gt; &gt;        * after the last token. &quot;strtok&quot; returns NULL if it<br>
&gt; &gt;        * couldn&#39;t find a token.<br>
&gt; &gt;        */<br>
&gt; &gt;       next_tok = strtok (env_val, delimiter);<br>
&gt; &gt;       while (next_tok != NULL)<br>
&gt; &gt;       {<br>
&gt; &gt;         if ((strlen (buf) + strlen (next_tok) + 25) &lt; BUF_SIZE)<br>
&gt; &gt;         {<br>
&gt; &gt;           strncpy (buf + strlen (buf), &quot;\n                       &quot;,<br>
&gt; &gt;                    BUF_SIZE - strlen (buf));<br>
&gt; &gt;           strncpy (buf + strlen (buf), next_tok,<br>
&gt; &gt;                    BUF_SIZE - strlen (buf));<br>
&gt; &gt;         }<br>
&gt; &gt;         else<br>
&gt; &gt;         {<br>
&gt; &gt;           fprintf (stderr, &quot;Buffer too small. Couldn&#39;t add \&quot;%s\&quot; &quot;<br>
&gt; &gt;                    &quot;to %s.\n\n&quot;, next_tok, env_vars[i]);<br>
&gt; &gt;         }<br>
&gt; &gt;         /* get next token                                           */<br>
&gt; &gt;         next_tok = strtok (NULL, delimiter);<br>
&gt; &gt;       }<br>
&gt; &gt;     }<br>
&gt; &gt;      }<br>
&gt; &gt;      MPI_Send (buf, strlen (buf), MPI_CHAR, stat.MPI_SOURCE,<br>
&gt; &gt;                     MSGTAG, MPI_COMM_WORLD);<br>
&gt; &gt;    }<br>
&gt; &gt;    else<br>
&gt; &gt;    {<br>
&gt; &gt;      more_to_do = 0;                        /* terminate<br>
*/<br>
&gt; &gt;    }<br>
&gt; &gt;  }<br>
&gt; &gt; }<br>
&gt; &gt; /* A small program, which delivers some information about its<br>
&gt; &gt; * machine, operating system, and some environment variables.<br>
&gt; &gt; *<br>
&gt; &gt; *<br>
&gt; &gt; * Compiling:<br>
&gt; &gt; *   Store executable(s) into local directory.<br>
&gt; &gt; *     (g)cc -o environ_without_mpi environ_without_mpi.c<br>
&gt; &gt; *<br>
&gt; &gt; * Running:<br>
&gt; &gt; *   environ_without_mpi<br>
&gt; &gt; *<br>
&gt; &gt; *<br>
&gt; &gt; * File: environ_without_mpi.c               Author: S. Gross<br>
&gt; &gt; * Date: 25.09.2012<br>
&gt; &gt; *<br>
&gt; &gt; */<br>
&gt; &gt;<br>
&gt; &gt; #include &lt;stdio.h&gt;<br>
&gt; &gt; #include &lt;stdlib.h&gt;<br>
&gt; &gt; #include &lt;string.h&gt;<br>
&gt; &gt; #include &lt;unistd.h&gt;<br>
&gt; &gt; #include &lt;sys/utsname.h&gt;<br>
&gt; &gt;<br>
&gt; &gt; #define     BUF_SIZE        8192            /* message buffer size<br>
*/<br>
&gt; &gt;<br>
&gt; &gt; int main (int argc, char *argv[])<br>
&gt; &gt; {<br>
&gt; &gt;  struct utsname sys_info;           /* system information           */<br>
&gt; &gt;  int                 num_env_vars,          /* # of environment variables<br>
*/<br>
&gt; &gt;              i;                     /* loop variable                */<br>
&gt; &gt;  char                buf[BUF_SIZE],         /* message buffer<br>
*/<br>
&gt; &gt;              *env_vars[] = {&quot;PATH&quot;,<br>
&gt; &gt;                             &quot;LD_LIBRARY_PATH_32&quot;,<br>
&gt; &gt;                             &quot;LD_LIBRARY_PATH_64&quot;,<br>
&gt; &gt;                             &quot;LD_LIBRARY_PATH&quot;,<br>
&gt; &gt;                             &quot;CLASSPATH&quot;};<br>
&gt; &gt;<br>
&gt; &gt;  num_env_vars = sizeof (env_vars) / sizeof (env_vars[0]);<br>
&gt; &gt;  uname (&amp;sys_info);<br>
&gt; &gt;  strcpy (buf, &quot;\n    hostname:          &quot;);<br>
&gt; &gt;  strncpy (buf + strlen (buf), sys_info.nodename,<br>
&gt; &gt;        BUF_SIZE - strlen (buf));<br>
&gt; &gt;  strncpy (buf + strlen (buf), &quot;\n    operating system:  &quot;,<br>
&gt; &gt;        BUF_SIZE - strlen (buf));<br>
&gt; &gt;  strncpy (buf + strlen (buf), sys_info.sysname,<br>
&gt; &gt;        BUF_SIZE - strlen (buf));<br>
&gt; &gt;  strncpy (buf + strlen (buf), &quot;\n    release:           &quot;,<br>
&gt; &gt;        BUF_SIZE - strlen (buf));<br>
&gt; &gt;  strncpy (buf + strlen (buf), sys_info.release,<br>
&gt; &gt;        BUF_SIZE - strlen (buf));<br>
&gt; &gt;  strncpy (buf + strlen (buf), &quot;\n    processor:         &quot;,<br>
&gt; &gt;        BUF_SIZE - strlen (buf));<br>
&gt; &gt;  strncpy (buf + strlen (buf), sys_info.machine,<br>
&gt; &gt;        BUF_SIZE - strlen (buf));<br>
&gt; &gt;  for (i = 0; i &lt; num_env_vars; ++i)<br>
&gt; &gt;  {<br>
&gt; &gt;    char *env_val,                   /* pointer to environment value */<br>
&gt; &gt;      *delimiter = &quot;:&quot;       ,       /* field delimiter for &quot;strtok&quot; */<br>
&gt; &gt;      *next_tok;                     /* next token                   */<br>
&gt; &gt;<br>
&gt; &gt;    env_val = getenv (env_vars[i]);<br>
&gt; &gt;    if (env_val != NULL)<br>
&gt; &gt;    {<br>
&gt; &gt;      if ((strlen (buf) + strlen (env_vars[i]) + 6) &lt; BUF_SIZE)<br>
&gt; &gt;      {<br>
&gt; &gt;     strncpy (buf + strlen (buf), &quot;\n    &quot;,<br>
&gt; &gt;              BUF_SIZE - strlen (buf));<br>
&gt; &gt;     strncpy (buf + strlen (buf), env_vars[i],<br>
&gt; &gt;              BUF_SIZE - strlen (buf));<br>
&gt; &gt;      }<br>
&gt; &gt;      else<br>
&gt; &gt;      {<br>
&gt; &gt;     fprintf (stderr, &quot;Buffer too small. Couldn&#39;t add \&quot;%s\&quot;.&quot;<br>
&gt; &gt;              &quot;\n\n&quot;, env_vars[i]);<br>
&gt; &gt;      }<br>
&gt; &gt;      /* Get first token in &quot;env_val&quot;. &quot;strtok&quot; skips all<br>
&gt; &gt;       * characters that are contained in the current delimiter<br>
&gt; &gt;       * string. If it finds a character which is not contained<br>
&gt; &gt;       * in the delimiter string, it is the start of the first<br>
&gt; &gt;       * token. Now it searches for the next character which is<br>
&gt; &gt;       * part of the delimiter string. If it finds one it will<br>
&gt; &gt;       * overwrite it by a &#39;\0&#39; to terminate the first token.<br>
&gt; &gt;       * Otherwise the token extends to the end of the string.<br>
&gt; &gt;       * Subsequent calls of &quot;strtok&quot; use a NULL pointer as first<br>
&gt; &gt;       * argument and start searching from the saved position<br>
&gt; &gt;       * after the last token. &quot;strtok&quot; returns NULL if it<br>
&gt; &gt;       * couldn&#39;t find a token.<br>
&gt; &gt;       */<br>
&gt; &gt;      next_tok = strtok (env_val, delimiter);<br>
&gt; &gt;      while (next_tok != NULL)<br>
&gt; &gt;      {<br>
&gt; &gt;     if ((strlen (buf) + strlen (next_tok) + 25) &lt; BUF_SIZE)<br>
&gt; &gt;     {<br>
&gt; &gt;       strncpy (buf + strlen (buf), &quot;\n                       &quot;,<br>
&gt; &gt;                BUF_SIZE - strlen (buf));<br>
&gt; &gt;       strncpy (buf + strlen (buf), next_tok,<br>
&gt; &gt;                BUF_SIZE - strlen (buf));<br>
&gt; &gt;     }<br>
&gt; &gt;     else<br>
&gt; &gt;     {<br>
&gt; &gt;       fprintf (stderr, &quot;Buffer too small. Couldn&#39;t add \&quot;%s\&quot; &quot;<br>
&gt; &gt;                &quot;to %s.\n\n&quot;, next_tok, env_vars[i]);<br>
&gt; &gt;     }<br>
&gt; &gt;     /* get next token                                               */<br>
&gt; &gt;     next_tok = strtok (NULL, delimiter);<br>
&gt; &gt;      }<br>
&gt; &gt;    }<br>
&gt; &gt;  }<br>
&gt; &gt;  printf (&quot;Environment:\n&quot;<br>
&gt; &gt;       &quot;  message:             %s\n\n&quot;,  buf);<br>
&gt; &gt;  return EXIT_SUCCESS;<br>
&gt; &gt; }<br>
&gt;<br>
&gt;<br>
<br>
</div></div></blockquote></div><br>

