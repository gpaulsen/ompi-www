<html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Thought about this some more, and I wonder if there isn’t a simpler solution:<div class=""><br class=""></div><div class="">* create a worker pool of userid’s that represents the maximum number of simultaneous users you are willing to support. This could be very large, if you want</div><div class=""><br class=""></div><div class="">* when a worker id becomes available, pull the next email from the inbox, assign it to that worker id, and submit that job to the scheduler for execution</div><div class=""><br class=""></div><div class="">* when the job completes, package the results/output and email them back to the original sender. Then mark the worker id as available.</div><div class=""><br class=""></div><div class="">You’ll still have security issues around the use of Docker, which is why I’d recommend considering Singularity since it doesn’t require nor allow privileged operations - and it doesn’t require integration with the resource manager like Docker does. Singularity knows how to fully package OMPI apps, so it is rather simple to automate the procedure for “containerizing” the user’s app prior to submitting to the scheduler.</div><div class=""><br class=""></div><div class="">HTH</div><div class="">Ralph</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On Jun 6, 2016, at 2:07 AM, John Hearns &lt;<a href="mailto:hearnsj@googlemail.com" class="">hearnsj@googlemail.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><div dir="ltr" class="">Rob, I am not familair with <a href="http://wakari.io/" class="">wakari.io</a><div class=""><br class=""></div><div class="">However what you say about the Unix userid problem is very relevant to many 'shared infrastructure' projects and is a topic which comes up in discussions about them.</div><div class="">Teh concern there is, as you say, if the managers of the system have a global filesystem, with shared datasets, then if virtual clusters are created on the shared infrastructure, or if containers are used, then if the user have root access they can have privileges over the global filesystem.</div><div class=""><br class=""></div><div class="">You are making some very relevant points here.</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="gmail_extra"><br class=""><div class="gmail_quote">On 5 June 2016 at 01:51, Rob Nagler <span dir="ltr" class="">&lt;<a href="mailto:openmpi-wooxi@q33.us" target="_blank" class="">openmpi-wooxi@q33.us</a>&gt;</span> wrote:<br class=""><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div dir="ltr" class=""><div class="gmail_extra">Thanks! SLURM Elastic Computing seems like it might do the trick. I need to try it out.&nbsp;</div><div class="gmail_extra"><br class=""></div><div class="gmail_extra">xCAT is interesting, too. It seems to be the HPC version of Salt'ed Cobbler. :) &nbsp;I don't know that it's so important for our problem. We have a small cluster for testing against the cloud, primarily. I could see xCAT being quite powerful for large clusters.&nbsp;</div><div class="gmail_extra"><br class=""></div><div class="gmail_extra">I'm not sure how to explain the Unix user id problem other than a gmail account does not have a corresponding Unix user id. Nor do you have one for your representation on this mailing list. That decoupling is important. The actual execution of unix processes on behalf of users of gmail, this mailing list, etc. run as a Unix single user. That's how JupyterHub containers run. When you click "Start Server" in JupyterHub, it starts a docker container as some system user (uid=1000 in our case), and the container is given access to the user's files via a Docker volume. The container cannot see any other user's files.&nbsp;</div><div class="gmail_extra"><br class=""></div><div class="gmail_extra">In a typical HPC context, the files are all in /home/&lt;unix-user&gt;. The "containment" is done by normal Unix file permissions. It's very easy, but it doesn't work for web apps as described above. Even being able to list all the other users on a system (via "ls /home") is a privacy breach in a web app.</div><span class="HOEnZb"><font color="#888888" class=""><div class="gmail_extra"><br class=""></div><div class="gmail_extra">Rob</div><div class="gmail_extra"><br class=""></div></font></span></div>
<br class="">_______________________________________________<br class="">
users mailing list<br class="">
<a href="mailto:users@open-mpi.org" class="">users@open-mpi.org</a><br class="">
Subscription: <a href="https://www.open-mpi.org/mailman/listinfo.cgi/users" rel="noreferrer" target="_blank" class="">https://www.open-mpi.org/mailman/listinfo.cgi/users</a><br class="">
Link to this post: <a href="http://www.open-mpi.org/community/lists/users/2016/06/29369.php" rel="noreferrer" target="_blank" class="">http://www.open-mpi.org/community/lists/users/2016/06/29369.php</a><br class=""></blockquote></div><br class=""></div></div>
_______________________________________________<br class="">users mailing list<br class=""><a href="mailto:users@open-mpi.org" class="">users@open-mpi.org</a><br class="">Subscription: https://www.open-mpi.org/mailman/listinfo.cgi/users<br class="">Link to this post: http://www.open-mpi.org/community/lists/users/2016/06/29377.php</div></blockquote></div><br class=""></div></body></html>
