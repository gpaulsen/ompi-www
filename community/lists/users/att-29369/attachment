<div dir="ltr"><div class="gmail_extra">Thanks! SLURM Elastic Computing seems like it might do the trick. I need to try it out. </div><div class="gmail_extra"><br></div><div class="gmail_extra">xCAT is interesting, too. It seems to be the HPC version of Salt&#39;ed Cobbler. :)  I don&#39;t know that it&#39;s so important for our problem. We have a small cluster for testing against the cloud, primarily. I could see xCAT being quite powerful for large clusters. </div><div class="gmail_extra"><br></div><div class="gmail_extra">I&#39;m not sure how to explain the Unix user id problem other than a gmail account does not have a corresponding Unix user id. Nor do you have one for your representation on this mailing list. That decoupling is important. The actual execution of unix processes on behalf of users of gmail, this mailing list, etc. run as a Unix single user. That&#39;s how JupyterHub containers run. When you click &quot;Start Server&quot; in JupyterHub, it starts a docker container as some system user (uid=1000 in our case), and the container is given access to the user&#39;s files via a Docker volume. The container cannot see any other user&#39;s files. </div><div class="gmail_extra"><br></div><div class="gmail_extra">In a typical HPC context, the files are all in /home/&lt;unix-user&gt;. The &quot;containment&quot; is done by normal Unix file permissions. It&#39;s very easy, but it doesn&#39;t work for web apps as described above. Even being able to list all the other users on a system (via &quot;ls /home&quot;) is a privacy breach in a web app.</div><div class="gmail_extra"><br></div><div class="gmail_extra">Rob</div><div class="gmail_extra"><br></div></div>

