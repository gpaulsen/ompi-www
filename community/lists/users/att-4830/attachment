Hi, <br>I am trying to write a simple code which does the following - <br>A master process running on &#39;n&#39; processors spawn 4 processes using the MPI_Comm_spawn_multiple command. After spawning, the intercommunicator between the master and the spawned processes are merged using MPI_Intercomm_merge to create a new common intracommunicator for the expanded set of processes. These steps are repeated over a loop - execute the master processes, spawn new processes, and merge the communicators to get a global communicator. 
<br>In this example the new processes are always spawned on the same 4 nodes.<br><br>After the loop is completed, when I call MPI_Finalize, I get a segmentation fault. I do not get segmentation fault if I run the loop only once, 
i.e.call MPI_Intercomm_merge only once.<br>Is there something wrong with my program or is it a known issue with MPI_Intercomm_merge when called multiple times? <br><br>I have pasted the sample code below. It has 3 files - 
master.c, spawn.c, hello.c. I will be glad to clarify if anything looks confusing. Any help will be appreciated.<br><br>/****************************************************************************************/<br>Master function. This function calls MPI_Comm_spawn_multiple the first time. (
master.c)<br>/*****************************************************************************************/<br><br>/*Global variables*/<br>MPI_Comm grid_comm; /*new global communicator after spawning*/<br>int loop=0; /*number of iterations*/
<br>int newprocess = -1;&nbsp; /* Variable to identify whether the current process is an old process or a spawned process.*/<br><br><br>int main (int argc, char ** argv)<br>{<br><br>&nbsp; int size,rank;<br><br>&nbsp; MPI_Init(&amp;argc, &amp;argv);
<br><br>&nbsp; grid_comm=MPI_COMM_WORLD;<br><br>&nbsp; newprocess=0;<br><br>&nbsp; for( ;loop &lt; 2; loop++){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stdout,&quot;\n\nLOOP in main =%d\n&quot;,loop);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpicomm_spawn();<br><br>&nbsp;&nbsp;&nbsp;&nbsp; /*Broacasting the loop value to spawned processes so that the new processes 
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; join the next iteration with the correct loop value.*/<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; MPI_Bcast(&amp;loop,1,MPI_INT,0,grid_comm);<br><br>&nbsp; &nbsp; &nbsp;&nbsp; MPI_Comm_size(grid_comm, &amp;size);<br>&nbsp;&nbsp; &nbsp; &nbsp; MPI_Comm_rank(grid_comm, &amp;rank);
<br>&nbsp;&nbsp; }<br><br>&nbsp; fprintf(stdout,&quot;Exiting...main..rank=%d\n&quot;,rank); fflush(stdout);<br>&nbsp; MPI_Barrier(grid_comm);<br>&nbsp; MPI_Comm_free(&amp;grid_comm);<br>&nbsp; MPI_Finalize();<br>}<br><br><br><br>/**********************/
<br>Spawning function (spawn.c)<br>/********************/<br><br>extern MPI_Comm grid_comm;<br><br>int mpicomm_spawn()<br>{<br><br>&nbsp; MPI_Comm parent, intercomm;<br>&nbsp; int rank, nprocs=4, size,nspawned;<br>&nbsp; MPI_Info info[4];
<br>&nbsp; char *host = (char *) &quot;host&quot;; /*String to be stored as a key in MPI_Info*/<br><br>&nbsp; char *commands[4];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*Stores the array of executable names to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be spawned*/
<br>&nbsp; int maxprocs[4];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*maximum number of processes that can be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; spawned on each process.*/<br>&nbsp; char ***args=NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*array of arguments for each executable*/
<br>&nbsp; int i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*loop counter*/<br>&nbsp; char nodenames[4][50];<br><br><br>&nbsp; MPI_Comm_get_parent(&amp;parent);<br><br>&nbsp;&nbsp; if(newprocess==0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*Master processes*/<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(nodenames[0],&quot;n1009&quot;);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(nodenames[1],&quot;n1010&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(nodenames[2],&quot;n1011&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(nodenames[3],&quot;n1012&quot;);<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;4;i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commands[i]=(char*)malloc(sizeof(char)*50);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(commands[i],&quot;./hello&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxprocs[i]=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MPI_Info_create (&amp;info[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MPI_Info_set (info[i], host, nodenames[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nspawned&nbsp; = MPI_Comm_spawn_multiple(nprocs, commands, args, maxprocs, info, 0, grid_comm,&nbsp; &amp;intercomm, MPI_ERRCODES_IGNORE);
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MPI_Intercomm_merge(intercomm, 0, &amp;grid_comm);<br>&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This part of the code is executed by the newly spawned process*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newprocess=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MPI_Intercomm_merge(parent, 1, &amp;grid_comm);
<br>&nbsp;&nbsp; }<br><br>}<br><br><br>/*******************************************************/<br>Function that needs to be called while spawning (hello.c)<br>/********************************************************/<br><br>/*Global variables*/
<br>MPI_Comm grid_comm; /*new global communicator after spawning*/<br>
int loop=0; /*number of iterations*/<br>
int newprocess = -1;&nbsp; /* Variable to identify whether the current process is an old process or a spawned process.*/<br><br>int main (int argc, char **argv)<br>{<br>&nbsp;&nbsp; int myrank,size;<br><br>&nbsp;&nbsp; MPI_Init(&amp;argc, &amp;argv);
<br>&nbsp;&nbsp; while(loop&lt;2){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(newprocess!=0){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newprocess=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpicomm_spawn();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpicomm_spawn();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MPI_Comm_rank(grid_comm, &amp;myrank);
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MPI_Bcast(&amp;loop,1,MPI_INT,0,grid_comm);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stdout,&quot;\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;LOOP in hello = %d..Myrank=%d\n&quot;,loop,myrank);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MPI_Comm_size(grid_comm, &amp;size);
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop++;<br>&nbsp;&nbsp; }<br><br>&nbsp;&nbsp; MPI_Comm_rank(grid_comm, &amp;myrank);<br><br>&nbsp;&nbsp; fprintf(stdout,&quot;Exiting worker..rank=%d\n&quot;,myrank);fflush(stdout);<br>&nbsp;&nbsp; MPI_Barrier(grid_comm);<br><br>&nbsp;&nbsp; MPI_Comm_free(&amp;grid_comm);
<br>&nbsp;&nbsp; MPI_Finalize();<br>}<br><br>Thanks.<br>Regarads,<br>Rajesh<br>

