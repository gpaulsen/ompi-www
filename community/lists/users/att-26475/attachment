<html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Thomas,<div class=""><br class=""></div><div class="">The struct idea makes perfect sense. As apparently you have multiple&nbsp;<span style="font-family: CourierNewPSMT;" class="">local_tlr_lookup</span>&nbsp;the current approach will certainly not work. As you mentioned the allocatable arrays do not have similar relative displacements, and this prevent the derived datatype from being correctly constructed. Moreover, in order to be able to build a consistent datatype with a repetition count, one must suppose that your “nat" is a constant. &nbsp;You then have 2 possible approaches:</div><div class=""><br class=""></div><div class="">1. Get rid of the allocatable arrays in the tlr_lut structure. (this is an easy solution but not very flexible).</div><div class=""><br class=""></div><div class="">2. (Spoiler alert: I have no idea how to implement this in Fortran, but this is a regular trick for C programmers). Reshape your structure to have all fixed size elements in the beginning, and the only variable size one at the end (in your case this require to move the dTLRdr at the end of the struct). Then allocate a memory area large enough to hold all your structures, and the the pointers manually (also each datatype will have to be resized at the correct length). Let me give you an example (in C)</div><div class=""><br class=""></div><div class="">typedef struct my_t {</div><div class="">&nbsp; int a;</div><div class="">&nbsp; double b[1];</div><div class="">} my_t;</div><div class=""><br class=""></div><div class="">/* suppose the maximum size of the d component is NMAX (3*3*nat*3), and that</div><div class="">&nbsp;* I dare allocate a little extra memory (in case the d’s are not all of the</div><div class="">&nbsp;* same size).</div><div class="">&nbsp;*/</div><div class="">size_t my_struct_size = (sizeof(my_t) + NMAX * sizeof(double)) * nb_elements;</div><div class="">my_t* elements = (my_t*)malloc(my_struct_size);</div><div class="">/* it is now unsafe to access elements[i] but I can build a datatype that match */</div><div class="">displ[0] = &amp;elements[0].a - &amp;element[0];</div><div class="">displ[1] = &amp;elements[0].d - &amp;element[0];</div><div class="">types[0] = MPI_INT;</div><div class="">types[1] = MPI_DOUBLE;</div><div class="">bl[0] = 1;</div><div class="">bl[1] = NMAX;</div><div class="">/* create the base struct bstr*/</div><div class="">MPI_Type_create_resized(bstr, 0, my_size_struct, &amp;my_mpi_dt);</div><div class="">/* you can now send using my_mpi_dt and a count */</div><div class=""><br class=""></div><div class="">Good luck ? ;)</div><div class=""><br class=""></div><div style="font-family: CourierNewPSMT;" class="">&nbsp; George.</div><div style="font-family: CourierNewPSMT;" class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On Mar 15, 2015, at 19:50 , Thomas Markovich &lt;<a href="mailto:thomasmarkovich@gmail.com" class="">thomasmarkovich@gmail.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><div dir="ltr" class="">Hi George,<br class=""><br class="">Thanks for taking the time to look at my question! wtlr was a typo when I was stripping things down for a smaller example... TLR should be a 3x3 matrix (long range dipole dipole tensor).&nbsp;<div class=""><br class=""></div><div class="">I'm trying to split up the computation of anywhere between 30k and 15m individual dipole-dipole tensors, and I figured that I'd use a struct to help with the book keeping. It appears that having an allocatable tensor (dTLRdr) throws a wrench in the whole thing. When I looked more into the memory layout with totalview, it looks like the various dTLRdR isn't even contiguously connected with the rest of the array! This is supported by the fact that my offsets for each dTLRdr ( offset of tlr_lookup(1)%dTLRdr,&nbsp;tlr_lookup(2)%dTLRdr,&nbsp;tlr_lookup(3)%dTLRdr) are different. Unfortunately, I'm not totally sure that it's possible to do what I was trying to do. I'm going to try a different strategy that sidesteps this issue of derived data types, though. Perhaps that'll help.</div><div class=""><br class=""></div><div class="">Best,</div><div class="">Thomas</div></div><br class=""><div class="gmail_quote">On Sun, Mar 15, 2015 at 9:00 PM George Bosilca &lt;<a href="mailto:bosilca@icl.utk.edu" class="">bosilca@icl.utk.edu</a>&gt; wrote:<br class=""><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div dir="ltr" class="">Thomas,<div class=""><br class=""></div><div class="">IWhat exactly is '<span style="font-size:12.8000001907349px" class="">local_tlr_</span><span style="font-size:12.8000001907349px" class="">lookup(1)%wtlr'?</span></div><div class=""><span style="font-size:12.8000001907349px" class=""><br class=""></span></div><div class=""><span style="font-size:12.8000001907349px" class="">I think the problem is that your MPI derived datatype use the pointer to the allocatable arrays instead of using the pointer to the first element of these arrays. As an example instead of doing</span></div><div class=""><span style="font-size:12.8000001907349px" class="">call mpi_get_address(local_tlr_</span><span style="font-size:12.8000001907349px" class="">lookup(1)%wtlr, &nbsp; &nbsp; &nbsp; offsets(3), ierr)</span><span style="font-size:12.8000001907349px" class=""><br class=""></span></div><div class=""><span style="font-size:12.8000001907349px" class="">I would go for</span></div><div class=""><span style="font-size:12.8000001907349px" class="">call mpi_get_address(local_tlr_</span><span style="font-size:12.8000001907349px" class="">lookup(1)%</span><span style="font-size:12.8000001907349px" class="">TLR(1,1)</span><span style="font-size:12.8000001907349px" class="">, &nbsp; &nbsp; &nbsp; offsets(3), ierr)</span><span style="font-size:12.8000001907349px" class=""><br class=""></span></div><div class=""><span style="font-size:12.8000001907349px" class=""><br class=""></span></div><div class=""><span style="font-size:12.8000001907349px" class="">Then you don't have to&nbsp;subtract&nbsp;offset(1) from the other, but instead you can go for absolute addressing. Unfortunately this approach is not compatible with sending multiple structures (aka. using a count != 1), simply because each struct might have different displacements for the internal allocatable arrays.</span></div><div class=""><span style="font-size:12.8000001907349px" class=""><br class=""></span></div><div class=""><span style="font-size:12.8000001907349px" class="">&nbsp; George.</span></div><div class=""><span style="font-size:12.8000001907349px" class=""><br class=""></span></div><div class=""><span style="font-size:12.8000001907349px" class=""><br class=""></span></div></div><div class="gmail_extra"><br class=""><div class="gmail_quote"></div></div><div class="gmail_extra"><div class="gmail_quote">On Sun, Mar 15, 2015 at 3:45 PM, Thomas Markovich <span dir="ltr" class="">&lt;<a href="mailto:thomasmarkovich@gmail.com" target="_blank" class="">thomasmarkovich@gmail.com</a>&gt;</span> wrote:<br class=""></div></div><div class="gmail_extra"><div class="gmail_quote"><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div dir="ltr" class=""><div class="">Hi All,</div><div class=""><br class=""></div><div class="">I'm trying to parallelize my code by distributing the computation of various elements of a lookup table and then sync that lookup table across all nodes. To make the code easier to read, and to keep track of everything easier, I've decided to use a derived data type in fortran defined as follows:</div><div class="">&nbsp; &nbsp; type tlr_lut</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; sequence</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; integer p</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; integer q</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; real(dp), dimension(3, 3) :: TLR</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; real(dp), dimension(:, :, :, :) :: dTLRdr</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; real(dp), dimension(3, 3, 3, 3) :: dTLRdh</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; integer unique_ind</div><div class="">&nbsp; &nbsp; end type tlr_lut</div><div class=""><br class=""></div><div class="">and this works quite well in serial. I just have to allocate dTLRdr at run time. This is because TLR should be size 3x3xNx3, where N is a constant known at run time but not compile time. I've tried to create a custom data type to tell open-mpi what the size should be but I'm at a loss for how to deal with the allocatable array. I've tried something like this:</div><div class=""><br class=""></div><div class="">type(tlr_lut), dimension(:), allocatable :: tlr_lookup, temp_tlr_lookup</div><div class="">type(tlr_lut), dimension(:), allocatable :: local_tlr_lookup</div><div class="">integer :: datatype, oldtypes(6), blockcounts(6)&nbsp;</div><div class="">INTEGER(KIND=MPI_ADDRESS_KIND) :: offsets(6)</div><div class="">integer :: numtasks, rank, i, &nbsp;ierr&nbsp;</div><div class="">integer :: n, status(mpi_status_size)</div><div class=""><br class=""></div><div class="">do i = 1, num_pairs, 1</div><div class="">&nbsp; &nbsp; p = unique_pairs(i)%p</div><div class="">&nbsp; &nbsp; q = unique_pairs(i)%q</div><div class="">&nbsp; &nbsp; cpuid = unique_pairs(i)%cpu</div><div class="">&nbsp; &nbsp; if(<a href="http://cpuid.eq.me" class="">cpuid.eq.me</a>_image) then</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; TLR = 0.0_DP</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; dTLRdr = 0.0_DP</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; dTLRdh = 0.0_DP</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; call mbdvdw_TLR(p, q, TLR, dTLRdr, dTLRdh)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; if(.not.allocated(local_tlr_lookup(counter)%dTLRdr)) allocate(local_tlr_lookup(counter)%dTLRdr(3, 3, nat, 3))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; local_tlr_lookup(counter)%p = p</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; local_tlr_lookup(counter)%q = q</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; local_tlr_lookup(counter)%TLR(:, :) = TLR(:, :)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; local_tlr_lookup(counter)%dTLRdr(:,:,:,:) = dTLRdR(:,:,:,:)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; local_tlr_lookup(counter)%dTLRdh(:,:,:,:) = dTLRdh(:,:,:,:)</div><div class="">&nbsp; &nbsp; end if</div><div class="">end do</div><div class=""><br class=""></div><div class="">call mpi_get_address(local_tlr_lookup(1)%p, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offsets(1), ierr)</div><div class="">call mpi_get_address(local_tlr_lookup(1)%q, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offsets(2), ierr)</div><div class="">call mpi_get_address(local_tlr_lookup(1)%wtlr, &nbsp; &nbsp; &nbsp; offsets(3), ierr)</div><div class="">call mpi_get_address(local_tlr_lookup(1)%wdtlrdr, &nbsp; &nbsp;offsets(4), ierr)</div><div class="">call mpi_get_address(local_tlr_lookup(1)%wdtlrdh, &nbsp; &nbsp;offsets(5), ierr)</div><div class="">call mpi_get_address(local_tlr_lookup(1)%unique_ind, offsets(6), ierr)</div><div class=""><br class=""></div><div class="">do i = 2, size(offsets)</div><div class="">&nbsp; offsets(i) = offsets(i) - offsets(1)</div><div class="">end do</div><div class="">offsets(1) = 0</div><div class=""><br class=""></div><div class="">oldtypes = (/mpi_integer, mpi_integer, mpi_real, mpi_real, mpi_real, mpi_integer/)</div><div class="">blockcounts = (/1, 1, 3*3, 3*3*nat*3, 3*3*3*3, 1/)</div><div class=""><br class=""></div><div class="">But it didn't seem to work and I'm sorta at a loss. Any suggestions?</div><div class=""><br class=""></div><div class="">Best,</div><div class="">Thomas</div></div>
<br class=""></blockquote></div></div><div class="gmail_extra"><div class="gmail_quote"><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">_______________________________________________<br class="">
users mailing list<br class="">
<a href="mailto:users@open-mpi.org" target="_blank" class="">users@open-mpi.org</a><br class="">
Subscription: <a href="http://www.open-mpi.org/mailman/listinfo.cgi/users" target="_blank" class="">http://www.open-mpi.org/mailman/listinfo.cgi/users</a><br class="">
Link to this post: <a href="http://www.open-mpi.org/community/lists/users/2015/03/26472.php" target="_blank" class="">http://www.open-mpi.org/community/lists/users/2015/03/26472.php</a><br class=""></blockquote></div><br class=""></div>
______________________________<u class=""></u>_________________<br class="">
users mailing list<br class="">
<a href="mailto:users@open-mpi.org" target="_blank" class="">users@open-mpi.org</a><br class="">
Subscription: <a href="http://www.open-mpi.org/mailman/listinfo.cgi/users" target="_blank" class="">http://www.open-mpi.org/<u class=""></u>mailman/listinfo.cgi/users</a><br class="">
Link to this post: <a href="http://www.open-mpi.org/community/lists/users/2015/03/26473.php" target="_blank" class="">http://www.open-mpi.org/<u class=""></u>community/lists/users/2015/03/<u class=""></u>26473.php</a></blockquote></div>
_______________________________________________<br class="">users mailing list<br class=""><a href="mailto:users@open-mpi.org" class="">users@open-mpi.org</a><br class="">Subscription: http://www.open-mpi.org/mailman/listinfo.cgi/users<br class="">Link to this post: http://www.open-mpi.org/community/lists/users/2015/03/26474.php</div></blockquote></div><br class=""></div></body></html>
