<div dir="ltr"><div class="gmail_extra"><div class="gmail_quote"><div>Ralph, </div><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div style="word-wrap:break-word"><div><span class=""><blockquote type="cite"><div></div></blockquote></span>FWIW: I haven’t seen it before.</div></div></blockquote><div><br></div><div>Good to know. </div><div> </div><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div style="word-wrap:break-word"><div><span class=""><blockquote type="cite"><div dir="ltr"><div class="gmail_extra"></div></div></blockquote><div><br></div></span>Not sure I understand the issue, but I have no knowledge of Jupyter or why you are using it. From what I can see, it appears that your choice of tools may be complicating your solution - I’d suggest perhaps focusing on solving the problem rather than trying to force-fit your current tools, but that presumes you don’t have some particular attachment to those tools.</div></div></blockquote><div><br></div><div>No attachment to particular tools. This is a greenfield project. As to Jupyter, it&#39;s fairly simple. JupyterHub launches Jupyter in a Docker container with the user&#39;s directory, e.g. /var/nfs/jupyter/robnagler gets mounted /home/docker-user. Then the user can bring a up a terminal and work within the container as if they ssh&#39;ed into the container, but without having to run ssh. </div><div><br></div><div>Think of JupyterHub as way to provide login nodes without having a corresponding Unix user.</div><div><br></div><div> </div><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div style="word-wrap:break-word"><div><span class=""><div><br></div></span>That isn’t the security hole - the issue is that Docker doesn’t prevent the user from taking privileged state, which means the user can become root. Yes, it is within that container - but the network and other 3rd party services can be vulnerable. Cgroups doesn’t really solve that problem as it still thinks the user is the one you originally set for the container, and constrains resources that way - but it doesn’t do authentication protection.</div></div></blockquote><div><br></div><div>I think <a href="https://docs.docker.com/engine/reference/commandline/daemon/#daemon-user-namespace-options">user namespaces</a> (Docker 1.10)  helps mitigate privilege escalation/container escape issues. You can become root in the container, but outside the container, you are some other user, like NFS&#39;s root_squash. Docker by default does contain the network and other devices. I don&#39;t really know what MPI would require, but it seems to work with TCP sockets, which don&#39;t allow spoofing.</div><div><br></div><div>One thing I&#39;m assuming with all this is that people who run containers on Docker Hub, Travis, Terminal.com, etc. have similar problems. They are running jobs on behalf of web users (like our problem) as a single unix user id. Docker Hub runs containers as root to build images so they must be able to lock down containers well enough.</div><div><br></div><div>Another thing we can (and probably should) do is verify the images have no setuid files. I think this would eliminate a lot of the privilege escalation issues.</div><div><br></div><div>Rob<br></div><div><br></div></div><br></div></div>

